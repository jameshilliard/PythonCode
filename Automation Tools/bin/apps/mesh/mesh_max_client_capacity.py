#mesh_max_client_capacity
#
# Objective: Measures the maximum number of clients that a mesh network can
#            support while meeting it's SLA under typical web traffic.
#
import sys, time, traceback, math
from basetest import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *
from odict import *

#Global paramters
FlowPattern = Enum("up down both")

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,   1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,   4 ),
                         'WT90_W3': ( 'wt-tga-xx-xx', 4, 0,  11 ),
                         'WT90_W4': ( 'wt-tga-xx-xx', 5, 0,  54 )
                       }


        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}
          
        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of 00:00:00:00:00:00
                       tells the system to pick the first on on the list.
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """
        self.EthernetClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.0.10', '255.255.0.0', '192.168.0.1', (), Security_None, {} )] 
        #Hop 1 is the closest to the Etherent, while hop 10 is the farthest
        self.WirelessClients    = [ [], [], [], [], [], [], [], [], [], [] ]
        self.WirelessClients[1] = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.10.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions)]
        self.WirelessClients[2] = [ ('ClientDue', 'WT90_W2', '00:00:00:00:00:00', 'DEFAULT', '192.168.20.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions)] 

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds.
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. RFC2544 recommends 2 seconds.  Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        self.Trials              =  3 
        self.TransmitTime        = 10.0
        self.SettleTime          =  2.0
        self.AgingTime           =  2.0

        ##################  Goal Seeking parameters  ##############################
        """
        The goal seeking parameters are used to define how the goal seeking algorithm will arrive at a solution.
        SearchMinimum -           The lower boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values less than this.  Unit is in clients.  Setting the minimum to zero tells the algorithm
                                  to try all the way to the SearchResolutionCount.
        SearchMaximum -           The upper boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values higher than this.  The binary search algorithm will use this as the inital value.
                                  If it passed, then the test is complete.  Otherwise the next value is half way between
                                  the SearchMinimum and SearchMaximum.  Unit is in clients.
        SearchResolutionCount -   Determines how precise the search for the final result needs to be. For instance,
                                  a value of 1 means that the search will stop if the current result is within 1 client 
                                  of the previous iteration result. 
        SLAAcceptLossPercent -    Determines how much packet loss will be acceptable in seeking the throughput result. 
                                  Ordinarily, throughput is defined as the maximum forwarding rate with zero frame loss.
                                  However, since 802.11 is a lossy medium it may not be possible in some circumstances to
                                  achieve zero frame loss. This parameter can be used in those situations to allow the search
                                  process to obtain the throughput goal.
        SLAMinimumThroughput -    Specifics the mininum ganurentee download speed in bps.  The upload will be running about 5%
                                  the download speed (Simulatinf ACKs for streaming data).
        SLAMaximumLatency -       The maximum latency allowed before the user says "F@ck this" and calls the Help Desk.  Unit
                                  represents time in seconds.  The script recognizes SI units of m, u, n, p, and f (knock yourself
                                  out if you want to specify latency in femtoseconds).
        """
        self.SearchMinimum         = 0
        self.SearchMaximum         = 200
        self.SearchResolutionCount = 1
        
        self.SLAAcceptLossPercent = 0.0
        self.SLAMinimumThroughput = '256K'
        self.SLAMaximumLatency    = '100m'

        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at the configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 1
        self.FlowLearningRate   = 100

        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the test details. This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_mesh_max_client_capacity.csv'
        self.ReportFilename   = 'Report_mesh_max_client_capacity.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_mesh_max_client_capacity.csv'

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  20.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  50.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =   0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability']  =   0


########################## DO NOT MODIFY BELOW HERE ##########################

        #################  Hard coded parameters  #################################
        """
        These parameters are not exposed to user yet.   
        
        FlowOptions -   Dictionary of options used to configure data flows. 
                        Field Definitions:
                            Type     - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP'
                            srcPort  - Source Port number used in the UDP or TCP header
                            destPort - Destination Port number used in the UDP or TCP header
                            PhyRate  - The PhyRate for wireless cards.  Separate from the management frames.
        FlowDirection - Deteremide the direction of the flows:
                            up   - Wireless to Etherenet
                            down - Etherenet to Wireless
                            both - Bidirectional ( up + down )
        """
        #Simulate Web traffic
        self.FrameSizeUpstream   = 88
        self.FrameSizeDownstream = 1518
        self.TCPportUpstream     = 80
        self.TCPportDownstream   = 32767
        self.FlowOptions         = {'Type': 'TCP', 'PhyRate': 54 }
        self.FlowDirection       = FlowPattern.both

        # Include the version 
        self.version = '$Revision: 1.5 $' 
        self.date    = '$Date: 2007/07/12 23:53:08 $' 

    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
        # FIXME - support for the new client objects 
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore )
        #These are the test specific parameters that get passed down from the GUI for the test execution
        self.SearchResolutionPercent = float(waveTestSpecificStore['unicast_unidirectional_throughput']['SearchResolution'])
        if waveTestSpecificStore['unicast_unidirectional_throughput']['MinSearchValue'] == "Default":
            self.SearchMinimum = None
        else:
            self.SearchMinimum = waveTestSpecificStore['unicast_unidirectional_throughput']['MinSearchValue']
        if waveTestSpecificStore['unicast_unidirectional_throughput']['MaxSearchValue'] == "Default":
            self.SearchMaximum = None
        else:
            self.SearchMaximum = waveTestSpecificStore['unicast_unidirectional_throughput']['MaxSearchValue']
        
        self.SearchAcceptLossPercent = float(waveTestStore['TestParameters']['LossTolerance'])
        frameSizeList = waveTestSpecificStore['unicast_unidirectional_throughput']['FrameSizeList']
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
        # all good
        return True

    def BuildClientTable(self, Count=None):
        self.SourceClients = []
        self.DestClients   = []

        #Count the active hops
        ActiveHops = 0
        for eachhHop in self.WirelessClients:
            if len(eachhHop) > 0:
                ActiveHops += 1
        if Count == None:
            ClientsPerHop = 1.0
            HopIndex      = 0
        else:
            ClientsPerHop = float(Count) / float(ActiveHops)
            HopIndex      = Count % ActiveHops
   
        #Build the ethernet client table
        if self.FlowDirection == FlowPattern.up:
            self.DestClients = self.EthernetClients[:]
        else:
            self.SourceClients = self.EthernetClients[:]

        #Build the wireless client table
        HopCount = 0
        for eachHop in self.WirelessClients:
            if len(eachHop) == 0:
                continue
            if HopCount >= HopIndex:
                ClientsThisGroup = int(math.floor(ClientsPerHop))
            else:
                ClientsThisGroup = int(math.ceil(ClientsPerHop))
            HopCount       += 1
            ClientsPerGroup = ClientsThisGroup / float(len(eachHop))
            TotalHopClients = 0
            HopClients      = 1
            for eachGroup in eachHop:
                (BaseName, PortName, BSSID, MACaddr, IPaddr, Subnet, Gateway, IncrTuple, SecurityOptions, ClientOptions) = eachGroup
                if Count == None:
                    IncrTuple = ()
                    IncrCount = 1
                else:
                    if len(IncrTuple) == 3:
                        (IncrCount, IncrMAC, IncrIP) = IncrTuple
                    else:
                        IncrMAC = "DEFAULT"
                        IncrIP  = "0.0.0.1"
                    if HopClients * ClientsPerGroup >= TotalHopClients:
                        IncrCount = int(math.ceil(ClientsPerGroup))
                    else:
                        IncrCount = int(math.floor(ClientsPerGroup))
                    TotalHopClients += IncrCount
                    HopClients += 1
                    IncrTuple = (IncrCount, IncrMAC, IncrIP)
                if IncrCount > 0 :           
                    #print "  ", BaseName, IncrCount
                    if self.FlowDirection == FlowPattern.up:
                        self.SourceClients.append((BaseName, PortName, BSSID, MACaddr, IPaddr, Subnet, Gateway, IncrTuple, SecurityOptions, ClientOptions), )
                    else:
                        self.DestClients.append((BaseName, PortName, BSSID, MACaddr, IPaddr, Subnet, Gateway, IncrTuple, SecurityOptions, ClientOptions), )

    def ClearExsistingClientsFlows(self):
        #Destroy all the flow group names, flow names, mc names and ec names from
        #a previous run
        for fgname in flowGroup.getNames():
            WaveEngine.VCLtest("action.stopFlowGroup('%s')" % (fgname) )
            WaveEngine.VCLtest("flowGroup.destroy('%s')" % (fgname) )
        for flowname in flow.getNames():
            WaveEngine.VCLtest("flow.destroy('%s')" % (flowname) )
        for name in mc.getNames():
            WaveEngine.VCLtest("mc.deauthenticate('%s', 1)" % (name) )
            WaveEngine.VCLtest("mc.destroy('%s')" % (name) )
        for name in ec.getNames():
            WaveEngine.VCLtest("ec.destroy('%s')" % (name) )

    def configureFlows(self):
        # Set the flows up initally with the learning paramters
        self.FlowOptions['NumFrames']    = int( self.FlowLearningTime * self.FlowLearningRate)
        self.FlowOptions['IntendedRate'] = self.FlowLearningRate
        self.FlowOptions['RateMode']     = 'pps'
        self.FlowOptions['Type']      = 'TCP'
        self.FlowOptions['srcPort']   = int(self.TCPportDownstream)
        self.FlowOptions['destPort']  = int(self.TCPportUpstream)
        self.FlowOptions['FrameSize'] = int(self.FrameSizeDownstream)

        FlowsUp = WaveEngine.CreateFlows_PartialMesh(self.ListofSrcClient,  self.ListofDesClient,  False, self.FlowOptions)
        self.FlowList = FlowsUp.copy()

        if self.FlowDirection == FlowPattern.both:
            self.FlowOptions['srcPort']   = int(self.TCPportUpstream)
            self.FlowOptions['destPort']  = int(self.TCPportDownstream)
            self.FlowOptions['FrameSize'] = int(self.FrameSizeUpstream)
            FlowsDown = WaveEngine.CreateFlows_PartialMesh(self.ListofDesClient,  self.ListofSrcClient,  False, self.FlowOptions)
            self.FlowList.update(FlowsDown)
                
        self._createFlowGroup(self.FlowList, "XmitGroup")
        self.TotalFlows = len(self.FlowList)
            
    def connectClients(self):
        AssociateRate     = float(self.AssociateRate)
        AssociateRetries  = float(self.AssociateRetries)
        AssociateTimeout  = float(self.AssociateTimeout)
        TotalTimeout = self.TotalClients/AssociateRate + AssociateTimeout
        return WaveEngine.ConnectClients(self.ListOfClients, AssociateRate, AssociateRetries, AssociateTimeout, TotalTimeout)

    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters):
        TotalTX = 0
        TotalRX = 0
        PktType = PassedParameters['Type'] 
        bpf = PassedParameters['BitsPerFrame']
        for Portname in PassedParameters['CardList']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname))
            if PktType == 'TCP':
                TotalTX += stats.txTcpFramesOkRate
                TotalRX += stats.rxTcpPacketsOkRate
            elif PktType == 'UDP':
                TotalTX += stats.txUdpFramesOkRate
                TotalRX += stats.rxUdpPacketsOkRate
            else:
                TotalTX += stats.txIpPacketsOkRate
                TotalRX += stats.rxIpPacketsOkRate
        OLOADtext = Float2EngNotation(bpf * TotalTX, self.DisplayPrecision)
        FRtext    = Float2EngNotation(bpf * TotalRX, self.DisplayPrecision)
        # Change pkt/sec to bps per VPR 3030
        WaveEngine.OutputstreamHDL("\r%s OLOAD=%sbps, FR=%sbps, (%2s %4.1f secs)" % (PassedParameters['Title'], OLOADtext, FRtext, TXstate, ElapsedTime), WaveEngine.MSG_OK)

    def startTest(self, FuncRealTime):
        self.ResultsForCSVfile.append( ('Trial', 'Number Of Clients', 'Offered Load', 'Frame Loss', 'Maximum Latency') )
        if self.SearchMinimum:
            if isnum(self.SearchMinimum):
                _minimum = int(self.SearchMinimum) 
            else:
                _minimum = 0
                WaveEngine.OutputstreamHDL("Warning: Can not understand minimum rate of '%s', using default.\n" % (self.SearchMinimum), WaveEngine.MSG_WARNING)
        else:
            _minimum = 0
        if self.SearchMaximum:
        #If the Search Maximum Value is not an integer number then set the maximum value to 20 per card
            if isnum(self.SearchMaximum):
                _maximum = int(self.SearchMaximum) 
            else:
                _maximum = 20 * len(self.CardList)
                WaveEngine.OutputstreamHDL("Warning: Can not understand maximum rate of '%s', using default.\n" % (self.SearchMaximum), WaveEngine.MSG_WARNING)
        else:
            _maximum = 20 * len(self.CardList)

        #Loop through each Trial
        for TrialNumber in range(1, 1 + self.Trials):
            SearchLogic = WaveEngine.BinarySerach()
            SearchLogic.minimum(_minimum)
            SearchLogic.maximum(_maximum)
            SearchLogic.resolutionAbsolute(self.SearchResolutionCount)
            MaxClients = 0
            SLAMinimumThroughput = EngNotation2Int(self.SLAMinimumThroughput)
                
            while SearchLogic.searching():
                numClients = int(SearchLogic.query())
                WaveEngine.OutputstreamHDL("\nTrial %d: %d clients\n" % (TrialNumber, numClients), WaveEngine.MSG_OK)
                self.BuildClientTable(numClients)
                self.VerifyBSSID_MAC()

                #Create clients for the test
                self.createClients()
                WaveEngine.WriteAPinformation(self.ListOfClients)
                
                if (self.connectClients() < 0 ):
                    SearchLogic.FAIL()
                    self.ClearExsistingClientsFlows()
                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
                    continue
#                self._clientLearning(self.ListOfClients, self.ClientLearningTime, self.ClientLearningRate)
                
                #Configure flows for the test
                self.configureFlows()
                #Do arp exchanges for the test
                if WaveEngine.ExchangeARP(self.FlowList,"XmitGroup",self.ARPRate, self.ARPRetries, self.ARPTimeout) < 0.0 :
                    SearchLogic.FAIL()
                    self.ClearExsistingClientsFlows()
                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
                    continue

                #Do flow learning
                FrameRate = SLAMinimumThroughput / float(8 * self.FrameSizeDownstream)
                PassedParam = {'Title': 'Learning', 'ILOAD': FrameRate, 'CardList': self.CardList, 'Type': self.FlowOptions['Type'], 'BitsPerFrame': 8 * self.FrameSizeDownstream}
                if self.FlowLearningTime > 0.0:
                    self._transmitIteration(self.FlowLearningTime, 0, self.UpdateInterval, "XmitGroup", True, FuncRealTime, PassedParam)
                    WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)

                #Set the flow rates for the SLA 
                WaveEngine.ClearAllCounter(self.CardList)
                WaveEngine.ModifyFlows(self.FlowList, {'RateMode': 'pps', 'IntendedRate': FrameRate, 'NumFrames': int(FrameRate * self.TransmitTime)})

                #The test duration
                PassedParam['Title'] = ''
                WaveEngine.OutputstreamHDL("\nTrial %d: Transmitting for %d clients\n" % (TrialNumber, numClients), WaveEngine.MSG_OK)
                WaveEngine.WriteDetailedLog([''])
                WaveEngine.WriteDetailedLog(['ILOAD:', FrameRate, 'Trial:', TrialNumber,'Number of Clients:', numClients])
                self._transmitIteration(self.TransmitTime, self.SettleTime, self.UpdateInterval, "XmitGroup", True, FuncRealTime, PassedParam)
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)

                #Check for loss and latency
                (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = WaveEngine.MeasureFlow_OLOAD_FR_LossRate(self.FlowList, self.TransmitTime)
                (latencyMin, latencyMax, latencyAvg) = WaveEngine.MeasurePort_Latency(self.DesCardList, self.TransmitTime)

                if OLOAD == 0:
                    WaveEngine.OutputstreamHDL(" FAIL (nothing transmitted)\n" , WaveEngine.MSG_WARNING)
                    SearchLogic.FAIL()
                elif FrameLossRate > self.SLAAcceptLossPercent:
                    if FrameLossRate > 0.0001:
                        WaveEngine.OutputstreamHDL(" FAIL (loss of %s%%)\n" % (str(EngNotation2Int(Float2EngNotation(FrameLossRate, 2)))), WaveEngine.MSG_WARNING)
                    else:
                        WaveEngine.OutputstreamHDL(" FAIL (loss less than 0.0001%%)\n", WaveEngine.MSG_WARNING)
                    SearchLogic.FAIL()
                elif SLAMinimumThroughput > OLOAD_bps:
                    WaveEngine.OutputstreamHDL(" FAIL (Throughput only %sbps)\n" % (Float2EngNotation(OLOAD_bps, 3)), WaveEngine.MSG_WARNING)
                    SearchLogic.FAIL()
                elif latencyMax > EngNotation2Int(self.SLAMaximumLatency):
                    WaveEngine.OutputstreamHDL(" FAIL (Latency went up to %ss)\n" % (Float2EngNotation(latencyMax, 3)), WaveEngine.MSG_WARNING)
                    SearchLogic.FAIL()
                else:
                    #if nothing failed
                    WaveEngine.OutputstreamHDL(" PASS\n", WaveEngine.MSG_SUCCESS)
                    MaxClients = numClients
                    MaxOLOAD   = OLOAD_bps
                    MaxLoss    = FrameLossRate
                    MaxLatncy  = latencyMax
                    SearchLogic.PASS()

                # Distory the clients and wait befoer starting next iteration
                self.ClearExsistingClientsFlows()
                if self.AgingTime > 0:
                    WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
            # Print results for that frame size
            if SearchLogic.neverpassed:
                self.ResultsForCSVfile.append( (TrialNumber, MaxClients, 0, 0, 0 ) )
                WaveEngine.OutputstreamHDL("Error: Trial=%d failed every pass. No throughput measurement.\n" % (TrialNumber), WaveEngine.MSG_ERROR)
            else:
                self.ResultsForCSVfile.append( (TrialNumber, MaxClients, MaxOLOAD, MaxLoss, MaxLatncy ) )
                WaveEngine.OutputstreamHDL("Completed: Able to sustain %d clients\n" % (MaxClients), WaveEngine.MSG_SUCCESS)
                
    # Extract data from the CVS file and puts store it as the object's attribute
    def ParseCVSdata(self, dataFromFile):
        # Data for the Troughput Graph
        self._ReportData   = {}
        # Data for the detailed section of the Report
        self._ReportResults = [('Trial', 'Number Of Clients', 'Offered Load', 'Frame Loss', 'Maximum Latency'),]

        for eachLine in dataFromFile:
            #print len(eachLine), ':', eachLine
            if len(eachLine) != 5:
                continue

            (TrialNumber, MaxClients, OLOAD_BPS, LossPercentage, MaxLatency) = eachLine
            if not isnum(TrialNumber):
                #Process Titles
                continue
            TrialNumber = int(TrialNumber)
            self._ReportData[TrialNumber] = (MaxClients, OLOAD_BPS, LossPercentage, MaxLatency)
            MaxLatency = "%ss" % (Float2EngNotation(float(MaxLatency), self.DisplayPrecision) )
            OLOAD_BPS = "%sbps" % (Float2EngNotation(float(OLOAD_BPS), self.DisplayPrecision) )
            self._ReportResults.append( (TrialNumber, MaxClients, OLOAD_BPS, LossPercentage, MaxLatency), )

    def PrintReport(self):
        import os.path
        # Text Paragraphs
        Overview1     = "Mesh Client Capacity measures the maximum number of clients that can use the mesh network "\
                        "within a given SLA (Service Level Agreement).  This test answer the important question: So "\
                        "how many customers does it support?"
        Overview2     = "Obviously the more clients, the better.  The SLA (Service Level Agreement) will contribute "\
                        "greatly to the final result.  The SLA is defined by three parameters: Maximum packet loss, "\
                        "guaranteed throughput, and the maximum acceptable latency.  These parameters should match "\
                        "the intended SLA of the real customers."
        ClientMap     = "Client Map represents the configured maximum clients.  For each iteration, only a subset of "\
                        "these clients were active."
        Method1       = "Mesh Client Capacity identifies the maximum number of clients at which the Mesh Network "\
                        "can support a given SLA (Service Level Agreement).  The SLA is defined by three parameters: "\
                        "Maximum packet loss, guaranteed throughput, and the maximum acceptable latency.  Multiple "\
                        "iterations are used to find the maximum number."
        Method2       = "For each test iteration, clients are evenly distributed on every hop.  If the total number "\
                        "of clients is not a multiple of he number of hops, then the hops closer to the backbone "\
                        "Ethernet link will have one more client that the hops farther.  If clients fail to connect, "\
                        "or ARPs fail to complete, or measured packet loss is greater than SLA Accept Loss, or the "\
                        "offered load is less than SLA Minimum Throughput, or if any of the frames' latency exceeds "\
                        "the SLA Maximum Latency, then the iteration has failed."
        Method3       = "This implementation uses a binary search algorithm to determine the number of clients for "\
                        "each iteration.  The binary search algorithm uses two parameters in its search: the maximum "\
                        "passed (labeled Search Maximum in the Test Configuration section) and the maximum failed "\
                        "(labeled Search Minimum). On the first test iteration, a configured maximum is attempted. "\
                        "If the iteration passes all the checks, then the search is terminated and the configured "\
                        "number is reported. If any of the five checks listed about fail, then the binary search "\
                        "algorithm will attempt another test iteration half way between the maximum passed and the "\
                        "maximum failed. The binary search algorithm continues this process until difference between "\
                        "the values is less than the Search Resolution setting. At each iteration the binary search "\
                        "algorithm updates the maximum passed rate and the maximum failed rate before computing the "\
                        "next value to attempt."
        Method4       = "The overall process is repeated for the number of trials specified."
        RSSIdetails=    "The RSSI is sampled each test iteration just before transmitting data.  The RSSI value "\
                        "can range from -127 dBm to + 127 dBm.  Desired RSSI values are in the range of -60 dBm to -20 dBm."

        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Mesh Client Capacity Report", self.DUTinfo, self.TestID )
        MyReport.InsertHeader("Overview")
        MyReport.InsertParagraph(Overview1)

        self.ParseCVSdata(self.ResultsForCSVfile)
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.5 * inch
        MyReport.InsertObject(self.CreateTrialvsClientsGraph(GraphWidth, GraphHeight, self._ReportData))
        MyReport.InsertParagraph(Overview2)
        MyReport.InsertPageBreak()
        
        MyReport.InsertHeader("Test Configuration")
        ConfigParamters = [('Parameter', 'Value', 'Description'),
                           ('Learning Time', "%d secs" % (self.FlowLearningTime), 
                            'The number of seconds to transmit frames for the DUT/SUT to populate its forwarding tables'),
                           ('Transmit Time', "%d secs" % (self.TransmitTime), \
                            'The number of seconds that the WaveTest will transmit for each iteration.'),
                           ('Settle Time', "%d secs" % (self.SettleTime), \
                            'How many seconds to wait for the DUT/SUT to finish forwarding frames before making the final measurement'),
                           ('AgingTime', "%d secs" % (self.AgingTime), \
                            'The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to zero.'),
                           ('Trials', "%d" % (self.Trials), \
                            'Number of times the measurement will be repeated.  Multiple trials are used for averaging the measurement.'),
                           ('Search Minimum', self.SearchMinimum, \
                            'The lower boundry for the goal seeking algorthim.  The algorthim will not search for values less than this.'),
                           ('Search Maximum', self.SearchMaximum, \
                            'The upper boundry for the goal seeking algorthim.  The algorthim will not search for values higher than this.'),
                           ('Search Resolution', "%d" % (self.SearchResolutionCount), \
                            'Determines how precise the search for the final result needs to be to within the number of clients.'),
                           
                           ('SLA Accept Loss', "%.2f%%" % (float(self.SLAAcceptLossPercent)), \
                            'Determines how much packet loss will be acceptable by the Service Level Agreement.'),
                           ('SLA Minimum Throughput', "%sbps" % (Float2EngNotation(EngNotation2Int(self.SLAMinimumThroughput), 3)), \
                            'Specifics the mininum ganurentee download speed in bps.'),
                           ('SLA Maximum Latency', "%ss" % (Float2EngNotation(EngNotation2Int(self.SLAMaximumLatency), 3)), \
                            'The maximum latency allowed per the Service Level Agreement.'),
                           
                           ]
        

        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ('Client Contention', "%d%%" % (self.testOptions['ContentionProbability']) , 'The probability that 2 clients will try to access the media at the same time and create an errored frame.'), )
        MyReport.InsertParameterTable(ConfigParamters, columns=[1.75*inch, 1.00*inch, 3.25*inch])
        
        MyReport.InsertPageBreak(1.5*inch) #Break if there is less than an inch left.
        MyReport.InsertHeader("Client Map")
        self.BuildClientTable(self.SearchMaximum)
        MyReport.InsertParagraph(ClientMap)
        MyReport.InsertClientMap(self.SourceClients, self.DestClients, True, self.CardMap)
        
        MyReport.InsertPageBreak()  #Forced break
        MyReport.InsertHeader("Methodology")
        MyReport.InsertParagraph(Method1)
        MyReport.InsertParagraph(Method2)
        MyReport.InsertParagraph(Method3)
        MyReport.InsertParagraph(Method4)

        MyReport.InsertPageBreak(inch) #Break if there is less than an inch left.
        MyReport.InsertHeader("Detailed Results")
        MyReport.InsertDetailedTable(self._ReportResults, columns=[0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch])        

        RSSI_Data = self.AnalyizeRSSIdata(WaveEngine.ReadAPinformation())
        MyReport.InsertPageBreak( (0.95 + len(RSSI_Data) * 0.42) * inch )
        MyReport.InsertHeader("Access Point Information")
        MyReport.InsertParagraph(RSSIdetails)
        MyReport.InsertDetailedTable(RSSI_Data, columns=[1.5*inch, 0.60*inch, 1.25*inch, 1.55*inch, 0.40*inch, 0.40*inch, 0.40*inch])

        # other info section
        MyReport.InsertPageBreak(1.85*inch)
        MyReport.InsertHeader("Other Info")
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        #Hack to stop printing the document
        if self.generatePdfReportF:
            MyReport.Print()

    def run(self):
        # For debuging the reports
        #print "\n--- New Run --- "
        #self.ReadResults()
        #self.BuildClientTable()
        #self.PrintReport()
        #return
        
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.BuildClientTable()
            self.configurePorts()
            self.initailizeCSVfile()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            self.PrintReport()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.SaveResults()
            self.ExitStatus = 2
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()

    def getInfo(self):
        Method = "Placeholder\n"
        return Method


################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateTrialvsClientsGraph(self, GraphWidth, GraphHeight, DataDict):
        CallNames = DataDict.keys()
        CallNames.sort()
        CallTime = []
        CallName = []
        for eachCall in CallNames:
            (MaxClients, OLOAD_BPS, LossPercentage, MaxLatency) = DataDict[eachCall]
            CallTime.append(MaxClients)
            CallName.append(str(eachCall))
        return self.TrialvsClientsGraph(GraphWidth, GraphHeight, CallName, [CallTime, ], "Client Capacity per Trial")

    class TrialvsClientsGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title
            
        def _customSecondsLabelFormat( self, value ):
            return str(int(value))

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            #self._drawBox(x1, y1, Width, Height)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            countSteps = int(self.valueMax / self.valueStep)
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(self._customSecondsLabelFormat(eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
            
            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft   
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                if len(self.dataNames) < 16:
                    bc.barLabelFormat = self._customSecondsLabelFormat
                    bc.barLabels.dy = 0.08*inch
                    bc.barLabels.fontSize = 9
            else:
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            bc.valueAxis.labelTextFormat = self._customSecondsLabelFormat
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            self.drawing.add(bc)

            #Put the labels on the center of the graph
            self._drawLabels(self.title, "Trial", "Clients")


##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()

    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus) 
