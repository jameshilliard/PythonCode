#tcp_goodput
#
# Objective: Find the maximum TCP payload the DUT can forward frames (regardless 
#            loss) through an iteration search. Try different RFC2544 packet 
#            sizes.
#
import sys, time, sched, traceback
import WaveEngine
import Qlib
from basetest import *
from optparse import OptionParser
from vcl import *
from CommonFunctions import *

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}
          
        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}

        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of '00:00:00:00:00:00'
                       tells the system to pick the first on on the list
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.10',  '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.100', '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of MSS to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. RFC2544 recommends 2 seconds.  Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.                        
        """
        self.FrameSizeList  = [ 128, 256, 1024 ]
        self.Trials         =  1  
        self.TransmitTime   =  5.0
        self.SettleTime     =  2.0
        self.AgingTime      =  0.0
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.FinalResult=0
 
        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the test details. This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_tcp_goodput.csv'
        self.ReportFilename   = 'Report_tcp_goodput.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_tcp_goodput.csv'

        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at teh configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 2
        self.FlowLearningRate   = 100

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
         """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  10.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =   0.25
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        NumOfSessionPerClient - number of TCP session per client
        NTo1Map - Many to one/one to many, valid direction is from/to Wireless
                  to/from Ethernet
        """
        self.FlowOptions    = {'Type': 'TCP', 'PhyRate': 54 }
        self.NumOfSessionPerClient = 1
        self.NTo1Map = 'False'
        self.tcpWindowSize = 65535
        
########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.42 $' 
        self.date    = '$Date: 2007/07/12 23:54:25 $' 

        self.BiDirectional  = False

        self.FlowMap        = WaveEngine.CreateFlows_Pairs
        self.finalGraphs = odict.OrderedDict()
        self.frameData = {}
        self.tcpPayload = 536
        self.tcpWindowSize = 65535
        self.tcpPayloadDict = {}
        self.tcpTxBytesCtrDict = {}
    
    def getTestName(self):
        return 'tcp_goodput'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        
        self.FlowOptions['Type'] = 'TCP'
        #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
          if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
            self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
          if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
            self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
            if waveTestSpecificStore['tcp_goodput']['AcceptableGoodput']:
               if float (waveTestSpecificStore['tcp_goodput']['AcceptableGoodput']) >=0:
                    self.UserPassFailCriteria['ref_acc_goodput']=float(waveTestSpecificStore['tcp_goodput']['AcceptableGoodput'])
               else:
                    WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableGoodput should be a positive number\n",WaveEngine.MSG_ERROR)
                    raise  WaveEngine.RaiseException
  
            else:
               #WaveEngine.OutputstreamHDL("\nUser has not given the value for <AcceptableGoodput> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
               self.UserPassFailCriteria['ref_acc_goodput']=90
            if waveTestSpecificStore['tcp_goodput']['GoodputMode']:
               if str(waveTestSpecificStore['tcp_goodput']['GoodputMode']) == ("Percentage" or "specify"):
                    self.UserPassFailCriteria['ref_goodput_mode']=str(waveTestSpecificStore['tcp_goodput']['GoodputMode'])
               else:
                  WaveEngine.OutputstreamHDL("\nThe value for the parameter GoodputMode should be either Percentage or specify\n",WaveEngine.MSG_ERROR)
                  raise  WaveEngine.RaiseException
            else:
               #WaveEngine.OutputstreamHDL("\nUser has not given the value for <GoodputMode> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
               self.UserPassFailCriteria['ref_goodput_mode']="Percentage"
        #___________________________________TEL_________________________________________________


        #These are the test specific parameters that get passed down from the GUI for the test execution
        self.NumOfSessionPerClient = int(waveTestSpecificStore['tcp_goodput']['NumOfSessionPerClient'])
        self.tcpWindowSize = int(waveTestSpecificStore['tcp_goodput']['TcpWindowSize'])
        self.trafficDir = str(waveTestSpecificStore['tcp_goodput']['TrafficDir'])
        # FIXME: comment out Many to 1 mapping for now
        #self.NTo1Map = str(waveTestSpecificStore['tcp_goodput']['Nto1Map'])
        frameSizeList = []
        frameSizeList = waveTestSpecificStore['tcp_goodput']['FrameSizeList']
        self.mapType = int(waveMappingStore[0])
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
        
        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        
        # all good
        return True

############################ calculateL2FrameSize ##############################
# Calculate the L2 frame size
# Input:
# - MSS: TCP MSS
# Output:
# - L2 frame size
    def calculateL2FrameSize(self, MSS):
        # always assume it's Ethernet frame & no VLAN tag 
        L2headerSize = 18 
        #if self.mapType = 0 or self.mapType == 3:   
        frameSize = MSS + L2headerSize + 20 + 20
        if frameSize > 1518:
            frameSize = 1518    
        return frameSize
        
#################################### MeasureFlow_OLOAD_Goodput_LossRate ##################################
# Returns the offered load (and bps), Forwarding rate (and bps) , and frame loss as a tuple
#
    def MeasureFlow_OLOAD_Goodput_LossRate(self, ListofFlows, TestDuration):
        TotalTxTcpPkts= 0
        TotalTXframes = 0
        #TotalRxTcpPkts= 0
        TotalRXframes = 0
        TotalTxTcpOct = 0
        TotalTXoctets = 0
        #TotalRxTcpOct = 0
        TotalRXoctets = 0
        TotalOutOfSequence = 0
        resultData = {}
        patt = re.compile(r'F_\d+_\d+_.+') # F_1024_1024_Group_1_001-->Group_2_001
        WaveEngine.WriteDetailedLog(['Flow Name', 'TCP src port', 'TCP dest port', 
                                     'src_port', 'src_client', 'des_port', 'des_client', 
                                     'txFlowTcpSegmentsOk', 'txFlowTcpOctetsOk', 'txFlowFramesOk', 'txFlowOctetsOk', 
                                     #'rxFlowTcpFramesOk', 'rxFlowTcpOctetsOk', 
                                     'rxFlowFramesOk', 'rxFlowOctetsOk', 
                                     'OutOfSequence', 'Loss'])
        for Flowname in ListofFlows.keys():
            (src_port, src_client, des_port, des_client) = ListofFlows[Flowname]
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (src_port, Flowname))
            TotalTXframes += flowStats.txFlowFramesOk
            TXframes       = flowStats.txFlowFramesOk
            TotalTXoctets += flowStats.txFlowOctetsOk 
            TXoctets       = flowStats.txFlowOctetsOk  
            biflow.checkStatus(Flowname)  
            tcpTxBytesCtr = long(biflow.get("Total TCP Bytes TX"))   
            TxTcpOct       = tcpTxBytesCtr #- self.tcpTxBytesCtrDict[Flowname]
            #self.tcpTxBytesCtrDict[Flowname] = tcpTxBytesCtr           
            
            TotalTxTcpOct += TxTcpOct
            TxTcpPkts      = TxTcpOct / self.tcpPayload
            TotalTxTcpPkts+= TxTcpPkts
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (des_port, Flowname))
            TotalRXframes += flowStats.rxFlowFramesOk
            RXframes       = flowStats.rxFlowFramesOk            
            TotalRXoctets += flowStats.rxFlowOctetsOk
            RXoctets       = flowStats.rxFlowOctetsOk            
            #RxTcpOct       = 0
            #TotalRxTcpOct += RxTcpOct
            #RxTcpPkts      = RxTcpOct / self.tcpPayload
            #TotalRxTcpPkts+= RxTcpPkts
            TotalOutOfSequence += flowStats.rxFlowOutOfSequenceFrames
            if patt.match(Flowname):
                res = re.split('_', Flowname)
                tcpSrcPort = res[1]
                tcpDestPort = res[2]
            else:
                #If drop here, the flow name doesn't have the TCP src & dest ports
                #in it. We need to get them from the flow local cache. 
                biflow.read(Flowname)
                biflowTcp.readBiflow()
                tcpSrcPort = biflowTcp.getSrcPort()
                tcpDestPort = biflowTcp.getDestPort()
            resultData[src_client+des_client+'$'+Flowname] = \
                [Flowname, tcpSrcPort, tcpDestPort,
                 src_port, src_client, des_port, des_client, 
                 TxTcpPkts, TxTcpOct, TXframes, TXoctets, 
                 #RxTcpPkts, RxTcpOct, 
                 RXframes, RXoctets, 
                 flowStats.rxFlowOutOfSequenceFrames,
                 TXframes - RXframes]
        key = resultData.keys()
        key.sort()
        for i in key:    
            WaveEngine.WriteDetailedLog(resultData[i])
        if TotalTXframes > 0:
            FrameLossRate = 100.0 * (TotalTXframes - TotalRXframes) / TotalTXframes
        else:
            FrameLossRate = 0.0
            WaveEngine.OutputstreamHDL("\nWarning: No frames were transmitted; Frame Loss Rate is invalid.\n", WaveEngine.MSG_WARNING)
        if TotalRXframes == 0:
            WaveEngine.OutputstreamHDL("\nWarning: No frames were received; Forwarding Rate is zero.\n", WaveEngine.MSG_WARNING)
        WaveEngine.WriteDetailedLog(['Totals', '', '', '', '', '', '',
                                     TotalTxTcpPkts, TotalTxTcpOct, TotalTXframes, TotalTXoctets, 
                                     #TotalRxTcpPkts, TotalRxTcpOct, 
                                     TotalRXframes, TotalRXoctets, 
                                     TotalOutOfSequence, TotalTXframes - TotalRXframes])
        return (TotalTXframes / float(TestDuration),   
                TotalTxTcpOct / float(TestDuration), 
                resultData, TotalTxTcpOct)     
    
    def startTest(self, FuncRealTime):
        if  self.UserPassFailCriteria['user']=="True":
            self.ResultsForCSVfile.append(('Trial',
                                       'TCP MSS',
                                       'TCP Goodput segments/sec',
                                       'TCP Goodput kbits/sec',
                                       'TCP payload sent kbytes',
                                       'Theoretical Goodput segments/sec',
                                       'Theoretical Goodput kbits/sec',
                                       'L2 Frame Size',
                                       'L2 OLOAD frames/sec',
                                       'USC:GP'
                                       ))
        else:  
            self.ResultsForCSVfile.append(('Trial',
                                           'TCP MSS',
                                           'TCP Goodput segments/sec', 
                                           'TCP Goodput kbits/sec',
                                           'TCP payload sent kbytes',
                                           'Theoretical Goodput segments/sec', 
                                           'Theoretical Goodput kbits/sec',                                        
                                           'L2 Frame Size', 
                                           'L2 OLOAD frames/sec' 
                                         ))
        
        if self.FlowLearningTime > 0:
            #Do the Flow learning
            if self.FlowOptions['Type'] == 'TCP':
                self.setQoShandshakeFlag()
                # do biflow.connect for flow learning 
                if self.connectTcpFlows(self.FlowList, operation='connect') < 0:
                    raise WaveEngine.RaiseException              
            PassedParam = {'FrameSize': 'Learning', 'ILOAD': self.FlowLearningRate * float(len(self.FlowList)), 
                           'CardList': self.CardList, 'Type': self.FlowOptions['Type'], 'Queue': 1}
            self._transmitIteration(self.FlowLearningTime, self.SettleTime, self.UpdateInterval, "XmitGroup", 
                                         True, FuncRealTime, PassedParam)
            if self.FlowLearningTime > 0:
                # Wait for 2 seconds to make sure we get all the TCP ACKs
                WaveEngine.Sleep(2, 'TCP settling time') 
            if self.FlowOptions['Type'] == 'TCP':
                # do biflow.connect for flow learning 
                if self.connectTcpFlows(self.FlowList, operation='disconnect') < 0:
                    raise WaveEngine.RaiseException              
                                
        TheoreticalMFRcalc = self.getMediumCapacityCalculator()
                                             
        for eachSize in self.FrameSizeList:
            MSS = int(eachSize)
            self.tcpPayload = MSS
            self.FlowOptions['Mss'] = MSS
            self.FlowOptions['Window'] = self.tcpWindowSize
            FrameSize = self.calculateL2FrameSize(MSS)
            self.tcpPayloadDict[FrameSize] = self.tcpPayload
       
            TheoreticalMFR = TheoreticalMFRcalc(FrameSize)
            TheoreticalBPS = 8 * FrameSize * TheoreticalMFR
            TheoryAckFPS = TheoreticalMFR / 2.0
            TheoryAckBitsPS = TheoryAckFPS * 64 * 8
            TheoryTcpDataBitsPS = TheoreticalBPS - TheoryAckBitsPS 
            TheoryGoodputFPS = TheoryTcpDataBitsPS / FrameSize / 8.0
            TheoryGoodputBitsPS = TheoryGoodputFPS * MSS * 8 
            
            trialData = {}
            for TrialNumber in range(1, 1 + self.Trials):
                WaveEngine.ClearAllCounter(self.CardList)
                ILOAD = 2 * TheoreticalMFR
                FrameRatePerFlow =  ILOAD / float(len(self.FlowList))   
                self.modifyFlows(ILOAD, FrameSize, 
                                 Options={'Mss':MSS, 'Window':self.tcpWindowSize},
                                 doTcpConnect=False)           
            
                # initialize the TCP seq number
                """
                for name in self.FlowList.keys():
                    biflow.checkStatus(name) 
                    self.tcpTxBytesCtrDict[name] = int(biflow.get("Total TCP Bytes TX"))               
                """
                #Connect TCP biflows
                if self.FlowOptions['Type'] == 'TCP':
                    self.setQoShandshakeFlag()
                    # do biflow.connect
                    if self.connectTcpFlows(self.FlowList, operation='connect') < 0:
                        raise WaveEngine.RaiseException              
                                
                WaveEngine.WriteDetailedLog(['TCP MSS', MSS, 'TCP Payload Size', self.tcpPayload, 'Trial', TrialNumber])
                WaveEngine.WriteAPinformation(self.ListOfClients)
                PassedParam = {'FrameSize': FrameSize, 'ILOAD': ILOAD,
                               'CardList': self.CardList, 'Type': self.FlowOptions['Type']}

                WaveEngine.OutputstreamHDL("\nFrame Size: %d bytes, attempting %.1f frames/sec" % 
                (FrameSize, ILOAD), WaveEngine.MSG_OK)                
                
                self._transmitIteration(self.TransmitTime, self.SettleTime, self.UpdateInterval, "XmitGroup", True, 
                                             FuncRealTime, PassedParam)
                # Wait for 2 seconds to make sure we get all the TCP ACKs
                WaveEngine.Sleep(2, 'TCP settling time')
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
                                
                # This is a hack since flows counter do not work with less
                # than 88 byte frames
                if FrameSize < 88:
                    # raise exception since we don't allow the user from 
                    # specifying frame size < 88 bytes in the GUI
                    raise RaiseFrameSizeException
                else:
                    #(10, 10, {1:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}, 10)
                    (OLOAD, goodput_BPS, resultData, totalBytes) = \
                    self.MeasureFlow_OLOAD_Goodput_LossRate(self.FlowList, self.TransmitTime)                                       
                
                #WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
                Theoretical_Goodput_bps = TheoreticalMFR * 8 * self.tcpPayload                
                if  self.UserPassFailCriteria['user']=="True":
                   TestResult=''
                   if self.UserPassFailCriteria['ref_goodput_mode']=="Percentage":
                          MC=TheoryGoodputBitsPS/float(1000)
                          user_gp =(MC* float(self.UserPassFailCriteria['ref_acc_goodput']))/100 
                          if user_gp  <=  goodput_BPS*8/float(1000):
                                   TestResult='PASS' 
                                   WaveEngine.OutputstreamHDL("\nTest has achieved the User Pass/Fail criteria set by the user: USER-%s, Achieved-%s\n"%(user_gp,goodput_BPS*8/float(1000)),WaveEngine.MSG_SUCCESS)
                          else:
                                   TestResult='FAIL'
                                   WaveEngine.OutputstreamHDL("\nTest has failed to achieve the User Pass/Fail criteria set by the user: USER-%s, Achieved-%s\n"%(user_gp,goodput_BPS*8/float(1000)),WaveEngine.MSG_WARNING)
                   elif self.UserPassFailCriteria['ref_goodput_mode']=="Specify":
                          user_gp=self.UserPassFailCriteria['ref_acc_goodput']
                          if self.UserPassFailCriteria['ref_acc_goodput']  <=  goodput_BPS*8/float(1000):  
                                   TestResult='PASS'
                                   WaveEngine.OutputstreamHDL("\nTest has achieved the User Pass/Fail criteria set by the user: USER-%s, Achieved-%s\n"%(user_gp,goodput_BPS*8/float(1000)),WaveEngine.MSG_SUCCESS) 
                          else:
                                   TestResult='FAIL'
                                   WaveEngine.OutputstreamHDL("\nTest has failed to achieve the User Pass/Fail criteria set by the user: USER-%s, Achieved-%s\n"%(user_gp,goodput_BPS*8/float(1000)),WaveEngine.MSG_WARNING)  
                   self.ResultsForCSVfile.append((TrialNumber,
                                               MSS,
                                               goodput_BPS/self.tcpPayload,
                                               goodput_BPS*8/float(1000),
                                               totalBytes/float(1000),
                                               TheoryGoodputFPS,
                                               TheoryGoodputBitsPS/float(1000),
                                               FrameSize,
                                               OLOAD,
                                               TestResult
                                               ))
                else:  
                   self.ResultsForCSVfile.append((TrialNumber,
                                               MSS,
                                               goodput_BPS/self.tcpPayload, 
                                               goodput_BPS*8/float(1000), 
                                               totalBytes/float(1000),                                                
                                               TheoryGoodputFPS, 
                                               TheoryGoodputBitsPS/float(1000), 
                                               FrameSize,                                               
                                               OLOAD
                                               ))
                
                trialData[TrialNumber] = (resultData, ILOAD, goodput_BPS)
                WaveEngine.OutputstreamHDL("Completed: Max. Segment Size: %d bytes, transferred %.2f kbytes of TCP payload, found the TCP Goodput of %.1f kbps at L2 OLOAD=%.1f fps\n" % 
                                           (MSS, totalBytes/float(1000), goodput_BPS*8/float(1000), OLOAD), WaveEngine.MSG_SUCCESS)
                WaveEngine.WriteDetailedLog(['',])
                
                #disconnect TCP biflows at the end of trial
                if self.FlowOptions['Type'] == 'TCP':
                    # do biflow.disconnect
                    if self.connectTcpFlows(self.FlowList, operation='disconnect') < 0:
                        raise WaveEngine.RaiseException              

                # Certain DUT do not like the constant traffic
                if self.AgingTime > 0:
                    WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
            
                WaveEngine.CheckEthLinkWifiClientState(self.CardList, self.ListOfClients)
                
            self.frameData[MSS] = trialData                  
         
    def PrintReport(self):
        import os.path
        #Strip off the DUT info
        Results = []
        Results_PF=[]  
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                if  self.UserPassFailCriteria['user'] == "True":
                    Results_PF.append(line)
                    Results.append(line[:-1])
                else:
                    Results.append(line)
            if len(line) == 0:
                flag = True
                
        # Text Paragraphs
        Overview1 = "The TCP Goodput test measures the number of TCP payload bytes per second that the system under test (SUT) can transfer between its ports and the maximum segment size (MSS)."

        Overview2 = "The TCP payload is the sum of the TCP segment bytes minus the TCP headers and options."
        
        FrSizeDesc = "The following graph shows the TCP goodput performance of the SUT in Mbps for the specified TCP maximum segment size in bytes."
        
        FrSizeDesc2 = ""

        FrSizeDesc3 = "The following graphs show the TPC goodput across multiple trails for each TCP maximum segment size."

        FrSizeDesc4 = "The following graphs show the minimum, maximum and average TCP goodput across all TCP "\
                      "sessions for each TCP maximum segment size."
                      
        FrSizeDesc4mt = "The following graphs show the minimum, maximum and average TCP goodput across all TCP "\
                      "sessions across multiple trials for each TCP maximum segment size."
        
        Topology = "The following diagram shows the test topology. Each box indicates the port identifiers and IP addresses for the test clients; for wireless clients the security mode and channel ID is also shown. The arrows show the direction of the traffic." 
     
        Method1 = "The test associates clients with the SUT and generates unidirectional TCP traffic at twice the theoretical maximum 802.11 load. The test iterates through each element in the TCP maximum segment size list for the number of trials specified."
        
        Method2 = "The results are reported separately for each maximum segment size and trial."
        
        RSSIdetails = "The following table shows the SUT details. The received signal strength indication (RSSI) from the SUT is sampled on each port at the start of each trial and averaged over all of the trials."
        
        RSSIdetails2 = "RSSI values should be between -25 dBm and -35 dBm. If the RSSI is not in this range, modify the external attenuation to bring it into this range."
                         
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("TCP Goodput Report", self.DUTinfo, self.TestID)

        MyReport.InsertHeader( "Overview" )
        MyReport.InsertParagraph( Overview1 )
        MyReport.InsertParagraph( Overview2 )
        
        MyReport.InsertHeader( "Results Summary" )
        MyReport.InsertParagraph( FrSizeDesc )
        frameSizeVsGoodputGraph = self.CreateFrameSizeVersusGoodputGraph(Results,
                                                                         GraphWidth  = 5.5 * inch,
                                                                         GraphHeight = 2.5 * inch)
        MyReport.InsertObject(frameSizeVsGoodputGraph)
        self.finalGraphs["TCP Goodput"] = frameSizeVsGoodputGraph
        MyReport.InsertParagraph( FrSizeDesc2 )

        frameData = []
        frameData = self.frameData.keys()
        frameData.sort()
        trialList = []
        for num in range(self.Trials):
            trialList.append(str(num+1))
        if self.Trials > 1: 
            MyReport.InsertParagraph(FrSizeDesc3)    
            graphMultiTrialGoodput = {}
            for size in frameData:
                trialData = self.frameData[size]
                trial = trialData.keys()
                trial.sort()
                goodputVal = []
                for num in trial:
                    goodputVal.append(trialData[num][2]*8/float(1000000))
                # Generate TCP goodput graph across multiple trials for each MSS
                graphMultiTrialGoodput[size] = Qlib.GenericGraph( 
                    trialList,    # x values which is the trial numbers
                    "Trials",     # x label
                    list((goodputVal,)), # list of y values
                    "TCP Goodput (Mbps)",    # y label
                    "TCP Goodput - MSS: %d bytes" % size, # graphtitle
                    ['Bar'] # graph type
                ) 
                MyReport.InsertObject(graphMultiTrialGoodput[size])
                self.finalGraphs["TCP Goodput - MSS: " + str(size) + " bytes"] = graphMultiTrialGoodput[size]                

        if self.NumOfSessionPerClient > 1: 
            self.ResultsForCSVfile.append(('\n'))
            #MyReport.InsertPageBreak()
            if self.Trials > 1:
                MyReport.InsertParagraph(FrSizeDesc4mt)
            else:
                MyReport.InsertParagraph(FrSizeDesc4)                
            graphMinMaxAvgGoodputSession = {}
            for size in frameData:
                trialData = self.frameData[size]
                trial = trialData.keys()
                trial.sort()                  
                trialMinVal = []
                trialAvgVal = []
                trialMaxVal = []
                for num in trial:
                    resultData = trialData[num][0]
                    resultDataKey = resultData.keys()
                    minVal = WaveEngine.MAXtxFrames
                    maxVal = 0
                    avgVal = 0
                    clientMinValDict = {}
                    clientMaxValDict = {}
                    clientAvgValDict = {}      
                    clientInfoDict = {}             
                    # min, max & avg goodput per client with multiple sessions
                    self.ResultsForCSVfile.append(('TCP MSS', size, 'TCP Payload Size', size, 'Trial', num))                    
                    self.ResultsForCSVfile.append(('src_port', 'src_client', 'des_port', 'des_client', 
                                                   'Min TCP Goodput segments/sec', 'Avg TCP Goodput segments/sec',
                                                   'Max TCP Goodput segments/sec'))
                    for i in resultDataKey:
                        patt = re.compile(r'.+\$.+') # Group_1Group_2$F_1024_1024_Group_1-->Group_2
                        if patt.match(i):
                            res = re.split('\$', i)
                            clientName = res[0]   
                            flowName = res[1]
                            clientInfoDict[clientName] = self.FlowList[flowName]
                            clientMinValDict[clientName] = \
                                min(clientMinValDict.get(clientName, WaveEngine.MAXtxFrames), 
                                    resultData[i][8])
                            clientMaxValDict[clientName] = \
                                max(clientMaxValDict.get(clientName, 0), resultData[i][8])
                            clientAvgValDict[clientName] = \
                                clientAvgValDict.get(clientName, 0) + resultData[i][8]                                 
                        minVal = min(minVal, resultData[i][8])
                        maxVal = max(maxVal, resultData[i][8])
                        avgVal += resultData[i][8]
                    avgVal = avgVal / float(len(resultDataKey))
                    trialMinVal.append(minVal*8/self.TransmitTime)
                    trialAvgVal.append(avgVal*8/self.TransmitTime)                
                    trialMaxVal.append(maxVal*8/self.TransmitTime)
                    
                    clientKeys = clientAvgValDict.keys()
                    clientKeys.sort()
                    for clientName in clientKeys:
                        clientAvgValDict[clientName] = clientAvgValDict[clientName]/float(self.NumOfSessionPerClient)
                        (src_port, src_client, des_port, des_client) = clientInfoDict[clientName]
                        self.ResultsForCSVfile.append((src_port, src_client, des_port, des_client,
                                                       clientMinValDict[clientName]/(self.TransmitTime * size), 
                                                       clientAvgValDict[clientName]/(self.TransmitTime * size),
                                                       clientMaxValDict[clientName]/(self.TransmitTime * size)))
                    
                # Generate min, max & avg TCP goodput per session graph across trials for each MSS
                graphMinMaxAvgGoodputSession[size] = Qlib.GenericGraph( 
                    trialList,    # x values which is the trial numbers
                    "Trials",     # x label
                    list((trialMinVal,trialAvgVal,trialMaxVal)), # list of y values
                    "TCP Goodput (bps)",    # y label
                    "Min, Avg & Max TCP Goodput - MSS: %d bytes" % size, # graphtitle
                    ['Bar'], # graph type
                    [["Min"],["Avg"],["Max"]] # list of legend name
                ) 
                MyReport.InsertObject(graphMinMaxAvgGoodputSession[size])        
                self.finalGraphs["Min, Avg & Max TCP Goodput - MSS: " + str(size) + " bytes"] = graphMinMaxAvgGoodputSession[size]
        
        #MyReport.InsertPageBreak()

        MyReport.InsertHeader( "Methodology" )
        MyReport.InsertParagraph( Method1 )
        MyReport.InsertParagraph( Method2 )
        
        MyReport.InsertHeader( "Test Topology" )
        MyReport.InsertParagraph( Topology )
        MyReport.InsertClientMap( self.SourceClients, self.DestClients, self.BiDirectional, self.CardMap )
        # count ports used in client lists
        portlist = []
        for eachClient in self.SourceClients + self.DestClients:
            port = eachClient[ 1 ] # extract portname from client tuple
            if port not in portlist:
                portlist.append( port )
        numPorts = len( portlist )
        MyReport.InsertParagraph( "This test used %d ports." % numPorts )
        #MyReport.InsertPageBreak()
        
        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        for eachClient in self.SourceClients + self.DestClients:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject

            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )

        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])
        MyReport.InsertHeader( "Configuration" )
        """
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Maximum Segment Sizes', str( self.FrameSizeList ), "TCP MSS in bytes" ) ]
                             #( 'ILOAD', str( self.ILOADlist ), "Traffic load, frames/sec" ) ]
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 1.75*inch, 3.0*inch, 1.25*inch ] ) # 6-inch total

        MyReport.InsertHeader( "Test Configuration" )
        """
        if self.NTo1Map == 'True':
            mappingType = 'Many to One'
        else:
            mappingType = 'One to One'
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description'),
                             ( 'Maximum Segment Sizes', str( self.FrameSizeList ), "TCP MSS in bytes" ),
                            ( 'Learning Time', "%.1f sec" % ( self.FlowLearningTime ), "Transmission time (seconds) for initial learning packets, to allow the SUT to set up forwarding tables" ),
                            ( 'Transmit Time', "%.1f sec" % ( self.TransmitTime ), "Trial duration (seconds) - i.e., duration of test traffic" ),
                            ( 'Settle Time', "%d sec" % ( self.SettleTime ), "Idle time after test traffic transmission completes" ),
                            ( 'Aging Time', "%d sec" % ( self.AgingTime ), "Time allowed for the SUT to recover between iterations" ),
                            ( 'Number of Trials', "%d" % ( self.Trials ), "Number of times measurements are repeated" ),
                            ( 'Num of Session per Client', "%d" % (self.NumOfSessionPerClient), "Number of TCP sessions per client pair" ),
                            ( 'TCP Window', "%d" % (self.tcpWindowSize), "TCP Window Size" ),
                            #( 'Mapping Type', "%s" % (mappingType), "Client mapping type" )
                          ]

        if self.testOptions['ContentionProbability'] > 0:
            ConfigParameters.append( ('Client Contention', 'ON', 'This enables 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 2.0*inch, 0.75*inch, 3.25*inch ] )
 
        MyReport.InsertHeader( "Detailed Results" )
        MyReport.InsertParagraph("The following table shows the detailed results for this test.")
        if self.UserPassFailCriteria['user'] =="True":
           MyReport.InsertDetailedTable( Results_PF, columns = [0.4*inch, #Trial
                                                          0.5*inch, #MSS
                                                          0.8*inch, #Goodput SPS
                                                          0.8*inch, #Goodput Kbps
                                                          0.8*inch, #Goodput kbytes
                                                          0.8*inch, #L2 theoretical fps
                                                          0.8*inch, #L2 theoretical kbps
                                                          0.5*inch, #L2 frame size
                                                          0.8*inch,  #OLOAD fps
                                                          0.8*inch 
                                                          ])
           NoteText=""" Note: Abbreviations used: USC-User Specified Criteria,GP-Good Put"""
           MyReport.InsertParagraph(NoteText)
           iteration_count=-1
           fail_count =0
           fail_perc  =0
           for each_tup in Results_PF:
              iteration_count=iteration_count+1
              for each_value in each_tup:
                  if each_value == 'FAIL':
                     fail_count=fail_count+1
           #fail_perc=float(fail_count/iteration_count)* 100

           MyReport.InsertHeader( "User Specified P/F criteria" )
           ConfigParameters = [ ( 'Parameter', 'User defined Value', 'Overall Result' ),
                                ( 'Goodput Mode',"%s" %self.UserPassFailCriteria['ref_goodput_mode'], "NA"),
                                ( 'Acceptable Goodput',"%s" %self.UserPassFailCriteria['ref_acc_goodput'] ,
 "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,(iteration_count-fail_count),fail_count) )]
           userspecifiedtext= """  With this feature user can decide the criteria for pass or fail of the test.User can configure the acceptable goddput
                                and goodput mode as either Percentage/Specify based on which the test is evaluated to Pass/Fail"""
           MyReport.InsertParagraph (userspecifiedtext)
 
           if fail_count > 0:
             self.FinalResult =3
           MyReport.InsertParameterTable( ConfigParameters, columns = [ 3.0*inch, 1.25*inch, 1.75*inch ] ) # 6-inch total

        else:
           MyReport.InsertDetailedTable( Results, columns = [0.4*inch, #Trial 
                                                          0.5*inch, #MSS
                                                          0.8*inch, #Goodput SPS
                                                          0.8*inch, #Goodput Kbps
                                                          0.8*inch, #Goodput kbytes
                                                          0.8*inch, #L2 theoretical fps
                                                          0.8*inch, #L2 theoretical kbps
                                                          0.5*inch, #L2 frame size
                                                          0.8*inch  #OLOAD fps                                                         
                                                          ])        
        MyReport.InsertHeader( "Access Point Information" )
        MyReport.InsertParagraph( RSSIdetails )
        MyReport.InsertDetailedTable( self.AnalyizeRSSIdata( WaveEngine.ReadAPinformation() ),
                                      columns = [ 1.5*inch,
                                                  0.60*inch,
                                                  1.25*inch,
                                                  1.55*inch,
                                                  0.40*inch,
                                                  0.40*inch,
                                                  0.40*inch ] )
        MyReport.InsertParagraph( RSSIdetails2 )
        
        # other info section
        MyReport.InsertHeader( "Other Information" )
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        #Hack to stop printing the document
        if self.generatePdfReportF:
            MyReport.Print()

    def run(self):
        # For debuging Reports
        #self.LoggingDirectory = "/home/keith/Veriwave/WaveApps/Results/20060329-102259"
        #self.ReadResults()
        #self.PrintReport() 
        #return

        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, self.ClientLearningTime, self.ClientLearningRate)
            self.configureFlows(self.NumOfSessionPerClient, connectBiflow=False, tcpGoodput=True)
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            if self.generatePdfReportF:
                self.PrintReport()
            self.SaveResults()   
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus=self.FinalResult
            self.updateGUIresultsPage()         
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """
        
        msg = """The TCP Goodput test measures the number of TCP payload bytes per second that the system under test (SUT) can transfer between its ports and the maximum segment size (MSS)."""
        
        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        return self.finalGraphs

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateFrameSizeVersusGoodputGraph(self, ResultData, GraphWidth = None, GraphHeight = None ):
        if not GraphWidth: GraphWidth  = 6.0 * inch
        if not GraphHeight: GraphHeight = 3.5 * inch

        #Extract the data from the CSV file
        _ExtractedData= {}
        for (TrialNumber, PayloadSize, goodput_SPS, goodput_KBPS, 
             totalKBytes, Theory_FPS, Theory_KBPS, FrameSize, OLOAD_FPS) in ResultData:
            if not isnum(FrameSize):
                continue
            if _ExtractedData.has_key(int(FrameSize)):
                (m, n, OLOAD, MaxGoodput_SPS, MaxGoodput_KBPS, Count) = _ExtractedData[int(FrameSize)]
                _ExtractedData[int(FrameSize)]= (Theory_FPS, Theory_KBPS, OLOAD, MaxGoodput_SPS + goodput_SPS, MaxGoodput_KBPS + goodput_KBPS, Count + 1)
                
            else:
                _ExtractedData[int(FrameSize)] = (Theory_FPS, Theory_KBPS, OLOAD_FPS, goodput_SPS, goodput_KBPS, 1)
        FrameSizeList = _ExtractedData.keys()
        FrameSizeList.sort()
       
        graphTitle = "TCP Goodput"
        FrameSizeData1  = ()
        FrameSizeTheory = ()
        FrameSizeName   = []
        for eachFrameSize in FrameSizeList:
            (Theory_FPS, Theory_KBPS, OLOAD_FPS, goodput_SPS, goodput_KBPS, Count) = _ExtractedData[eachFrameSize]   
            tcpPayload = self.tcpPayloadDict[eachFrameSize]          
            FrameSizeData1   += (goodput_KBPS / (int(Count) * 1000.0) , ) 
            FrameSizeTheory  += (Theory_KBPS /  1000.0, )
            FrameSizeName.append(str(tcpPayload))
        return self.GoodputGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeTheory,], [FrameSizeData1,], graphTitle)

    class GoodputGraph(FlowableGraph):
        def __init__(self, width, height, names, line, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names  
            self.dataLine  = line
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataLine, self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str('%.1f Mbps' % eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis - 20 # padding for legend
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            
            if self.validData:
                # add valid data to chart
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # add value labels above bars
                bc.barLabelFormat = "%.2f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            # chart formatting
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.labelTextFormat = '%.1f Mbps'
            # axis values
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            # axis labels
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            # add chart
            self.drawing.add(bc)

            self._drawLabels(self.title, "Max. Segment Size", "")

            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height + 2 * legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'TCP Goodput', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
           # done

            # FIXME - Keith wants number on top of the bars
            #self._drawLabels(self.title, "Frame Size", "")

            if self.validData and len(self.dataLine[0]) > 0:
                DashArray = [2,2]
                # add horizontal line if only one datapoint
                if len(self.dataLine[0]) == 1:
                    yPos = bc.height * (self.dataLine[0][0] - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
                    self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.blue, strokeWidth=1, strokeDashArray = DashArray))
                # theoretical line
                lc = HorizontalLineChart()    
                lc.x = bc.x
                lc.y = bc.y
                lc.height = bc.height
                lc.width  = bc.width
                lc.valueAxis.valueMin  = self.valueMin
                lc.valueAxis.valueMax  = self.valueMax
                lc.valueAxis.valueStep = self.valueStep
                lc.valueAxis.visible   = False
                lc.data = self.dataLine
                # line format
                lc.lines[0].strokeColor = colors.blue
                lc.lines[0].strokeDashArray = DashArray
                lc.lines[0].symbol = makeMarker('FilledDiamond')
                lc.joinedLines = 1
                self.drawing.add(lc)
                    
                # legend
                self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=colors.blue, strokeWidth=1, strokeDashArray = DashArray))
                self.drawing.add(String(legendX + 22, legendY, 'Medium Capacity', fontName='Helvetica', fontSize=8))
                legendY -= legendHeight

class RaiseFrameSizeException( WaveEngine.RaiseException ):
    def __repr__(self):
        return "WaveApps: MSS should be equal or greater than 30 bytes.\n"
                    
##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
