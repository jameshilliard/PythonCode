#unicast_latency
#
# Objective: measure the min, max and average latency then 
#            set the latency buckets to get a good view
#
import sys, math
import traceback
import WaveEngine
from basetest import *
from optparse import OptionParser
from vcl import *
from CommonFunctions import *

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                              
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}
          
        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of 00:00:00:00:00:00
                       tells the system to pick the first on on the list.
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.10',  '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.100', '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        ILOADlist -     List of intended loads. The intended load is expressed in frames/sec, 
                        and is applied at the port level. The port load is divided equally 
                        between all source clients on a port. Units: frames/second
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        self.FrameSizeList  = [ 64,    88,    128,   256,     512,   1024,   1280,  1518 ]
        self.ILOADlist      = [ 5584.6, 5584.6, 5417.1, 4900.6, 4151.2, 3132.3, 2773.9, 2773.9]
        self.Trials         =  1  
        self.TransmitTime   = 10
        self.SettleTime     =  2
        self.AgingTime      =  1 
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.FinalResult = 0
        self.DbSupport       = False

        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table and to compute the latency buckets.  MUST be 2 secords or greater.
                             If the latency buckets do not seem to be learning correctly, increase the FlowLearningTime.
        FlowLearningRate   - Overwritten in this test to compute the latency buckets.  
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 5
        self.FlowLearningRate   = 100
        
        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the raw test details.  This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_unicast_latency.csv'
        self.ReportFilename   = 'Report_unicast_latency.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_unicast_latency.csv'
        self.RSSIFilename    = 'RSSI_unicast_latency.csv'
        
        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   0.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  100.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =   0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        """
        self.FlowOptions    = {'Type': 'IP', 'PhyRate': 54 }
        self.BiDirectional  = False
  
########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.72 $' 
        self.date    = '$Date: 2007/06/25 23:57:52 $' 
        self.FlowMap        = WaveEngine.CreateFlows_Pairs

    def getTestName(self):
        
        return 'unicast_latency'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
            if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
            if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
                if waveTestSpecificStore['unicast_latency']['AcceptableMaxLatency']:
                    if float (waveTestSpecificStore['unicast_latency']['AcceptableMaxLatency']) >= 0:
                        self.UserPassFailCriteria['ref_max_latency']=float(waveTestSpecificStore['unicast_latency']['AcceptableMaxLatency'])/1000
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableMaxLatency should be a positive number\n",WaveEngine.MSG_ERROR) 
                        raise WaveEngine.RaiseException
                else:
                    WaveEngine.OutputstreamHDL("\nUser has not given any value for <AcceptableMaxLatency> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                    ## Give the reference latency Value in milli seconds default 1 msec (default we are giving in seconds)
                    self.UserPassFailCriteria['ref_max_latency']= 0.01

                if waveTestSpecificStore['unicast_latency']['AcceptableAvgLatency']:
                    if float (waveTestSpecificStore['unicast_latency']['AcceptableAvgLatency']) >= 0:
                        self.UserPassFailCriteria['ref_avg_latency']=float(waveTestSpecificStore['unicast_latency']['AcceptableAvgLatency'])/1000
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableAvgLatency should be a positive number\n",WaveEngine.MSG_ERROR) 
                        raise WaveEngine.RaiseException
                else:
                    WaveEngine.OutputstreamHDL("\nUser has not given any value for <AcceptableAvgLatency> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                    ## Give the reference latency Value in milli seconds default 1 msec
                    self.UserPassFailCriteria['ref_avg_latency']= 0.001 
        #___________________________________TEL_________________________________________________
        #These are the test specific parameters that get passed down from the GUI for the test execution
        self.trafficDirection = int(waveMappingStore[0])
        iLoadlist = []
        frameSizeList = []
        iLoadList = waveTestSpecificStore['unicast_latency']['ILoadList']
        frameSizeList = waveTestSpecificStore['unicast_latency']['FrameSizeList']
        if (len(iLoadList) != 0):
            self.ILOADlist = []
            for eachILoadValue in iLoadList:
                self.ILOADlist.append(int(eachILoadValue))
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        # all good
        return True

        
    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters ):
        Iload = float(PassedParameters['ILOAD'])
        Phase = PassedParameters['Phase'] 
        TotalRX     = 0
        TXframeRate = 0
        RXframeRate = 0
        latencyMin  = MAXlatency
        latencyMax  = 0.0
        latencyAvg  = 0.0
        for Portname in PassedParameters['src']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname), globals())
            TXframeRate += stats.txMacFramesRate
        for Portname in PassedParameters['des']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname), globals())
            TotalRX    += stats.rxSignatureValidFrames
#            RXframeRate += stats.rxSignatureValidFramesRate
            RXframeRate += stats.rxMacFramesRate
            if stats.minimumLatencyOverall < latencyMin:
                latencyMin = stats.minimumLatencyOverall
            if stats.maximumLatencyOverall > latencyMax:
                latencyMax = stats.maximumLatencyOverall
#            latencyAvg += stats.averageLatencyOverall * stats.rxSignatureValidFrames
            latencyAvg = stats.averageLatencyOverall

        latencyMinText  = Float2EngNotation(latencyMin / 1000000.0, self.DisplayPrecision)
        latencyMaxText  = Float2EngNotation(latencyMax / 1000000.0, self.DisplayPrecision)
        if TotalRX > 0 :
            latencyAvgText  = Float2EngNotation(latencyAvg / 1000000.0, self.DisplayPrecision)
        else:
            latencyAvgText  = '---'

        latencyAvgText  = Float2EngNotation(latencyAvg / 1000000.0, self.DisplayPrecision)
        WaveEngine.OutputstreamHDL("\r%s ILOAD=%d pkts/sec OLOAD=%d pkts/sec -> FR=%d pkts/sec latency: min=%ss max=%ss avg=%ss (%s %.1f)" % (Phase, Iload, TXframeRate, RXframeRate, latencyMinText, latencyMaxText, latencyAvgText, TXstate, Timeleft ), WaveEngine.MSG_OK)
        return True

    def startTest(self, FuncRealTime):
        if len(self.FrameSizeList) != len(self.ILOADlist):
            msg = "ERROR: Number of Frame Sizes does not equal number of ILOADs.  Please make them the same.\n"
            WaveEngine.OutputstreamHDL( msg, WaveEngine.MSG_ERROR )
            raise WaveEngine.RaiseException()
        
        SrcCardList, DesCardList = self._getSrcandDestCardLists()

        for InterationIndex in range(len(self.FrameSizeList)):
            FrameSize = int(self.FrameSizeList[InterationIndex])
            FrameRate = float(self.ILOADlist[InterationIndex])
            # FIXME -- workaround for VPR 3025 and  2969.
            if FrameSize < 64:
                msg = "WARNING: Latency is not supported for %d byte frames (64 is the minimum size).  Skipping...\n" % (FrameSize)
                WaveEngine.OutputstreamHDL( msg, WaveEngine.MSG_WARNING )
                continue
            if self.trafficDirection == 1 and FrameSize > 1524:    #self.trafficDirection ==1 for 'Wireless to Ethernet' flow
                msg = "WARNING: %d byte frames are not supported by the receiver (Ethernet).  Skipping...\n" % (FrameSize)
                WaveEngine.OutputstreamHDL( msg, WaveEngine.MSG_WARNING )
                continue

            for TrialNumber in range(1, 1 + self.Trials):
                self._applyFlowRate({'AggregateFlowRate':FrameRate}, 
                                    FrameSize)

                #self.modifyFlows(FrameRate, FrameSize, self.FlowLearningTime)
                #Learning Phase
                WaveEngine.ClearAllCounter(self.CardList)
                self.writeRSSIinfo()
                PassedParam = {'FrameSize': FrameSize, 'ILOAD': FrameRate, 'src': SrcCardList, 
                               'des': DesCardList, 'Phase': 'Learning'}
                WaveEngine.OutputstreamHDL("Trial:%d FrameSize: %s ILOAD:%s pkts/sec, Starting learning phase\n" % (TrialNumber, FrameSize, FrameRate), WaveEngine.MSG_OK)
                
                retVal = self._transmitIteration(self.FlowLearningTime , 
                                                      self.SettleTime, 
                                                      self.UpdateInterval, 
                                                      "XmitGroup", 
                                                      True, 
                                                      FuncRealTime , 
                                                      PassedParam )
                if retVal:
                    self.TransmitTime = retVal
                    
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
                WaveEngine.WriteDetailedLog([''])

                #Calculate the buckets
                (latencyMin, latencyMax, latencyAvg) = WaveEngine.MeasurePort_Latency(DesCardList, self.TransmitTime)
                WaveEngine.ClearAllCounter(self.CardList)
                self.writeRSSIinfo(time = 1)
                LatencyBucketSettings = WaveEngine.ConfigureLatencyBuckets(DesCardList, latencyMin, latencyMax)
                if self.UserPassFailCriteria['user']=="True":
                    CSVline = ('Frame Size', 'ILOAD pkt/sec', 'Trial', 'Minimum Latency', 'Maximum Latency', 'Average Latency', 'Average Jitter(us)','USC:AVGLAT','USC:MAXLAT')
                else:
                    CSVline = ('Frame Size', 'ILOAD pkt/sec', 'Trial', 'Minimum Latency', 'Maximum Latency', 'Average Latency', 'Average Jitter(us)')
                for n in LatencyBucketSettings:
                    CSVline += ( "< %ss" % (Float2EngNotation(float(n) / 1000000.0, self.DisplayPrecision)), )
                self.ResultsForCSVfile.append( CSVline )

                # Certain DUT do not like the constant traffic
                if self.AgingTime > 0:
                    WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')

                # Test Phase
                PassedParam['Phase'] = 'Test'
                WaveEngine.OutputstreamHDL("Trial:%d FrameSize: %s ILOAD:%s pkts/sec starting to transmit\n" % (TrialNumber, FrameSize, FrameRate), WaveEngine.MSG_OK)
                self._applyFlowRate({'AggregateFlowRate':FrameRate}, 
                                    FrameSize)
                WaveEngine.WriteDetailedLog(['FrameSize:', FrameSize, 'ILOAD:', 
                                             FrameRate, 'Trial:', TrialNumber, 'TransmitTime (sec):', "%.4f" % self.TransmitTime])
                self._transmitIteration(self.TransmitTime, self.SettleTime, self.UpdateInterval, "XmitGroup", True, FuncRealTime , PassedParam )
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)

                #Get final results for this ILOAD
                (latencyMin, latencyMax, latencyAvg) = WaveEngine.MeasurePort_Latency(DesCardList, self.TransmitTime)
                LatencyBucketCount                   = WaveEngine.MeasureFlow_LatencyHistogram(self.FlowList, self.TransmitTime)
                (JitterMin, JitterMax, JitterAvg) = WaveEngine.MeasureFlow_Jitter(self.FlowList)   

                if self.FlowOptions['Type'] == 'TCP':
                    # Wait for 2 seconds to make sure we get all the TCP ACKs
                    WaveEngine.Sleep(2, 'TCP settling time') 
                           
                TextLatencyMin = Float2EngNotation(latencyMin, self.DisplayPrecision)
                TextLatencyMax = Float2EngNotation(latencyMax, self.DisplayPrecision)
                TextLatencyAvg = Float2EngNotation(latencyAvg, self.DisplayPrecision)
                #_____________________PATCH from TEL________________________________
                if self.UserPassFailCriteria['user']=="True": 
                    TestResult=TestResult1= ''
                    if latencyAvg == 0 or latencyMax==0:
                          TestResult=TestResult1='FAIL'
                          WaveEngine.OutputstreamHDL("\nThe Latency vlaues measured in the test are invalid, hence test is failed ", WaveEngine.MSG_WARNING)                          
                    else:
                        if (float(self.UserPassFailCriteria['ref_avg_latency']) > latencyAvg):
                            TestResult=TestResult+'PASS'
                            WaveEngine.OutputstreamHDL("\nAchieved the P/F criteria given by the User-Avg:%ss , Achieved-Avg:%ss\n" % ( float ( self.UserPassFailCriteria ['ref_avg_latency'] ) , TextLatencyAvg),WaveEngine.MSG_SUCCESS) 
                        else:
                            TestResult=TestResult+'FAIL'
                            WaveEngine.OutputstreamHDL("\nThe test failed to achieve the P/F criteria given by the User-Avg:%ss,Achieved-Avg:%ss\n " %( float ( self.UserPassFailCriteria['ref_avg_latency'] ) , TextLatencyAvg), WaveEngine.MSG_WARNING)
            
                        if (float(self.UserPassFailCriteria['ref_max_latency']) > latencyMax):
                            TestResult1=TestResult1+'PASS'
                            WaveEngine.OutputstreamHDL("\nAchieved the P/F criteria given by the User-Max:%ss,Achieved-Max:%ss\n" %(float(self.UserPassFailCriteria['ref_max_latency']),TextLatencyMax,),WaveEngine.MSG_SUCCESS) 
                        else:
                            TestResult1=TestResult1+'FAIL'
                            WaveEngine.OutputstreamHDL("\nThe test failed to achieve the P/F criteria given by the User-Avg:%ss ,Achieved-Avg:%ss\n" %( float ( self.UserPassFailCriteria['ref_max_latency'] ) , TextLatencyMax), WaveEngine.MSG_WARNING)
                            
                    CSVline = (FrameSize, FrameRate, TrialNumber, latencyMin, latencyMax, latencyAvg, JitterAvg,TestResult,TestResult1)

                else:
                    CSVline = (FrameSize, FrameRate, TrialNumber, latencyMin, latencyMax, latencyAvg, JitterAvg)
                #_________________________END________________________________________________
                for n in LatencyBucketCount:
                    CSVline += ( int(n), )
                self.ResultsForCSVfile.append( CSVline )
                self.ResultsForCSVfile.append( ('',) )
                if latencyMin == 0.0 or latencyMax == 0.0 or latencyAvg == 0.0:
                    WaveEngine.OutputstreamHDL("Completed: Size:%d ILOAD:%.1f pkts/sec zero latency number: Minimum = %ss Maximum = %ss Average = %ss\n" % (FrameSize, FrameRate, TextLatencyMin, TextLatencyMax, TextLatencyAvg), WaveEngine.MSG_SUCCESS)
                else:
                    WaveEngine.OutputstreamHDL("Completed: Size:%d ILOAD:%.1f pkts/sec Latency: Minimum = %ss Maximum = %ss Average = %ss\n" % (FrameSize, FrameRate, TextLatencyMin, TextLatencyMax, TextLatencyAvg), WaveEngine.MSG_SUCCESS)

                WaveEngine.CheckEthLinkWifiClientState(self.CardList, self.ListOfClients)
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)

    # Extract data from the CVS file and puts store it as the object's attribute
    def ParseCVSdata(self, dataFromFile):
        # List if bars used in the Latency graph
        self._LatencyList       = []
        # Data for the Latency Graph
        self._LatencyData   = {}
        # Data for the detailed section of the Report
        if self.UserPassFailCriteria['user']=="True":
             self._LatencyResults = [('Frame Size', 'Frame Rate', 'Trial Number', 'Minimum Latency', 'Maximum Latency', 'Average Latency', 'Average Jitter','USC:AVGLAT','USC:MAXLAT'),]
        else:
             self._LatencyResults = [('Frame Size', 'Frame Rate', 'Trial Number', 'Minimum Latency', 'Maximum Latency', 'Average Latency', 'Average Jitter'),]
        # Data for the Histogram Charts
        self._HistogramData = []
        self._BucketMin     = 4096.0
        self._BucketMax     = 0.0
        
        FrameSize = 'None'
        for eachLine in dataFromFile:
            #print len(eachLine), ':', eachLine
            if self.UserPassFailCriteria['user']=="True":
                if len(eachLine) != 25:
                    continue
                (FrameSize, FrameRate, TrialNumber, LatencyMin, LatencyMax, LatencyAvg, JitterAvg,AVG,MAX,B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16) = eachLine
            else:
                if len(eachLine) != 23:
                    continue
            
                (FrameSize, FrameRate, TrialNumber, LatencyMin, LatencyMax, LatencyAvg, JitterAvg, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16) = eachLine
            if not isnum(FrameSize):
                if self.UserPassFailCriteria['user']=="True":
                   Names = eachLine[9:]
                else:  
                   Names = eachLine[7:]
                BucketValues = []
                for eachName in Names:
                    BucketValues.append(EngNotation2Int(eachName[2:-1]))
                continue
            
            TotalCount = (B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16)
            FrameSize =int(FrameSize)
            FrameRate = float(FrameRate)
            IndexKey = (FrameSize, FrameRate)
            if not IndexKey in self._LatencyList:
                self._LatencyList.append(IndexKey)

            if self._LatencyData.has_key(IndexKey):
                (TotalMin, TotalMax, TotalAvg, Count) = self._LatencyData[IndexKey]
                if TotalMin > LatencyMin:
                    TotalMin = LatencyMin
                if LatencyMax > TotalMax:
                    TotalMax = LatencyMax
                self._LatencyData[IndexKey] = (TotalMin, TotalMax, TotalAvg + LatencyAvg, Count + 1)
            else:
                self._LatencyData[IndexKey] = (LatencyMin, LatencyMax, LatencyAvg, 1)

            # Make sure the last bucket suppose to have counts
            BucketValues[15] = LatencyMax
            if LatencyMax <= BucketValues[14] and TotalCount[15] > 0:
                WaveEngine.OutputstreamHDL("WARNING: detected inconsistency between maximum latency and the last bucket.\n", WaveEngine.MSG_WARNING)
           
            JitterText = "%ss" % (Float2EngNotation(float(JitterAvg/1000000.0), self.DisplayPrecision))
            LatencyMinText = "%ss" % (Float2EngNotation(float(LatencyMin), self.DisplayPrecision) )
            LatencyMaxText = "%ss" % (Float2EngNotation(float(LatencyMax), self.DisplayPrecision) )
            LatencyAvgText = "%ss" % (Float2EngNotation(float(LatencyAvg), self.DisplayPrecision) )
            if self.UserPassFailCriteria['user']=="True":
                self._LatencyResults.append( (FrameSize, FrameRate, TrialNumber, LatencyMinText, LatencyMaxText, LatencyAvgText, JitterText,AVG,MAX), )
            else: 
                self._LatencyResults.append( (FrameSize, FrameRate, TrialNumber, LatencyMinText, LatencyMaxText, LatencyAvgText, JitterText), )

            graphTitle = "Latency Histogram Trial:%s Size:%s Rate:%s frames/sec" % (TrialNumber, FrameSize, FrameRate)
            
            self._HistogramData.append( (Names, [TotalCount, ], graphTitle, LatencyMin, LatencyMax, LatencyAvg), )
            min = EngNotation2Int(Names[0][2:-1])
            max = EngNotation2Int(Names[14][2:-1])
            if self._BucketMin > min:
               self._BucketMin = min
            if max > self._BucketMax:
               self._BucketMax = max

        self._BucketMin = pow(10,int(math.log10(self._BucketMin)-1))
        self._BucketMax = pow(10,int(math.log10(self._BucketMax)))   
        
    def PrintReport(self):
        import os.path
        # Text Paragraphs
        Overview = """The latency test measures the delay incurred by frames passing through the system under test (SUT). It also measures the amount of jitter, which is the variation in latency over many frames. Latency and jitter are key performance metrics that determine how well the SUT can handle traffic, such as voice or real-time video, that is sensitive to the delay between source and destination. This test measures latency and jitter according to RFC 2544 and RFC 3550, respectively."""
        
        LatencyText = """The following graph summarizes the measured minimum, maximum, and average latency performance of the SUT at the specified frame sizes, accumulated over all trials. Lower values indicate better performance. Also, a smaller difference between maximum and minimum latency indicates a better-performing SUT datapath."""
        
        LatencyText2 = """Normal values for latency range from 1 to 1000 microseconds. Values in excess of 20 milliseconds are cause for concern, as they can pose problems for VoIP traffic."""
        
        HistogramText = """The following latency histograms show the distribution of latency values produced by the SUT. Each histogram has 16 buckets (time ranges) into which the measured latency values are placed; the bucket boundaries are determined automatically during the test. Each bucket contains the number of measured latency values that were less than the upper boundary of the bucket, and greater than the upper boundary of the preceding bucket. A separate histogram is plotted for each frame size, offered load and trial."""
        
        HistogramText2 = """Ideally, all of the measured latency values should be clustered into as few buckets as possible, indicating a consistent and uniform delay through the SUT datapath."""
        
        Topology = """The test topology is shown below. Traffic is transmitted in the direction of the arrows. The test client port identifiers and IP addresses are indicated in the boxes, together with the security mode and channel ID for WLAN clients."""
        
        Medthod1 =  """The test is performed by associating test clients with the SUT ports, performing any desired learning transmissions, and then generating test traffic between the test clients. Proprietary timestamps inserted in each test traffic frame are then used to calculate the minimum, maximum and average latency as per RFC 2544, as well as the smoothed interarrival jitter according to RFC 3550. The results are recorded separately for each combination of test conditions, as well as for each trial if multiple trials are run. Results from multiple trials are averaged into the graphs shown above."""
        
        Medthod2 =  """Different intended loads (ILOADs) and frame sizes can be set up, to understand how latency varies with different types of traffic in a real environment. Each combination of ILOAD and frame size is tested separately. Test traffic may be configured to flow either from Ethernet to wireless, from wireless to Ethernet, or from wireless to wireless. If multiple APs are involved in the test, the ILOAD is divided evenly across the APs; if multiple clients are associated with an AP, the ILOAD for that AP is divided evenly between the clients."""
        
        Medthod3 =  """Latency measurements are made accurately even in the presence of frame loss. However, the ILOAD should be set such that no frame loss occurs; otherwise, buffer occupancy delays can obscure actual SUT datapath delays. The throughput test may be used to determine this traffic level."""
        
        HistogramDetails = "Detailed latency histogram tables are not included in this report, but may be obtained from the file '%s' in the results directory." % (self.CSVfilename)

        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Unicast Latency Report", self.DUTinfo, self.TestID )
        MyReport.InsertHeader( "Overview" )
        MyReport.InsertParagraph( Overview )

        self.ParseCVSdata( self.ResultsForCSVfile )
        MyReport.InsertHeader( "Measured Latency" )
        MyReport.InsertParagraph( LatencyText )
        MyReport.InsertObject( self.CreateLatencyGraph( self._LatencyList,
                                                        self._LatencyData,
                                                        GraphWidth  = 5.5 * inch,
                                                        GraphHeight = 3.0 * inch ) )
        MyReport.InsertParagraph( LatencyText2 )
    
        # Create each of the histographs
        MyReport.InsertHeader( "Latency Histograms" )
        MyReport.InsertParagraph( HistogramText )
        MyReport.InsertParagraph( HistogramText2 )
        
        # Create each of the histographs (original style)
        # FIXME -- old histograms put back for VPR 3469
        GraphWidth  = 5.5 * inch
        GraphHeight = 3.0 * inch
        for (Names, Data, Title, LatencyMin, LatencyMax, LatencyAvg) in self._HistogramData:
        #   MyReport.InsertObject(self.HistogramGraph2(GraphWidth, GraphHeight, Names, Data, self._BucketMin, self._BucketMax, LatencyMin, LatencyMax, LatencyAvg, Title))
            MyReport.InsertObject( self.HistogramGraph(GraphWidth, GraphHeight, Names, Data, LatencyMin, LatencyMax, Title ) )
        MyReport.InsertPageBreak()

        MyReport.InsertHeader( "Test Conditions" )
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Frame Sizes', str( self.FrameSizeList ), "Frame sizes in bytes" ),
                             ( 'ILOAD', str( self.ILOADlist ), "Traffic load, frames/sec" ) ]
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 1.25*inch, 3.0*inch, 1.75*inch ] ) # 6-inch total
        
        MyReport.InsertHeader( "Test Configuration" )
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Learning Time', "%d sec" % (self.FlowLearningTime),  'Transmission time (seconds) for initial learning packets, to allow the SUT to set up forwarding tables' ),
                             ( 'Transmit Time', "%d sec" % (self.IntendedTransmitTime), 'Trial duration (seconds) - i.e., duration of test traffic' ),
                             ( 'Settle Time', "%d sec" % (self.SettleTime), 'Idle time after test traffic transmission completes' ),
                             ( 'Number of Trials', "%d" % (self.Trials), 'Number of times measurements are repeated for averaging')]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParameters.append( ('Client Contention', 'ON', 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 2.0*inch, 0.75*inch, 3.25*inch ] )
        
        MyReport.InsertHeader( "Test Topology" )
        MyReport.InsertParagraph( Topology )
        MyReport.InsertClientMap( self.SourceClients, self.DestClients, self.BiDirectional, self.CardMap )
        # count ports used in client lists
        portlist = []
        for eachClient in self.SourceClients + self.DestClients:
            port = eachClient[ 1 ] # extract portname from client tuple
            if port not in portlist:
                portlist.append( port )
        numPorts = len( portlist )
        MyReport.InsertParagraph( "A total of %d ports were used in this test." % numPorts )
        MyReport.InsertPageBreak()
        
        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        allClientList = self.SourceClients + self.DestClients
        allClientList.sort()
        for eachClient in allClientList:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject

            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )

        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])
        
        MyReport.InsertHeader( "Methodology" )
        MyReport.InsertParagraph( Medthod1 )
        MyReport.InsertParagraph( Medthod2 )
        MyReport.InsertParagraph( Medthod3 )
        MyReport.InsertPageBreak()
        
        MyReport.InsertHeader( "Detailed Results" )
        #_____Pass/Fail criteria ______
        if self.UserPassFailCriteria['user']=="True":
            MyReport.InsertDetailedTable( self._LatencyResults, columns = [ 0.5*inch,
                                                                        0.8*inch,
                                                                        0.5*inch,
                                                                        0.8*inch,
                                                                        0.8*inch,
                                                                        0.8*inch,
                                                                        0.8*inch,
                                                                        1.0*inch,
                                                                        1.0*inch] )
        else:  
            MyReport.InsertDetailedTable( self._LatencyResults, columns = [ 0.5*inch,
                                                                        0.8*inch,
                                                                        0.5*inch,
                                                                        0.8*inch,
                                                                        0.8*inch,
                                                                        0.8*inch,
                                                                        0.8*inch ] )
         
        if self.UserPassFailCriteria['user']=="True": 
            NoteText=""" Note: Abbreviations used: USC-User Specified Criteria,MAXLAT: Maximum Latency,AVGLAT: Average Latency"""
            MyReport.InsertParagraph(NoteText)
            fail_count = 0 
            pass_count = 0
            iteration_count=-1
            fail_percent=0
            for each_tuple in self._LatencyResults:
                iteration_count=iteration_count+1 
                if 'FAIL' in each_tuple:
                    fail_count=fail_count+1
                else:
                     pass     
            #fail_percent=float(fail_count*100)/iteration_count
            TextLatMax = Float2EngNotation(float(self.UserPassFailCriteria['ref_max_latency']), self.DisplayPrecision) 
            TextLatAvg =Float2EngNotation(float(self.UserPassFailCriteria['ref_avg_latency']), self.DisplayPrecision) 
            MyReport.InsertHeader( "User Specified P/F Criteria" )
            userspecifiedtext= """  With this feature, user can decide the criteria using which the test is evaluated.We will get
 the input from the user for maximum and average allowable latency in (ms), based on that we will evaluate the test result as PASS/FAIL. """  
            MyReport.InsertParagraph (userspecifiedtext) 
            ConfigParameters = [ ( 'Parameter', 'User Configured Threshold', 'Overall Result' ),
                                 ( ' Avg Latency and Max Latency',"%s : %s secs" %(TextLatAvg,TextLatMax),
                                   "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,iteration_count-fail_count,fail_count) )]
            if fail_count > 0:
                self.FinalResult = 3
            MyReport.InsertParameterTable( ConfigParameters, columns = [ 2*inch, 2*inch, 2*inch ] )
        MyReport.InsertParagraph( HistogramDetails )
        #_____Pass/Fail criteria ______
        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename , 
                               reportObject = MyReport)

        # other info section
        MyReport.InsertHeader( "Other Information" )
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        MyReport.Print()

    def run(self):
        # For debuging reports
        #self.LoggingDirectory = "/home/keith/Documents/Demos/3868-Report_unicast_latency"
        #self.ReadResults()
        #self.PrintReport()
        #return

        #Add some checks to see if the test setup is supported
        if self.FlowLearningTime < 2.0:
            WaveEngine.OutputstreamHDL('ERROR: FlowLearningTime needs to be at least 2 seconds or longer for histograms to work.', WaveEngine.MSG_ERROR)
            return
        
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, 
#                                 self.ClientLearningTime, 
#                                 self.ClientLearningRate)
            self.configureFlows()
            self.setQoShandshakeFlag()
            if self.biFlow:
                self._connectBiFlows()
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus=self.FinalResult  
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus
            
    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """
        msg = """The Latency Benchmarking test allows you to present the system under test (SUT) with an intended load (ILOAD) and measure the time that it takes for frames to be forwarded through the SUT (latency). If you have multiple clients, the ILOAD is divided evenly between the clients sourcing traffic into the SUT. For accurate latency measurement, the ILOAD must be at a level that produces no frame loss. Use the throughput test to determine the maximum ILOAD that can be achieved without frame loss.

Latency is measured by taking the difference between the arrival time of a packet at the destination port and the time the packet was sent at the source port. WaveTest allocates each arriving packet into one of sixteen different "latency buckets". Each latency bucket has a maximum latency time boundary, which are setup in ascending order. The arriving packets are placed in the last latency bucket for which their latency value does not exceed the latency bucket boundary. In this way a distribution of latency times can be measured."""
        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        self.ParseCVSdata(self.ResultsForCSVfile)
      
        # create charts
        charts = {}
        c = self.CreateLatencyGraph(self._LatencyList, self._LatencyData)
        t = c.title
        charts[ t ] = c
        # FIXME -- new histograms disabled for VPR 3469
        for (Names, Data, Title, LatencyMin, LatencyMax, LatencyAvg) in self._HistogramData:
        #   charts[ Title ] = self.HistogramGraph2(640, 480, Names, Data, self._BucketMin, self._BucketMax, LatencyMin, LatencyMax, LatencyAvg, Title)
            charts[ Title ] = self.HistogramGraph(640, 480, Names, Data, LatencyMin, LatencyMax, Title )

        # done with histogram charts
        return charts

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateLatencyGraph(self, ListOfBars, ResultData, GraphWidth = None, GraphHeight = None):
        if not GraphWidth: GraphWidth  = 6.0 * inch
        if not GraphHeight: GraphHeight = 3.5 * inch

        #Break up the latency data into the graphs
        FrameSizeData1 = ()
        FrameSizeData2 = ()
        FrameSizeData3 = ()
        FrameSizeName = []
        for eachFrameSize in ListOfBars:
            (FrameSize, FrameRate) = eachFrameSize
            (TotalMin, TotalMax, TotalAvg, Count) = ResultData[eachFrameSize]
            FrameSizeData1 += (TotalMin, )
            FrameSizeData2 += (TotalMax, )
            FrameSizeData3 += (float(TotalAvg) / float(Count), )
            FrameSizeName.append("%d bytes @\n%spkt/sec" % (FrameSize, Float2EngNotation(FrameRate, self.DisplayPrecision)) )
        return self.LatencyGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeData1, FrameSizeData2, FrameSizeData3], 'Latency')

    class LatencyGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _customSecondsLabelFormat( self, value ):
            return str( "%ss" % Float2EngNotation( value, 2 ) )
            
        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.axes import XCategoryAxis,YValueAxis
            from reportlab.graphics.charts.textlabels import Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            
            self.originX = x
            self.originY = y
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            countSteps = int(self.valueMax / self.valueStep)
            SizeYaxis = 0.0
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                textString = self._customSecondsLabelFormat( eachValue )
                SizeYaxis = max(SizeYaxis, self._stringWidth(textString, STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis - 20 # 20 is padding for the legend
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                # add valid data to chart
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # axis values
                bc.valueAxis.valueMin  = self.valueMin
                bc.valueAxis.valueMax  = self.valueMax
                bc.valueAxis.valueStep = self.valueStep
                # add value labels above bars
                bc.barLabelFormat = self._customSecondsLabelFormat
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                bc.valueAxis.valueMin  = 0
                bc.valueAxis.valueMax  = 1
                bc.valueAxis.valueStep = 1
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            
            # chart formatting
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.labelTextFormat = self._customSecondsLabelFormat
            # axis labels
            bc.categoryAxis.labels.boxAnchor = 'c'
            bc.categoryAxis.labels.dx    = 0
            bc.categoryAxis.labels.dy    = -10
            bc.categoryAxis.labels.angle = 0
            bc.categoryAxis.labels.fontSize = 8

            # add chart
            self.drawing.add(bc)

            #Adjust the labels to be the center of the graph
            self._drawLabels(self.title, "", "")

            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height + legendHeight * 3
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'MIN', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[1].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'MAX', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[2].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'AVG', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight

    class HistogramGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, minimum, maximum, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.Minimum   = minimum
            self.Maximum   = maximum
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.axes import XCategoryAxis,YValueAxis
            from reportlab.graphics.charts.linecharts import Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            self.originX = x
            self.originY = y
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 20

            # Set the last bucket to a resonable number instead of 4000 seconds
            lastBucket = EngNotation2Int(self.dataNames[14][2:-1])
            temp = self.dataNames[:15]
            if self.Maximum > lastBucket:
                self.dataNames = temp + ("< %ss" % ( Float2EngNotation(self.Maximum * 2.0, 3)), )
            else:
                self.dataNames = temp + ("< %ss" % ( Float2EngNotation(lastBucket * 2.0, 3)), )

            bc = VerticalBarChart()
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 0
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 45
            if self.validData:
                # add valid data to chart
                SizeYaxis = 0.0
                countSteps = int(self.valueMax / self.valueStep)
                for n in range(countSteps + 1):
                    eachValue = self.valueMin + n * self.valueStep
                    SizeYaxis = max(SizeYaxis, self._stringWidth(str(eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
                SizeYaxis += bc.valueAxis.tickLeft
                SizeXaxis = 10
                for eachName in self.dataNames:
                    SizeXaxis = max(SizeXaxis, self._stringWidth(eachName, STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
                SizeXaxis = SizeXaxis * sin(radians(bc.categoryAxis.labels.angle)) + bc.categoryAxis.labels.dy
                bc.x = x1 - x + SizeYaxis
                bc.y = y1 - y + SizeXaxis
                bc.height = Height - SizeXaxis
                bc.width  = Width  - SizeYaxis
                self.graphCenterX = bc.x + bc.width/2
                self.graphCenterY = bc.y + bc.height/2
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # set axis values
                bc.valueAxis.valueMin  = self.valueMin
                bc.valueAxis.valueMax  = self.valueMax
                bc.valueAxis.valueStep = self.valueStep
                # add value labels above bars
                bc.barLabelFormat = "%.0f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                SizeYaxis = 15
                bc.x = x1 - x + SizeYaxis
                bc.y = y1 - y + SizeXaxis
                bc.height = Height - SizeXaxis
                bc.width  = Width  - SizeYaxis
                self.graphCenterX = bc.x + bc.width/2
                self.graphCenterY = bc.y + bc.height/2
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                bc.valueAxis.valueMin  = 0
                bc.valueAxis.valueMax  = 1
                bc.valueAxis.valueStep = 1
                
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            # chart format
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            # add chart
            self.drawing.add(bc)

            #Adjust the labels to be the center of the graph
            self._drawLabels(self.title, '', "Count")

    class HistogramGraph2(FlowableGraph):
        def __init__(self, width, height, names, bar, minimum, maximum, LatencyMin, LatencyMax, LatencyAvg, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames  = names
            self.dataBar    = bar
            self.offset     = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title      = title
            self.Minimum    = minimum
            self.Maximum    = maximum
            self.LatencyMin = float(LatencyMin)
            self.LatencyMax = float(LatencyMax)
            self.LatencyAvg = float(LatencyAvg)

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, Rect, String, STATE_DEFAULTS
            from reportlab.graphics.charts.axes import XValueAxis,YValueAxis
            from reportlab.graphics.charts.linecharts import Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            self.originX = x
            self.originY = y
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            #self._drawBox(x, y, self.width, self.height)
            #self._drawBox(x1, y1, Width, Height)
            self.drawing = Drawing(self.width, self.height)

            #Compute the area needed for the axis labels
            SizeXaxis = 18
            SizeYaxis = 0.0
            countSteps = int(self.valueMax / self.valueStep)
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str(eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
            _minimum = int(math.log10(self.Minimum))
            _maximum = int(math.log10(self.Maximum))
            LabelXsize = self._stringWidth("%ss" % (Float2EngNotation(pow(10, _maximum), 1)), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize'])

            PlotW = Width  - SizeYaxis - LabelXsize/2.0
            PlotH = Height - SizeXaxis
            PlotX = x1 - x + SizeYaxis
            PlotY = x1 - x + SizeXaxis
            self.graphCenterX = PlotX + PlotW/2
            self.graphCenterY = PlotY + PlotH/2
            
            #Plot the axis
            self.drawing.add(Line(PlotX, PlotY, PlotX+PlotW, PlotY) )
            _tickXcount = abs(_maximum - _minimum)
            _tickWidth  = PlotW/_tickXcount
            for n in range(_tickXcount+1):
                nexX = _tickWidth * n
                self.drawing.add(Line(PlotX+nexX, PlotY, PlotX+nexX, PlotY - 4, strokeWidth = 1) )
                AxisLabel = Label()
                AxisLabel.fontSize = STATE_DEFAULTS['fontSize']
                AxisLabel.angle = 0
                AxisLabel.boxAnchor = 'n'
                AxisLabel.dx = PlotX + nexX - 1
                AxisLabel.dy = PlotY - 4
                AxisLabel.setText("%ss" % (Float2EngNotation(pow(10, _minimum + n), 1)))
                self.drawing.add(AxisLabel)
            for n in range(_tickXcount):
                for i in range(9):
                    nexX = _tickWidth * n + _tickWidth*log10(i+1)
                    self.drawing.add(Line(PlotX+nexX, PlotY, PlotX+nexX, PlotY - 2, strokeWidth = 0.5) )
             
            self.drawing.add(Line(PlotX, PlotY, PlotX, PlotY+PlotH) )
            for n in range(1, countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                nexY = PlotH/countSteps * n
                self.drawing.add(Line(PlotX, PlotY+nexY, PlotX-4, PlotY+nexY) )
                AxisLabel = Label()
                AxisLabel.fontSize = STATE_DEFAULTS['fontSize']
                AxisLabel.angle = 0
                AxisLabel.boxAnchor = 'e'
                AxisLabel.dx =  PlotX - 6
                AxisLabel.dy = PlotY+nexY
                AxisLabel.setText("%d" % (eachValue))
                self.drawing.add(AxisLabel)
         
            #Plot Data bars
            StartValue = 0
            (R,G,B) = VeriwaveYellow
            ScaleX = PlotW/(_maximum - _minimum)
            ScaleY = PlotH/self.valueMax
            for n in range(len(self.dataNames)):
                value = EngNotation2Int(self.dataNames[n][2:-1])
                count = self.dataBar[0][n]

                _x = ScaleX * (math.log10(value) - _minimum)
                if PlotX + _x > PlotW:
                    _x = PlotW 
                _y = ScaleY * count
                
                r = Rect(PlotX + StartValue, PlotY, _x - StartValue, _y)
                r.fillColor = colors.Color(R,G,B)
                
                BarLabel = Label()
                BarLabel.fontSize = 6
                BarLabel.angle = 0
                BarLabel.boxAnchor = 's'
                BarLabel.dx = PlotX + (_x + StartValue) /2.0
                BarLabel.dy = PlotY + _y + 0.08*inch
                BarLabel.setText("%d" % (count))
                self.drawing.add(BarLabel)

                self.drawing.add(r)
                StartValue = _x

            #Add lines representing MIN/MAX/AVG
            _x = ScaleX * (math.log10(self.LatencyMin) - _minimum)
            self._DrawLine(PlotX + _x, PlotY,  PlotH, colors.blue, 'MIN')
            _x = ScaleX * (math.log10(self.LatencyMax) - _minimum)
            self._DrawLine(PlotX + _x, PlotY,  PlotH, colors.red, 'MAX')
            _x = ScaleX * (math.log10(self.LatencyAvg) - _minimum)
            self._DrawLine(PlotX + _x, PlotY,  PlotH, colors.green, 'AVG')
                
            #Adjust the labels to be the center of the graph
            self._drawLabels(self.title, 'Time', "Count")

        def _DrawLine(self, x, y, h, color, name):
            line = Line(x, y, x, y + h - 5)
            line.strokeWidth = 0.5
            line.strokeColor = color
            line.strokeDashArray=[2, 5] 
            LineLabel = Label()
            LineLabel.fontSize = 6
            LineLabel.angle = 45
            LineLabel.boxAnchor = 'w'
            LineLabel.dx = x
            LineLabel.dy = y + h - 2
            LineLabel.setText(name)
            LineLabel.strokeColor=color
            LineLabel.fillColor=color
            self.drawing.add(line)
            self.drawing.add(LineLabel)


##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
