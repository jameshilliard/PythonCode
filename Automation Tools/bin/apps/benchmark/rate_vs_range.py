#Rate vs. Range Test
#
# Objective: measure the range offered at a particular rate
#            with different values of attenuation in the SUT
#
import os, sys, time, traceback, random
from basetest import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *
import math

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}

        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of '00:00:00:00:00:00'
                       tells the system to pick the first on on the list
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.51.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions )]
        

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        ILOADlist -     List of intended loads. The intended load is expressed in frames/sec, 
                        and is applied at the port level. The port load is divided equally 
                        between all source clients on a port. Units: frames/second
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        #Since the direction of the traffic for this test is from Ethernet to Wireless, please make sure that
        #the frame size should not exceed 1518 Bytes in the self.FrameSizeList
        self.FrameSizeILoadInfo  = {'11n':{'FrameSize':1000,
                                           'ILoad':7000},
                                    '11abg':{'FrameSize':256,
                                             'ILoad':1400}
                                    }
        self.Trials         =  1
        self.TransmitTime   = 10
        self.SettleTime     =  2
        #This is set to a default of seconds as it was observed that certain access points
        #take about 60 seconds to recover.
        self.AgingTime      =  60 
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.ResultsforDb =[]
        self.FinalResult=0

        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the raw test details.  This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_rate_vs_range.csv'
        self.ReportFilename   = 'Report_rate_vs_range.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_rate_vs_range.csv'
        self.RSSIFilename    = 'RSSI_rate_vs_range.csv'
        
        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at teh configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 2
        self.FlowLearningRate   = 100

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results.
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        FerLevel -          This is the list of Frame Error Rate Level values calculated by measurement. Note that there are
                            only 8 fer level values. So we start introducing fer in the SUT at RRSI value about -66dBm which is 
                            about 0.2 % and increase to a maximum value of 32%(approx) in 7 steps.
        InitialPowerLevel - This is the initial power level for the test. Units : dBm
        FinalPowerLevel -   This is the final power level for the test. Units : dBm
        IncrementPowerLevel-This determines the step in which the initial power level value should be incremented to meet the
                            final power level value.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  25.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  25.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =  0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0
        self.Is11nClient = "False"
        self.CardType = '80211a/b/g'
        self.mcTxPowerList = []
        self.ferLevelList = []
        self.InitialPowerLevel = 0
        self.FinalPowerLevel = -50
        self.IncrPowerLevel = -1
        self.InitialPathLoss = 0
        self.FinalPathLoss = 0
        # Please check out Rate_vs_Range-FCS_Error_vs_AP_Power_Level.xls in the
        # benchmark directory for clarification on how we determined these FER 
        # level values below
        self.rssiVsFerDict = {-66:0.2, # RSSI(dBm) : FER level
                              -67:0.5,
                              -68:1.4,
                              -69:1.6,
                              -70:7.7,
                              -71:10.2,
                              -72:14.0,
                              -73:32.3,
                              -74:32.3,
                              -75:32.3,
                              -76:32.3,
                              -77:32.3,
                              -78:32.3,
                              -79:32.3,
                              -80:32.3,
                              -81:32.3,
                              -82:32.3,
                              -83:32.3,
                              -84:32.3,
                              -85:32.3,
                              -86:32.3,
                              -87:32.3,
                              -88:32.3,
                              -89:32.3,
                              -90:32.3,
                              -91:32.3,
                              -92:32.3,
                              -93:32.3,
                              -94:50.0,
                              -95:70.0,
                              -96:90.0,
                              -97:100.0}

        self.rssiVsFerDictFor11n = {-56:0.4,
                                    -57:0.5,
                                    -58:0.6,
                                    -59:0.9,
                                    -60:1.0,
                                    -61:1.6,
                                    -62:3.9,
                                    -63:5.6,
                                    -64:7.2,
                                    -65:7.6,
                                    -66:8.0, 
                                    -67:8.1,
                                    -68:8.6,
                                    -69:10.9,
                                    -70:19.9,
                                    -71:20.1,
                                    -72:21.2,
                                    -73:23.2,
                                    -74:30.3,
                                    -75:33.0,
                                    -76:33.0,
                                    -77:33.0,
                                    -78:33.0,
                                    -79:33.0,
                                    -80:33.0,
                                    -81:33.0,
                                    -82:33.0,
                                    -83:33.0,
                                    -84:33.0,
                                    -85:33.0,
                                    -86:33.0,
                                    -87:33.0,
                                    -88:33.0,
                                    -89:40.0,
                                    -90:48.0,
                                    -91:56.0,
                                    -92:64.0,
                                    -93:72.0,
                                    -94:76.0,
                                    -95:84.0,
                                    -96:92.0,
                                    -97:100.0}
                                    
        self.minRssiFer = -66
        self.maxRssiFer = -97
        self.minRssiFerFor11n = -56
        self.maxRssiFerFor11n = -97
        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        """
        self.FlowOptions    = {'Type': 'UDP', 'PhyRate': 54 }
        #This flag SHOULD NOT BE SET TO TRUE in this test as we are only passing traffic
        #from Ethernet to Wireless and the only traffic going from Wireless To Ethernet
        #are the acknowledgement frames. It is important to note here that we are testing
        #the rate adaptation behavior of the access point and not the wireless client created.
        self.BiDirectional  = False

########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.36 $' 
        self.date    = '$Date: 2006/06/05 17:38:34 $' 
        # FIXME - Ask Carl why moved it here.  
        self.FlowMap = WaveEngine.CreateFlows_Pairs
    
    def getTestName(self):
        
        return 'rate_vs_range' 
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )

        #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
          if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
            self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
          if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
            self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
            if waveTestSpecificStore['rate_vs_range']['RefPowerList']:
               self.UserPassFailCriteria['ref_power_list']=waveTestSpecificStore['rate_vs_range']['RefPowerList']
            else:
               #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ref_power_list> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
               self.UserPassFailCriteria['ref_power_list']=[-6,-7,-8]
            if waveTestSpecificStore['rate_vs_range']['RefRateList']:
                self.UserPassFailCriteria['ref_rate_list']=waveTestSpecificStore['rate_vs_range']['RefRateList']
            else:
                #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ref_rate_list> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                self.UserPassFailCriteria['ref_rate_list']=[3,4,5] 
        #___________________________________TEL_________________________________________________


        #These are the test specific parameters that get passed down from the GUI for the test execution
        #Get the Intended Load List and Frame Size List values from the wml file
        
        #Get the External Attenuation, Initial Power Level, Final Power Level and Increment Power Level
        #values from the wml file.
        self.ExternalAttenuation = float(waveTestSpecificStore['rate_vs_range']['ExternalAttenuation'])
        self.InitialPowerLevel = int(waveTestSpecificStore['rate_vs_range']['InitialPowerLevel'])
        self.FinalPowerLevel = int(waveTestSpecificStore['rate_vs_range']['FinalPowerLevel'])
        self.IncrPowerLevel = -(int(waveTestSpecificStore['rate_vs_range']['IncrementPowerLevel']))
        #Initialize the current power level in the list to be appended to self.InitialPowerLevel
        self.mcTxPowerList = range(self.InitialPowerLevel,
                                   self.FinalPowerLevel,
                                   self.IncrPowerLevel)
        
        # Now add the final requested power level, regardless of the power increment
        self.mcTxPowerList.append(self.FinalPowerLevel)
        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        # all good
        return True


    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters ):
        TotalTX = 0
        TotalRX = 0
        PktType = PassedParameters['Type'] 
        for Portname in PassedParameters['CardList']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname), globals())
            if PktType == 'TCP':
                TotalTX += stats.txTcpFramesOkRate
                TotalRX += stats.rxTcpPacketsOkRate
            elif PktType == 'UDP':
                TotalTX += stats.txUdpFramesOkRate
                TotalRX += stats.rxUdpPacketsOkRate
            else:
                TotalTX += stats.txIpPacketsOkRate
                TotalRX += stats.rxIpPacketsOkRate
        OLOADtext = Float2EngNotation(TotalTX , self.DisplayPrecision)
        FRtext    = Float2EngNotation(TotalRX , self.DisplayPrecision)
        WaveEngine.OutputstreamHDL("\r%s OLOAD=%spkts/sec, FR=%spkts/sec, (%2s %4.1f secs)" % (PassedParameters['Title'], OLOADtext, FRtext, TXstate, ElapsedTime), WaveEngine.MSG_OK)
        return True

    def startTest(self, FuncRealTime):
        #self.SourceClients = [('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.10', '255.255.255.0', '192.168.1.1', (), Security_None, self.ClientOptions )]
        #self.DestClients   = [('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.50', '255.255.255.0', '192.168.1.1', (), Security_None, self.ClientOptions )]
        if self.UserPassFailCriteria['user'] =='True':
              self.ResultsForCSVfile.append( ('Frame Size', 'ILOAD', 'Trial', 'Power Sweep Value dBm', 'OLOAD', 'Forwarding Rate pkts/sec', 'Forwarding Rate bits/sec', 'Frame Loss Rate %','Estimated Path Loss dB','USC:RVR') )  
        else:
              self.ResultsForCSVfile.append( ('Frame Size', 'ILOAD', 'Trial', 'Power Sweep Value dBm', 'OLOAD', 'Forwarding Rate pkts/sec', 'Forwarding Rate bits/sec', 'Frame Loss Rate %','Estimated Path Loss dB') )
        
        #Deriving info from Destination Clients Tuple (self.DestClients) so as 
        #to support both script and GUI mode. 9th element of self.DestClients 
        #tuple is Client Options. Inside that there is a field called 'PhyType' 
        #which tells if it's a 11n or a/b/g client. We shall use that value to 
        #determine the FER Level algorithm to be applied.
        if self.DestClients[0][9]['PhyType'] == '11n':
            self.Is11nClient = "True"

        if self.Is11nClient == 'True':
            phy = '11n'
        else:
            phy = '11abg'
            
        self.testFrameSize =  self.FrameSizeILoadInfo[phy]['FrameSize']
        self.testILoad =    self.FrameSizeILoadInfo[phy]['ILoad']
 
        for TrialNumber in range(1, 1 + self.Trials):
            rssiStep = 0
            correctedRssiValue = 0
            PassedParam = {'Title': None, 'CardList': self.CardList, 
                           'Type': self.FlowOptions['Type']}
            for eachCard in self.CardList:
                #Read the port and determine the card type
                WaveEngine.VCLtest("port.read('%s')" % (eachCard))
                portType = port.type
                if portType != '8023': 
                    if portType == '80211':
                        self.CardType = '80211a/b/g'
                    else:
                        self.CardType = '80211n'
                        
            if self.FlowLearningTime > 0:
                #Do the Flow learning
                PassedParam['Title'] = "Training DUT/SUT "
                self._transmitIteration(self.FlowLearningTime, 0, self.UpdateInterval, "XmitGroup", True, FuncRealTime, PassedParam)
                if self.FlowOptions['Type'] == 'TCP':
                    # Wait for 2 seconds to make sure we get all the TCP ACKs
                    WaveEngine.Sleep(2, 'TCP settling time') 
            FrameRate = float(self.testILoad)
            FrameSize = int(self.testFrameSize)
            FrameRatePerPort = FrameRate / float(len(self.FlowList))
            TheoreticalMFR = WaveEngine.SUTtheoreticalThroughput(self.ListOfClients, 
                                                                 self.FlowList, 
                                                                 '--', 
                                                                 FrameSize, 
                                                                 self.FlowOptions['PhyRate'])
            NumFrames = int(FrameRatePerPort * self.TransmitTime)

            for eachTxPowerLevel in self.mcTxPowerList:
                rssiValue = self.ReportRSSIInformation(self.ListOfClients)
                #WaveEngine.OutputstreamHDL("RSSI Value after being read is %d\n " %rssiValue, WaveEngine.MSG_OK)
                # Calculate the ferLevel for each corrected RSSI
                # we will start incorporating the FER level when the RSSI is
                # less than or equal to -66 dBm. For more info on how we 
                # determine the FER level, please consult the file 
                # Rate_vs_Range-FCS_Error_vs_AP_Power_Level.xls in the
                # benchmark directory
                if rssiValue != "unknown":
                    if self.CardType == "80211n":
                        #Subtract another 20dB because of the hardware bug on the new cards which adds an additional 20 dB
                        #attenuation by default to any incoming signal.
                        correctedRssiValue = (rssiValue + 
                                              (rssiStep * self.IncrPowerLevel) 
                                              + self.InitialPowerLevel - 20)
                        #WaveEngine.OutputstreamHDL("correctedRssiValue: %s " % correctedRssiValue, WaveEngine.MSG_OK)
                        #WaveEngine.OutputstreamHDL("Min RSSI for 11n: %s " % self.minRssiFerFor11n, WaveEngine.MSG_OK)
                        #WaveEngine.OutputstreamHDL("Max RSSI for 11n: %s " % self.maxRssiFerFor11n, WaveEngine.MSG_OK)
                        if correctedRssiValue > self.minRssiFerFor11n:
                            ferLevel = 0.0
                        elif correctedRssiValue < self.maxRssiFerFor11n:
                            ferLevel = self.rssiVsFerDictFor11n[self.maxRssiFerFor11n]  
                        else:
                            ferLevel = self.rssiVsFerDictFor11n[correctedRssiValue]
                    else:
                        correctedRssiValue = rssiValue + (rssiStep * self.IncrPowerLevel) + 6 + self.InitialPowerLevel
                        if correctedRssiValue > self.minRssiFer:
                            ferLevel = 0.0
                        elif correctedRssiValue < self.maxRssiFer:
                            ferLevel = self.rssiVsFerDict[self.maxRssiFer]  
                        else:
                            ferLevel = self.rssiVsFerDict[correctedRssiValue]  
                else:
                    WaveEngine.OutputstreamHDL("Warning: unable to obtain SUT's RSSI value", WaveEngine.MSG_WARNING)

                #print "rssiValue: ", rssiValue, " rssiStep: ", rssiStep, " correctedRssi: ", correctedRssiValue, " txPower: ", eachTxPowerLevel, " ferLevel: ", ferLevel       
                mcNames = WaveEngine.VCLtest("mc.getNames()")
                #Modify the Fer Level and Transmit Power Level on each mobile client
                self.ModifyClients(mcNames,
                                   {'FerLevel':ferLevel,
                                    'TxPower':eachTxPowerLevel}
                                   )
                WaveEngine.ClearAllCounter(self.CardList)
                WaveEngine.WriteAPinformation(self.ListOfClients)
                clientGroupKeys = self.ListOfClients.keys()
                self.modifyFlows(FrameRate, FrameSize)
                #Subtracting another 20 dB because of a hardware bug on the 11n card,
                #as the RSSI power in reality is 20 dB lower than what's being
                #reported. Need to find out if this got fixed in 3.3 or later.
                if self.CardType == "80211n":
                    PathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + self.InitialPowerLevel - 20 - 6
                    if rssiStep == 0:
                        #Use the initial path loss value to input in the PDF Report
                        self.InitialPathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + self.InitialPowerLevel - 20 - 6
                else:
                    PathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + 6 + self.InitialPowerLevel - 6
                    if rssiStep == 0:
                        self.InitialPathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + 6 + self.InitialPowerLevel - 6
                rssiStep += 1
                WaveEngine.OutputstreamHDL("Trial %d: Transmitting %s byte frames at %spkts/sec" % (TrialNumber, FrameSize, Float2EngNotation(FrameRate, self.DisplayPrecision)), WaveEngine.MSG_OK)
                WaveEngine.OutputstreamHDL("\nMobile client transmit power level: %d dBm\n" % eachTxPowerLevel, WaveEngine.MSG_OK)
                WaveEngine.WriteDetailedLog([''])
                PassedParam['Title'] = "ILOAD=%spkts/sec," % (Float2EngNotation(FrameRate, self.DisplayPrecision))
                retVal = self._transmitIteration(self.TransmitTime, self.SettleTime, self.UpdateInterval, "XmitGroup", True, FuncRealTime, PassedParam)
                if retVal:
                    self.TransmitTime = retVal  
                WaveEngine.WriteDetailedLog(['FrameSize:', FrameSize, 
                                             'ILOAD:', FrameRate, 
                                             'Trial:', TrialNumber, 
                                             'TransmitTime (sec):', "%.4f" % self.TransmitTime, 
                                             'Power Sweep Value (dBm) :',eachTxPowerLevel, 
                                             'SUT RSSI (dBm) :', rssiValue, 
                                             'Fer Level (%) :',ferLevel,
                                             'Estimated Path Loss(dB):',PathLoss])
                
                # This is a hack since flows counter do not work with less than 64 byte frames
                if FrameSize < 64:
                    (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = WaveEngine.MeasurePort_OLOAD_FR_LOSSRate(self.CardList, self.TransmitTime, self.FlowOptions['Type'])
                else:
                    (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = WaveEngine.MeasureFlow_OLOAD_FR_LossRate(self.FlowList, self.TransmitTime)
                
                if self.FlowOptions['Type'] == 'TCP':
                    # Wait for 2 seconds to make sure we get all the TCP ACKs
                    WaveEngine.Sleep(2, 'TCP settling time')       
                if self.UserPassFailCriteria['user'] =='True':
                    if eachTxPowerLevel in self.UserPassFailCriteria['ref_power_list']:
                            TestResult=''
                            tmp=self.UserPassFailCriteria['ref_power_list'].index(eachTxPowerLevel)
                            each=self.UserPassFailCriteria['ref_power_list'][tmp]  
                            if int(each) in self.mcTxPowerList:
                                user_fr_mbps=self.UserPassFailCriteria['ref_rate_list'][tmp]
                                ach_fr_mbps=float(FR_bps)/1000000
                                if float(ach_fr_mbps) >=float(user_fr_mbps):
                                    TestResult='PASS'
                                    WaveEngine.OutputstreamHDL("\nTest has achieved the P/F criteria mentioned by the user: User-%s and Achieved-%s\n" %(user_fr_mbps,ach_fr_mbps),WaveEngine.MSG_SUCCESS)
                                else:
                                    TestResult='FAIL'
                                    WaveEngine.OutputstreamHDL("\nTest has failed to achieve the P/F criteria mentioned by the user: User-%s and Achieved-%s \n" %(user_fr_mbps,ach_fr_mbps),WaveEngine.MSG_WARNING)
                            else:
                               WaveEngine.OutputstreamHDL("\nUser has configured a reference power level which is not there in the Tx power list, hence skipping and proceeding to next reference list", WaveEngine.MSG_WARNING)
                    else:
                        TestResult='NaRP'

                    self.ResultsForCSVfile.append( (FrameSize, FrameRate,
                                        TrialNumber, eachTxPowerLevel,
                                        OLOAD, FR, FR_bps,
                                        round(FrameLossRate,2),
                                        PathLoss,TestResult) )
                else:                   
                    self.ResultsForCSVfile.append( (FrameSize, FrameRate, 
                                                         TrialNumber, eachTxPowerLevel, 
                                                         OLOAD, FR, FR_bps, 
                                                         round(FrameLossRate,2), 
                                                         PathLoss) )
                WaveEngine.OutputstreamHDL("Completed: Forwarding rate for %d byte frames is %.1f (or %s bits/sec)" % (FrameSize, FR, Float2EngNotation(FR_bps, self.DisplayPrecision)), WaveEngine.MSG_SUCCESS)
                if FrameLossRate == 0.0:
                    WaveEngine.OutputstreamHDL("Completed: Frame Loss Rate is zero\n", WaveEngine.MSG_SUCCESS)
                else:
                    WaveEngine.OutputstreamHDL("Completed: Frame Loss Rate is %.2f%%\n" % (FrameLossRate), WaveEngine.MSG_SUCCESS)
            
            if self.CardType == "80211a/b/g":
                self.FinalPathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + self.InitialPowerLevel - 20 - 6
            else:
                self.FinalPathLoss = -self.ExternalAttenuation + (rssiStep * self.IncrPowerLevel) + 6 + self.InitialPowerLevel - 6
            #End of Looping through all client Tx Power Level Settings
            
            # Certain DUT do not like the constant traffic
            if self.AgingTime > 0:
                WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time')

            if TrialNumber < self.Trials:
                self._reinitializeClientsAndFlows()
            # check the Ethernet link status
            WaveEngine.CheckEthLinkWifiClientState(self.CardList, {})
    
    def _reinitializeClientsAndFlows(self):
        #Deauth and reconnect the clients as the power level is too low
        #So we set the clients back to -6dBm as that is the default 
        #power level value on the clients and get them connected
        #and then run again through the next trial
        for fgname in WaveEngine.VCLtest("flowGroup.getNames()"):
            WaveEngine.VCLtest("action.stopFlowGroup('%s')" % (fgname))
            WaveEngine.VCLtest("flowGroup.destroy('%s')" % (fgname))
        for flowname in WaveEngine.VCLtest("flow.getNames()"):
            WaveEngine.VCLtest("flow.destroy('%s')" % (flowname))
        for mcname in WaveEngine.VCLtest("mc.getNames()"):
            WaveEngine.VCLtest("mc.deauthenticate('%s', %d)" % (mcname, 0))
            WaveEngine.VCLtest("mc.destroy('%s')" % mcname)
        for name in WaveEngine.VCLtest("ec.getNames()"):
            WaveEngine.VCLtest("ec.destroy('%s')" % name)
        self.VerifyBSSID_MAC()
        self.createClients()
        self.connectClients()
        self.configureFlows()
        self.setQoShandshakeFlag()
        self.doArpExchanges()
        
    def ReportRSSIInformation(self,ClientDict, Time=0):
        listofPortstoScan = []
        listofUsedBSSIDs  = []

        #Create a list of wireless ports to scan
        for ClientName in ClientDict.keys():
            (ConnectCompleteState, PortName, ConnectCompleteCMD) = ClientDict[ClientName]
            if ConnectCompleteCMD == 'ec':
                continue
            if not PortName in listofPortstoScan:
                listofPortstoScan.append(PortName)
            WaveEngine.VCLtest("mc.read('%s')" % (ClientName))
            for eachBSSID in mc.getBssidList():
                eachKey = (PortName, MACaddress(eachBSSID).get())
                if not eachKey in listofUsedBSSIDs:
                    listofUsedBSSIDs.append(eachKey)
        listofPortstoScan.sort()
        #
        #Get the AP info
        #try:
            #_Fhdl = open(_RSSI_FileName, 'a')
        #TimeStop = time.time() + Time
        #TimeLoop = 0.050
        rssiValue = "unknown"
        #while TimeStop + TimeLoop > time.time():
           # _ClockStart = time.time()
        for PortName in listofPortstoScan:
            WaveEngine.VCLtest("port.read('%s')" % (PortName))
            for eachBSSID in port.getBssidList():
                eachKey = (PortName, MACaddress(eachBSSID).get())
                if eachKey in listofUsedBSSIDs:
                    rssiValue = port.getBssidRssi(eachBSSID)
                        #_Fhdl.write("%.3f, %s, %d, %s, %s, %d\n" % \
                        #    (time.time() - TimeScriptStartmS, PortName, int(port.getChannel()), MACaddress(eachBSSID).get(), port.getBssidSsid(eachBSSID), port.getBssidRssi(eachBSSID)), )
            #TimeLoop = (time.time() - _ClockStart) / 2.0
        return rssiValue

    def ModifyClients(self,mcNames,ClientOptions):
        OptionList  = []
        for OptionKey in ClientOptions.keys():
            OptionMethod = "set%s" % (OptionKey)
            if OptionMethod in getMethods("mc"):
                if isnum(ClientOptions[OptionKey]):
                    OptionList.append("mc.%s(%s)" % (OptionMethod, ClientOptions[OptionKey]) )
                else:
                    OptionList.append("mc.%s('%s')" % (OptionMethod, ClientOptions[OptionKey]) )
            else:
                WaveEngine.OutputstreamHDL("Error: Mobile Client option '%s' not supported (ignoring)\n" % (OptionKey), WaveEngine.MSG_WARNING)
                
        for eachClientName in mcNames:
            WaveEngine.Check4UserEscape()
            WaveEngine.VCLtest("mc.read('%s')"  % (eachClientName))
            #WaveEngine.OutputstreamHDL("OptionsList: %s " % OptionList, WaveEngine.MSG_OK)
            for CurrentOption in OptionList:
                WaveEngine.VCLtest(CurrentOption)
                #WaveEngine.OutputstreamHDL("CurrentOption: %s " %CurrentOption, WaveEngine.MSG_OK)
                if CurrentOption.split('(')[0].split('.')[1] == "setFerLevel":
                    WaveEngine.VCLtest("mc.updateFerLevel('%s')" %(eachClientName))
                    #WaveEngine.OutputstreamHDL("Completed updating FER Level on Client: %s " %eachClientName, WaveEngine.MSG_OK)
                elif CurrentOption.split('(')[0].split('.')[1] == "setTxPower":   
                    WaveEngine.VCLtest("mc.updateTxPowerModulation('%s')" %(eachClientName))
                    #WaveEngine.OutputstreamHDL("Completed updating TxPowerModulation on Client: %s " %eachClientName, WaveEngine.MSG_OK)
                else:
                    WaveEngine.OutputstreamHDL("Error: Mobile Client option '%s' not supported (ignoring)\n" % (CurrentOption), WaveEngine.MSG_WARNING)
        
        #for eachClientName in mcNames:
        #    WaveEngine.VCLtest("mc.read('%s')"  % (eachClientName))
        #    WaveEngine.OutputstreamHDL("=========DEBUG STATEMENT=========",WaveEngine.MSG_OK)
        #    WaveEngine.OutputstreamHDL("Client Name: %s" % eachClientName,WaveEngine.MSG_OK)
        #    #print "mc = ",eachClientName
        #    x = WaveEngine.VCLtest('mc.getTxPower()')
        #    WaveEngine.OutputstreamHDL("TxPower: %s" % x,WaveEngine.MSG_OK)
        #    y = WaveEngine.VCLtest('mc.getFerLevel()')
        #    print "The power level on the client after modifying is : ",x
        #    print "The fer level on the client after modifying is : ",y
        #    print "The power level on the client after modifying is : ",mc.getTxPower()
        #    print "The fer level on the client after modifying is : ",mc.getFerLevel()
        
    def PrintReport(self):
        import os.path
        #Strip off the DUT info
        Results  = []
        Results_PF=[]
         
        if self.UserPassFailCriteria['user'] == 'True':
            for line in self.ResultsForCSVfile:
                  if len(line) ==10:
                       Results_PF.append(line)  
                  if len(line) ==10:
                     Results.append(line[:-1])   
        else:           
            for line in self.ResultsForCSVfile:
                  if len(line) ==9:
                       Results.append(line)
        # Text Paragraphs
        Overview= "The mixed rate vs. range test measures the variation in forwarding rate of the system "\
                  "under test (SUT), at a fixed intended load, as the mixed test client(s) are moved away "\
                  "from the SUT. The test clients are generated by the WaveTest system, and the "\
                  "distance between each test client and the SUT is simulated by changing the "\
                  "power and effective frame error ratio (FER) presented by the client to the SUT. "
        FR_text1= "The following graph shows the measured rate at which the SUT can successfully "\
                  "forward packets at a given frame size and fixed intended load, versus the "\
                  "effective path loss interposed between the SUT and the WaveTest generated "\
                  "client. The X axis shows the increasing path loss in dB between the client and "\
                  "the SUT, while the Y axis shows the forwarding rate in bps. "
        FR_text2= "Note that the graph shows rate vs. path loss in dB, rather than rate vs. distance. "\
                  "There is a direct correlation between path loss and distance; an increasing path "\
                  "loss usually corresponds to an increasing distance. The actual range, however, is "\
                  "related to path loss by environmental factors, as will be explained later. "
        FR_text3= "The graph exposes the behavior of the rate adaptation algorithm used by the SUT to "\
                  "maximize transfer rate in the face of increasing distance. In an ideal scenario, the "\
                  "graph should start out at 100% forwarding rate, and remain flat as the path loss is "\
                  "increased, until a threshold of signal to noise ratio (relative to the SUT's receiver "\
                  "sensitivity) is reached. The forwarding rate should then decrease uniformly with "\
                  "increasing path loss until it reaches the point at which the SUT can no longer receive "\
                  "packets properly. At this point the forwarding rate should go to zero and remain there for "\
                  "the rest of the sweep. "
        FR_text4= "A SUT with a more sensitive receiver and/or a higher power transmitter will cause the "\
                  "drop-off in transfer rate to occur at higher path loss (i.e., the drop-off will move to the "\
                  "right). Unexpected spikes or dips in the graph indicate possible problems (e.g., hysteresis) "\
                  "in the rate adaptation algorithm used by the SUT. "
        Method1 = "This test allows the user to present the SUT with constant traffic having a specific intended "\
                  "load (ILOAD) and frame size. The ILOAD is calculated in frames/second. If multiple clients are "\
                  "involved in the test, then the ILOAD is divided evenly between the sourcing clients. The user may "\
                  "specify a variety of ILOAD conditions; the test will measure and output the results for each ILOAD "\
                  "separately. "
        Method2 = "The user should also input the value of any fixed external attenuation that may be inserted in order "\
                  "to center the expected SUT receiver sensitivity within the 37 dB sweep of path loss. The external "\
                  "attenuation should include losses due to external fixed attenuators, cables, splitters etc. The "\
                  "calibration process will take this external attenuation into account. "
        Method3 = "The traffic load is unidirectional and downstream (i.e., flowing from the Ethernet port to the WLAN "\
                  "port of the SUT). The only upstream traffic flowing during the test will be the 802.11 acknowledgement "\
                  "frames from the WLAN clients to the Ethernet clients in response to the data being transmitted, as well "\
                  "as the learning frames transmitted by the WLAN clients to set up the SUT datapaths. "
        Method4 = "The response of the SUT is measured in terms of forwarding rate at a specific path loss. Forwarding rate "\
                  "is measured by counting the number of good packets that have been successfully received at the destination "\
                  "WLAN WaveBlade(s) over the course of the test. In addition to forwarding rate, the packet loss is also "\
                  "calculated (by taking the difference between the transmitted and received packets). "
        Method5 = "As mentioned above, this test expresses the rate in terms of path loss (attenuation in dB) rather than "\
                  "directly in range (distance in meters or feet). This is because the relationship between path loss and "\
                  "range is dictated by a variety of environmental factors, such as whether the SUT is located indoors or "\
                  "outdoors. Indoor environments are complex: the composition of the walls and ceilings, the location of "\
                  "metallic objects, the dimensions of the rooms, etc. all play a part in determining the path loss between "\
                  "an AP and a client. "
        RSSIdetails = "SUT details are given below. The received signal strength indication (RSSI) from the SUT is sampled on "\
                      "each port at the start of each trial and averaged over all trials."
        RSSIdetails2 = "Desired RSSI values are in the range of -25 dBm to -35 dBm. If the RSSI is not in this range, the external "\
                       "attenuation should be modified to bring it into this range.  Note that this test simulates path loss.  External "\
                       "attenuation may need to be adjusted so the test can sweep over an emulated power range in which frame errors "\
                       "are expected (below -65 dBm)."
    
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Rate vs. Range Report", self.DUTinfo)
        MyReport.InsertHeader("Overview")
        MyReport.InsertParagraph(Overview)
        MyReport.InsertHeader("Rate vs. Range")
        MyReport.InsertParagraph(FR_text1)
        MyReport.InsertObject(self.CreateRateVsRangeGraph( self.testFrameSize, 
                                                           self.testILoad, 
                                                           Results ))
        MyReport.InsertParagraph(FR_text2)
        MyReport.InsertParagraph(FR_text3)
        MyReport.InsertParagraph(FR_text4)
        #for eachILOAD in self.ILOADlist:
        #    MyReport.InsertObject(self.CreateForwardingRateGraph(eachILOAD, Results))
        #MyReport.InsertHeader("Frame Loss Rate")
        #MyReport.InsertParagraph(FR_text2)
        #for eachILOAD in self.ILOADlist:
        #    MyReport.InsertObject(self.CreateFrameLossRateGraph(eachILOAD, Results))

        MyReport.InsertHeader("Test Configuration")
        ConfigParamters = [('Parameter', 'Value', 'Description'),
                           ('Learning Time', "%d secs" % (self.FlowLearningTime),  'The number of seconds to transmit frames for the DUT/SUT to populate its forwarding tables.'),
                           ('Transmit Time', "%d secs" % (self.IntendedTransmitTime), 'The number of seconds that the WaveTest will transmit for each iteration.'),
                           ('Settle Time', "%d secs" % (self.SettleTime), 'How many seconds to wait for the DUT/SUT to finish forwarding frames before making the final measurement.'),
                           ('Trials', "%d" % (self.Trials), 'Number of times the measurement will be executed.  Multiple trials are used for averaging the measurement.'),
                           ('External Attenuation',"%.2f dB" %(self.ExternalAttenuation),'This is the total attenuation in the SUT. This includes the attenuation due to attenuators, cable losses etc.'),
                           ('Initial Power Level (Path Loss)', "%d dBm (%d dB)" %(self.InitialPowerLevel, -self.InitialPathLoss) ,'This is the initial power level specified by the user for the power sweep. Initial path loss value corresponding to the initial power level is specified in parentheses.'),
                           ('Final Power Level (Path Loss)',"%d dBm (%d dB)" %(self.FinalPowerLevel, -self.FinalPathLoss),'This is the final power level specified by the user for the power sweep. Final path loss value corresponding to the final power level is specified in parentheses.'),
                           ('Decrement Power Level',"%d dB" %(-self.IncrPowerLevel),'This is the decrement power level specified by the user for the power sweep. ')]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ('Client Contention', 'ON', 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
        MyReport.InsertParameterTable(ConfigParamters, columns=[2*inch, 0.75*inch, 3.25*inch])
        
        MyReport.InsertHeader("Client Map")
        MyReport.InsertClientMap(self.SourceClients, self.DestClients, self.BiDirectional, self.CardMap)
        MyReport.InsertPageBreak()
        
        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        allClientList = self.SourceClients + self.DestClients
        allClientList.sort()
        for eachClient in allClientList:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject
            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )

        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])

        MyReport.InsertHeader("Methodology")
        MyReport.InsertParagraph(Method1)
        MyReport.InsertParagraph(Method2)
        MyReport.InsertParagraph(Method3)
        MyReport.InsertParagraph(Method4)
        MyReport.InsertHeader("Path Loss vs. Distance")
        MyReport.InsertParagraph(Method5)
        MyReport.InsertPageBreak()
        MyReport.InsertHeader("Detailed Results")
        if self.UserPassFailCriteria['user'] =='True':
            MyReport.InsertDetailedTable(Results_PF, columns=[0.5*inch, 0.6*inch, 0.4*inch, 0.65*inch, 0.65*inch, 0.75*inch, 0.75*inch, 0.65*inch, 0.65*inch,0.65*inch])
            NoteText=""" Note: Abbreviations used: USC-User Spefied Criteria,RVR-RateVsRange and NaRP-Not an Reference Point """
            MyReport.InsertParagraph(NoteText)
            iteration_count=-1
            fail_count =0
            pass_count  =0
            narp_count=0
            for each_tup in Results_PF:
                iteration_count=len (self.UserPassFailCriteria['ref_power_list'])
                for each_value in each_tup:
                    if each_value == 'FAIL':
                        fail_count=fail_count+1
                    elif each_value == 'NaRP':
                        narp_count=narp_count+1    
       	            elif each_value == 'PASS':
		                pass_count=pass_count+1
            #fail_perc=float(fail_count/iteration_count)* 100

            MyReport.InsertHeader( "User Specified P/F criteria" )
            userspecifiedtext= """  With this feature, user can decide the criteria using which the test is evaluated.We will get the input from the user for Minimum Expected clients , based on that we will evaluate the test result as PASS/FAIL. """
            MyReport.InsertParagraph (userspecifiedtext)
            ConfigParameters = [ ( 'Parameter', 'User defined Value', 'Overall Result' ),
                                   ( 'Reference Power List(dBm)::Reference Rate List(Mbps)',"%s::%s" %(self.UserPassFailCriteria['ref_power_list'],self.UserPassFailCriteria['ref_rate_list']),"Total:%s, PASS:%s, FAIL:%s and NaRP:%s"%(iteration_count,pass_count,fail_count,narp_count)  )]
            if fail_count > 0:
                self.FinalResult =3
            MyReport.InsertParameterTable( ConfigParameters, columns = [ 3.5*inch, 1.5*inch, 1.75*inch ] ) # 6-inch total
            note=""" The Total count is with reference to number of reference points which the user configured, remaining points will be Narp.Out of the total reference points which the user configured, the test will be evaluated for Pass/Fail."""
            MyReport.InsertParagraph(note)
        else:
            MyReport.InsertDetailedTable(Results, columns=[0.5*inch, 0.6*inch, 0.4*inch, 0.65*inch, 0.65*inch, 0.75*inch, 0.75*inch, 0.65*inch, 0.65*inch])

        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename , 
                               reportObject = MyReport, 
                               text1 = RSSIdetails, text2 = RSSIdetails2)

        # other info section
        MyReport.InsertHeader("Other Info")
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        #Hack to stop printing the document
        if self.generatePdfReportF:
            MyReport.Print()


    def run(self):
        # For debuging the reports
        #self.LoggingDirectory = "C:\\myCVS\\veriwave_sw_tga\\apps\\WaveAppSuite\\logs"
        #self.ReadResults()
        #self.PrintReport() 
        #return
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, 
                               Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
            WaveEngine.ClientLearning(self.ListOfClients, 
                                      self.ClientLearningTime, 
                                      self.ClientLearningRate)
            self.configureFlows()
            self.setQoShandshakeFlag()
            if self.biFlow:
                self._connectBiFlows()
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus = self.FinalResult
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.SaveResults()
            self.ExitStatus = 2
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        Method = "This test allows the user to present the system under test (SUT) with a specific "\
                 "intended load (ILOAD in frames/sec) at a given frame size and fixed external attenuation "\
                 "conditions, and measure the forwarded traffic rate as a function of path loss "\
                 "(equivalent to range). The user should input the value of the external attenuation, "\
                 "the desired initial and final transmit power level values for the path loss sweep, and the "\
                 "step size by which the path loss is changed.\n\nThe external attenuation (dB) should include "\
                 "the attenuation due to fixed external attenuators, cable losses, splitter losses etc. It "\
                 "should be set such that the AP power level at the WBW-1000 antenna port is between -55 and "\
                 "-45 dBm. For example, with an AP output power of +20 dBm, a 70 dB external attenuation should "\
                 "be used. The external attenuation may have to be modified experimentally in order to center the "\
                 "rate rolloff curve within the path loss sweep."
        return Method
    
    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        { 'Frame Loss [ILOAD=100]': <obj>,
          'Frame Loss [ILOAD=200]': <obj>,
          'Latency [framesize=100, ILOAD=100]': <obj>,
          <chart title>, <chart object> }
        """
        
        # code from Jerry to strip off irrelevant headings
        results = []
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                results.append(line)
            if len(line) == 0:
                flag = True
        # create charts
        charts = {}
        for (eachFrameSize,eachILOAD) in map(None,self.FrameSizeList,self.ILOADlist):
            c = self.CreateRateVsRangeGraph( eachFrameSize, eachILOAD, results )
            t = c.title
            charts[t] = c
        return charts

################################### Flowables #################################
#These are unique objects that a placed in the Report.PDF file.
    def CreateRateVsRangeGraph(self, DesiredFrameSize, DesiredFrameRate, ResultData):
    
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.5 * inch
        
        #Extract the data from the CSV file
        _FinalExtractedData= []
        _ExtractedDataDict = {}
        dummyList = []
        for eachLine in ResultData:
            #This tuple contains the rate and range values for that line being parsed
            rateRangeTuple = ()
            if len(eachLine) != 9:
                continue
            (FrameSize, FrameRate, TrialNumber, PowerLevel, OLOAD_FPS, FR_FPS, FR_BPS, FrameLossRate,PathLoss) = eachLine
            if not isnum(FrameSize):
                continue
            #this is to parse the DesiredFrameSize and the DesiredFrameRate data ONLY from the CSV file
            if int(DesiredFrameSize) != int(FrameSize) or int(DesiredFrameRate) != int(FrameRate):
                continue
            if _ExtractedDataDict.has_key(int(TrialNumber)):
                PathLoss = -1 * PathLoss
                rateRangeTuple = (PathLoss,FR_BPS)
                dummyList.append(rateRangeTuple)
            else:
                dummyList = []
                PathLoss = -1 * PathLoss
                rateRangeTuple = (PathLoss,FR_BPS)
                dummyList.append(rateRangeTuple)
            finalTuple = tuple(dummyList)
            _ExtractedDataDict[TrialNumber] = finalTuple
        TrialsList = _ExtractedDataDict.keys()
        TrialsList.sort()
        
        graphTitle = "Rate vs. Path Loss for %s Bytes @ %s frames/sec" %(DesiredFrameSize, DesiredFrameRate)
        
        for eachTrial in TrialsList:
            _FinalExtractedData.append(_ExtractedDataDict[eachTrial])
        return self.RateVsRangeGraph(GraphWidth, GraphHeight, _FinalExtractedData, graphTitle)
    
    class RateVsRangeGraph(FlowableGraph):
        def __init__(self, width, height, line, title):
            FlowableGraph.__init__(self, width, height)
            self.dataLine  = line
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title
        
        def _customSecondsLabelFormat( self, value ):
            return str( "%sbps" % Float2EngNotation( value, 5 ) )
        
        def _rawDraw(self, x, y):
            from reportlab.lib import colors
            from reportlab.graphics.charts.utils import nextRoundNumber
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.lineplots import LinePlot
            from reportlab.graphics.widgets.markers import makeMarker
            from reportlab.graphics.charts.linecharts import Label
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            self._setScale(self.dataLine)
            
            self.drawing = Drawing(self.width, self.height)
    
            #These are the standard Veriwave colours used in the reports
            VeriwaveBlue   = [  0/255.0, 158/255.0, 179/255.0]
            VeriwaveYellow = [235/255.0, 156/255.0,  24/255.0]
            VeriwaveGreen  = [206/255.0, 229/255.0, 183/255.0]
            VeriwaveLtBlue = [219/255.0, 243/255.0, 244/255.0]
            
            #These are some custom colours
            LtGreen = [128/255.0, 254/255.0, 1/255.0]
            DarkGreen = [0/255.0, 128/255.0, 0/255.0]
            Mahroon = [128/255.0, 0/255.0, 0/255.0]
            Purple = [64/255.0, 0/255.0, 64/255.0]
            DarkBlue = [29/255.0, 1/255.0, 186/255.0]
            Brown = [128/255.0, 64/255.0, 0/255.0]
            
            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            singlePlot = False
            
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                textString = self._customSecondsLabelFormat( eachValue )
                SizeYaxis = max(SizeYaxis, self._stringWidth(textString, STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            lp = LinePlot()
            SizeYaxis += lp.yValueAxis.tickLeft
            lp.x = x1 - x + SizeYaxis
            lp.y = y1 - y + SizeXaxis
            lp.height = Height - SizeXaxis 
            lp.width  = Width  - SizeYaxis - lp.yValueAxis.tickLeft - 10 - 45 # legend padding
            self.graphCenterX = lp.x + lp.width/2
            self.graphCenterY = lp.y + lp.height/2
            colorsList = [DarkGreen,VeriwaveBlue,Purple,Brown,LtGreen,Mahroon,DarkBlue]
            if self.validData:
                # add valid data to chart
                if len(self.dataLine[0]) == 1:
                    lp.xValueAxis.valueMin = 0
                    lp.xValueAxis.valueMax = self.dataLine[0][0][0]
                    lp.xValueAxis.valueSteps = [0, self.dataLine[0][0][0]]
                    lp.yValueAxis.valueMin = 0
                    lp.yValueAxis.valueMax = self.dataLine[0][0][1]
                    lp.yValueAxis.valueSteps = [0, self.dataLine[0][0][1]]
                    singlePlot = True
                else:
                    lp.xValueAxis.configure(self.dataLine)
                    lp.yValueAxis.configure(self.dataLine)
                lp.data = self.dataLine
                lp.joinedLines = 1
                # if trials is > 7, we need to generate more colors for the
                # lines in the graph
                if len(self.dataLine) > 7:
                    numColor = len(self.dataLine) - 7
                    for i in range(numColor):
                        colorsList.append([random.randint(0,255)/255.0,
                                           random.randint(0,255)/255.0,
                                           random.randint(0,255)/255.0
                                           ])
                    
                for eachDataLine in range(0,len(self.dataLine)):
                    (R,G,B) = colorsList[eachDataLine]
                    if singlePlot == True:
                        lp.lines[eachDataLine].symbol = makeMarker('FilledDiamond')
                    lp.lines[eachDataLine].strokeColor = colors.Color(R,G,B)
            else:
                # no valid data
                lp.xValueAxis.valueMin = 0
                lp.xValueAxis.valueMax = 1
                lp.xValueAxis.valueSteps = [0, 1]
                lp.yValueAxis.valueMin = 0
                lp.yValueAxis.valueMax = 1
                lp.yValueAxis.valueSteps = [0, 1]
                lp.data = [ ((0,0),), ]

                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            # format chart       
            #lp.yValueAxis.labelTextFormat = '%.3f Mbps'
            lp.yValueAxis.labelTextFormat = self._customSecondsLabelFormat
            
            lp.xValueAxis.labelTextFormat = '%.1f '
            self.drawing.add(lp)
            self._drawLabels(self.title, "Estimated Path Loss (dB)", "")

            ## Draw a line representing MFR on the X axis
            #if self.validData:
            #    xPos = lp.width * (self.MaxPoint - lp.xValueAxis._valueMin) / (lp.xValueAxis._valueMax - lp.xValueAxis._valueMin)
            #    self.drawing.add(Line(lp.x + xPos, lp.y, lp.x + xPos, lp.y + lp.height, strokeColor=colors.red, strokeWidth=1, strokeDashArray = [2,2]))
            #    # add label for MFR
            #    textString = "%.0f " % self.MaxPoint
            #    textWidth = self._stringWidth( textString, STATE_DEFAULTS['fontName'], 9 )
            #    self.drawing.add( String( lp.x + xPos - textWidth, lp.y + lp.height/2 + 6,
            #                              textString,
            #                              fontName = STATE_DEFAULTS['fontName'], fontSize = 9 ) )
            #    textString = "pkts/sec "
            #    textWidth = self._stringWidth( textString, STATE_DEFAULTS['fontName'], 9 )
            #    self.drawing.add( String( lp.x + xPos - textWidth, lp.y + lp.height/2 - 6,
            #                              textString,
            #                              fontName = STATE_DEFAULTS['fontName'], fontSize = 9 ) )
                
            #Add Legend in upper right corner
            legendHeight  = 9 
            legendX = lp.x + lp.width + 5
            legendY = lp.y + lp.height - 12
            offset = 0
            for eachTrial in range(0,len(self.dataLine)):
                (R,G,B) = colorsList[eachTrial]
                self.drawing.add(Line(legendX , legendY + 3 - offset, legendX + 20 , legendY + 3 - offset, strokeColor=colors.Color(R,G,B), strokeWidth=1))
                self.drawing.add(String(legendX + 22 , legendY - offset, "Trial  " + ('%s') %(eachTrial+1), fontName='Helvetica', fontSize=8))
                offset = offset + 8
            
                
##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    parser.add_option("--dbsupport",
                    dest="dbsupport", action="store_true", default=False,
                    help="save Results to the database")
    parser.add_option("--pf",
                    dest="passfail", action="store_true", default=False,
                    help="user pass/fail criteria enable/disable")

    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    if options.dbsupport:
        userTest.DbSupport = True
    if options.passfail:
        userTest.UserPassFailCriteria['user'] = True

    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
