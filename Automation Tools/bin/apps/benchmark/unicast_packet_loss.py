#unicast_packet_loss
#
# Objective: measure the forwarding rate and frame loss at different
#            loads and frames sizes
#
import os, sys, time, traceback
from basetest import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}

        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of '00:00:00:00:00:00'
                       tells the system to pick the first on on the list
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.51.1', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions )]
        

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        ILOADlist -     List of intended loads. The intended load is expressed in frames/sec, 
                        and is applied at the port level. The port load is divided equally 
                        between all source clients on a port. Units: frames/second
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        self.FrameSizeList  = [ 128 ]
        self.ILOADlist      = [ 100, 500 ]
        self.Trials         =  1
        self.TransmitTime   = 10
        self.SettleTime     =  2
        self.AgingTime      =  0 
        #___________________________________TEL_________________________________________________ 
        """
        Used Defined Test Pass/Fail criteria.
        UserPassFailCriteria['user']              - user defined pass/fail criteria enable/disable
                                                    Theoretical Medium capacity for the frame size given.
                                                    Else could be specified directly in Mbps.
        UserPassFailCriteria['ref_forwardingrate']- Specified as either percentage of theoretical Medium capacity
                                                    for the given framesize or directly in Mpbs.
        UserPassFailCriteria['ref_tolerance']     - The percentage of tolearable packet loss.
        Default values: 
        by default it is disabled and in percentage mode with 90% forwarding rate and 10% loss tolerance.  

        FinalResult         - The final Result of the particular test case executed, if the user defined 
        DbSupport           - Boolean True/False value. If True the results will be logged into Databse Tables. 
        """
        self.UserPassFailCriteria = {} 
        self.UserPassFailCriteria['user']='False'
         
        self.FinalResult = 0
        self.DbSupport       = False
        self.DbType          = "mysql"
        self.DbName          = "veriwave"
        self.DbUserName      = "root"
        self.DbPassword      = "veriwave"
        self.DbServerIP      = "localhost"

        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the raw test details.  This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_unicast_packet_loss.csv'
        # CHB add new file to write. 
        self.CSVSpecialfilename      = 'Results_custom_packet_loss.csv'
        self.enableCustomCSV  = False
        self.ReportFilename   = 'Report_unicast_packet_loss.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_unicast_packet_loss.csv'
        self.RSSIFilename    = 'RSSI_unicast_packet_loss.csv'

        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at teh configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 2
        self.FlowLearningRate   = 100

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results.
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  25.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  25.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =  0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        """
        self.FlowOptions    = {'Type': 'UDP', 'PhyRate': 54 }
        self.BiDirectional  = False

########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.56 $' 
        self.date    = '$Date: 2007/06/25 23:59:14 $' 
        # FIXME - Ask Carl why moved it here.  
        self.FlowMap = WaveEngine.CreateFlows_Pairs
    
    def getTestName(self):
        
        return 'unicast_packet_loss'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        #These are the test specific parameters that get passed down from the GUI for the test execution
        iLoadlist = []
        frameSizeList = []
        iLoadList = waveTestSpecificStore['unicast_packet_loss']['ILoadList']
        frameSizeList = waveTestSpecificStore['unicast_packet_loss']['FrameSizeList']
        #___________________________________TEL_________________________________________________ 
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and 
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if waveTestStore['LogsAndResultsInfo'].has_key('db'): 
            if  waveTestStore['LogsAndResultsInfo']['db'] == 'True':
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
            if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
                if waveTestSpecificStore['unicast_packet_loss']['AcceptableFrameLossRate']:
                    if float ( waveTestSpecificStore['unicast_packet_loss']['AcceptableFrameLossRate']) >=0:
                        self.UserPassFailCriteria['ref_tolerance']=float(waveTestSpecificStore['unicast_packet_loss']['AcceptableFrameLossRate'])
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableFrameLossRate should be a positive number\n",WaveEngine.MSG_ERROR)
                        raise  WaveEngine.RaiseException
                else:
                    #WaveEngine.OutputstreamHDL("\nUser has not given the value for <AcceptableFrameLossRate> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING) 
                    self.UserPassFailCriteria['ref_tolerance']=10              

            #if waveTestSpecificStore['unicast_packet_loss']['ForwardingRateMode']:
            #   self.UserPassFailCriteria['ref_fwd_mode']=waveTestSpecificStore['unicast_packet_loss']['ForwardingRateMode']
            #else:
            #    WaveEngine.OutputstreamHDL("\nUser has not given the value for <ForwardingRateMode> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
            #    self.UserPassFailCriteria['ref_fwd_mode']="percentage" 
            #if waveTestSpecificStore['unicast_packet_loss']['AcceptableForwardingRate']:
            #       self.UserPassFailCriteria['ref_forwardingrate']=waveTestSpecificStore['unicast_packet_loss']['AcceptableForwardingRate']
            #else:
            #       WaveEngine.OutputstreamHDL("\nUser has not given the value for <AcceptableForwardingRate> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
            #       self.UserPassFailCriteria['ref_forwardingrate']=90 
        #___________________________________TEL_________________________________________________ 
        if (len(iLoadList) != 0):
            self.ILOADlist = []
            for eachILoadValue in iLoadList:
                self.ILOADlist.append(int(eachILoadValue))
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))

        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        
        # all good
        return True

    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters ):
        TotalTX = 0
        TotalRX = 0
        PktType = PassedParameters['Type'] 
        for Portname in PassedParameters['CardList']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname), globals())
            if PktType == 'TCP':
                TotalTX += stats.txTcpFramesOkRate
                TotalRX += stats.rxTcpPacketsOkRate
            elif PktType == 'UDP':
                TotalTX += stats.txUdpFramesOkRate
                TotalRX += stats.rxUdpPacketsOkRate
            else:
                TotalTX += stats.txIpPacketsOkRate
                TotalRX += stats.rxIpPacketsOkRate
        OLOADtext = Float2EngNotation(TotalTX , self.DisplayPrecision)
        FRtext    = Float2EngNotation(TotalRX , self.DisplayPrecision)
        WaveEngine.OutputstreamHDL("\r%s OLOAD=%spkts/sec, FR=%spkts/sec, (%2s %4.1f secs)" % (PassedParameters['Title'], OLOADtext, FRtext, TXstate, ElapsedTime), WaveEngine.MSG_OK)
        return True

    def startTest(self, FuncRealTime):
        #___________________________________TEL_________________________________________________ 
        if self.UserPassFailCriteria['user']=="True":
           self.ResultsForCSVfile.append( ('Frame Size', 'ILOAD', 'Trial', 
                                        'Theoretical Rate pkts/sec', 
                                        'Theoretical Rate bits/sec', 'OLOAD', 
                                        'Forwarding Rate pkts/sec', 
                                        'Forwarding Rate bits/sec', 
                                        'Frame Loss Rate','USC:LT',
                                        'Min Latency', 'Max Latency',
                                        'Avg Latency', 'Avg Jitter') )
        else:
            self.ResultsForCSVfile.append( ('Frame Size', 'ILOAD', 'Trial',
                                        'Theoretical Rate pkts/sec',
                                        'Theoretical Rate bits/sec', 'OLOAD',
                                        'Forwarding Rate pkts/sec',
                                        'Forwarding Rate bits/sec',
                                        'Frame Loss Rate',
                                        'Min Latency', 'Max Latency',
                                        'Avg Latency', 'Avg Jitter') )
        #___________________________________TEL_________________________________________________ 
        # CHB write to new file.  
        self.ResultsForCSVSpecialfile.append( ('FrameSize', 'Trial', 'ILOAD', 'TxFrames', 'RxFrames', 'LostFrames', 'MinLatency(sec)', 'MaxLatency(sec)', 'AvgLatency(sec)', 'Tx fps', 'Tx L2 bps', 'Rx fps', 'Rx L3 bps', 'Rx L2 bps'  ) )
        PassedParam = {'Title': None, 'CardList': self.CardList, 
                       'Type': self.FlowOptions['Type']}
        
        self._doFlowLearning(FuncRealTime, PassedParam)
                    
        SrcCardList, DesCardList = self._getSrcandDestCardLists()
        
        mediumCapacityCalculator = self.getMediumCapacityCalculator()
        
        for eachSize in self.FrameSizeList:
            for eachILOAD in self.ILOADlist:
                FrameRate = float(eachILOAD)
                FrameSize = int(eachSize)
                TheoreticalMFR = mediumCapacityCalculator(eachSize)
                for TrialNumber in range(1, 1 + self.Trials):
                    WaveEngine.ClearAllCounter(self.CardList)
                    self.writeRSSIinfo()
                    self._applyFlowRate({'AggregateFlowRate':FrameRate}, 
                                        FrameSize)
                    WaveEngine.OutputstreamHDL("\nTrial %d: Transmitting %s byte frames at %spkts/sec\n" % (TrialNumber, FrameSize, Float2EngNotation(FrameRate, self.DisplayPrecision)), WaveEngine.MSG_OK)
                    WaveEngine.WriteDetailedLog([''])
                    
                    PassedParam['Title'] = "ILOAD=%spkts/sec," % (Float2EngNotation(FrameRate, self.DisplayPrecision))
                    retVal = self._transmitIteration(self.TransmitTime, self.SettleTime, self.UpdateInterval, "XmitGroup", True, FuncRealTime, PassedParam)
                    WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
                    if retVal:
                        self.TransmitTime = retVal
                    
                    WaveEngine.WriteDetailedLog(['FrameSize:', FrameSize, 'ILOAD:', 
                                                 FrameRate, 'Trial:', TrialNumber,
                                                 'Achieved TransmitTime (sec):', "%.2f" % self.TransmitTime])

                    # This is a hack since flows counter do not work with less than 64 byte frames
                    if FrameSize < 64:
                        (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = WaveEngine.MeasurePort_OLOAD_FR_LOSSRate(self.CardList, self.TransmitTime, self.FlowOptions['Type'])
                    else:
                        (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = WaveEngine.MeasureFlow_OLOAD_FR_LossRate(self.FlowList, self.TransmitTime)

                    #Get Latency & Jitter values
                    (latencyMin, latencyMax, latencyAvg) = WaveEngine.MeasurePort_Latency(DesCardList, self.TransmitTime)
                    (JitterMin, JitterMax, JitterAvg) = WaveEngine.MeasureFlow_Jitter(self.FlowList)                       
                    JitterText = "%ss" % (Float2EngNotation(float(JitterAvg/1000000.0), self.DisplayPrecision))
                    LatencyMinText = "%ss" % (Float2EngNotation(float(latencyMin), self.DisplayPrecision) )
                    LatencyMaxText = "%ss" % (Float2EngNotation(float(latencyMax), self.DisplayPrecision) )
                    LatencyAvgText = "%ss" % (Float2EngNotation(float(latencyAvg), self.DisplayPrecision) )
                    
                    self.TestResult= {}
                    
               #____________________________patch from TEL for PASS/FAIL criteria_______________________ 
               #The acceptable packet loss tolerance is specified as % of packet loss accepted.
               #If any one case is failed the final result of the test is fail.
                    if self.UserPassFailCriteria['user']=="True":
                       #if self.UserPassFailCriteria['ref_fwd_mode']=="percentage":
                       #  FRuser = (float(self.UserPassFailCriteria['ref_forwardingrate']) * TheoreticalMFR)/100
                       #  if FRuser <= FR:
                       #     WaveEngine.OutputstreamHDL("\nAchieved Fwd Rate specified by the User:%s Got: %s \n  "%(FRuser,FR), WaveEngine.MSG_SUCCESS)
                       #     self.TestResult['FR']='PASS'
                       #  else:
                       #     WaveEngine.OutputstreamHDL("Failed to achieve Forwarding rate mentioned by the User:%s Got:%s\n"%(FRuser,FR),WaveEngine.MSG_WARNING)
                       #     self.TestResult['FR']='FAIL'
                       #else:
                       #  temp= self.FrameSizeList.index(FrameSize) 
                       #  if self.UserPassFailCriteria['ref_forwardingrate'][temp] <= FR:
                       #     WaveEngine.OutputstreamHDL("Achieved the  Fwd Rate mentioned by the User\n",
                       #     WaveEngine.MSG_SUCCESS)
                       #     self.TestResult['FR']='PASS'
                       #  else:
                       #     WaveEngine.OutputstreamHDL("Iteration has failed to achieve Forwarding rate mentioned by\
                       #     the User\n",WaveEngine.MSG_WARNING)
                       #     self.TestResult['FR']='FAIL'

                       if FrameLossRate <= float(self.UserPassFailCriteria['ref_tolerance']):
                            WaveEngine.OutputstreamHDL("\nAchieved the Loss Tolerance mentioned by the User: %s   Got: %s\n"%(self.UserPassFailCriteria['ref_tolerance'],FrameLossRate),WaveEngine.MSG_SUCCESS)
                            self.TestResult['LT']='PASS'
                       else:
                            WaveEngine.OutputstreamHDL("\nFailed to achieve the Loss tolerance mentioned by the User:%s  Got: %s\n"%(self.UserPassFailCriteria['ref_tolerance'],FrameLossRate),WaveEngine.MSG_WARNING)
                            self.TestResult['LT']='FAIL'
                       if self.TestResult['LT']=='FAIL' :
                            self.FinalResult = 3
                       						
        #___________________________________TEL_________________________________________________ 
                       self.ResultsForCSVfile.append( (FrameSize, FrameRate, TrialNumber, 
                                                    int(TheoreticalMFR), int(TheoreticalMFR * 8 * FrameSize), 
                                                    OLOAD, FR, FR * FrameSize * 8, FrameLossRate,self.TestResult['LT'],
                                                    LatencyMinText, LatencyMaxText, LatencyAvgText, 
                                                    JitterText) )
                    else:
                        self.ResultsForCSVfile.append( (FrameSize, FrameRate, TrialNumber,
                                                    int(TheoreticalMFR), int(TheoreticalMFR * 8 * FrameSize),
                                                    OLOAD, FR, FR * FrameSize * 8, FrameLossRate,
                                                    LatencyMinText, LatencyMaxText, LatencyAvgText,
                                                    JitterText) ) 
                     # CHB add collection of latency data. 
                    TotalRXL3 = 0
                    for Flowname in self.FlowList.keys():
                        (src_port, src_client, des_port, des_client) = self.FlowList[Flowname]
                        WaveEngine.VCLtest("flowStats.read('%s','%s')" % (des_port, Flowname))
                        TotalRXL3 += flowStats.rxFlowIpOctetsOk 
                    self.ResultsForCSVSpecialfile.append( (FrameSize, 
                                                           TrialNumber, 
                                                           FrameRate, 
                                                           OLOAD * self.TransmitTime, 
                                                           FR * self.TransmitTime, 
                                                           (OLOAD - FR) * self.TransmitTime, 
                                                           latencyMin, latencyMax, 
                                                           latencyAvg, OLOAD, 
                                                           OLOAD_bps, FR, 
                                                           float(8 * TotalRXL3 / self.TransmitTime), 
                                                           FR_bps ) )
                    WaveEngine.OutputstreamHDL("Completed: Forwarding rate for %d byte frames is %.1f (or %s bits/sec)\n" % (FrameSize, FR, Float2EngNotation((FR * FrameSize * 8), self.DisplayPrecision)), WaveEngine.MSG_SUCCESS)
                    if FrameLossRate == 0.0:
                        WaveEngine.OutputstreamHDL("Completed: Frame Loss Rate is zero\n", WaveEngine.MSG_SUCCESS)
                    else:
                        WaveEngine.OutputstreamHDL("Completed: Frame Loss Rate is %.2f%%\n" % (FrameLossRate), WaveEngine.MSG_SUCCESS)

                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
                    WaveEngine.CheckEthLinkWifiClientState(self.CardList, self.ListOfClients)
    
    def PrintReport(self):
        import os.path
        #Strip off the DUT info
        Results  = []
        if self.UserPassFailCriteria['user']=="True": 
             len_line =14
             line_end =10
        else:
            len_line =13
            line_end =9
        for line in self.ResultsForCSVfile:
            if len(line) == len_line:
                Results.append(line[0:line_end])
        # Text Paragraphs
        Overview = """The packet loss test measures the rate at which frames are dropped, as well as the rate at which they are forwarded, by the system under test (SUT) when presented with specific traffic loads and frame sizes. """
        
        Overview2 = """The results of this test are principally useful for characterizing the SUT behavior over a wide range of traffic, rather than for obtaining a single performance number. The test can be run using frame size and intended load sweeps to fully exercise the SUT with all combinations of traffic loads."""
        
        FL_text1 = """The following graph(s) show the percentage of frames that were dropped by the SUT for the specific combination(s) of intended load (ILOAD) in frames/sec and frame size in bytes. The values are averaged over all the trials."""
        
        FL_text2 = """Ideally, no frames should be lost until the ILOAD exceeds the theoretical maximum. The relationship between the ILOAD and the theoretical maximum is shown in the next section (forwarding rate graphs)."""
        
        FR_text1 = """The following graph(s) compares the ILOAD presented to the SUT, versus the rate at which the SUT was able to successfully forward the traffic. The dashed line indicates the theoretical maximum ILOAD, as determined by the physical media. All traffic values are in frames/sec for specific frame sizes in bytes. The values are averaged over all the trial(s)."""
        
        FR_text2 = """Ideally, the forwarding rate should equal the ILOAD whenever the latter is less than or equal to the theoretical maximum. NOTE: For 11n clients the theoretical maximum assumes the Best Effort AC, AIFSn of 2, and ECWMin of 4."""
        
        Topology = """The test topology is shown below. Traffic is transmitted in the direction of the arrows. The test client port identifiers and IP addresses are indicated in the boxes, together with the security mode and channel ID for WLAN clients."""
        
        Method1 = """The test is performed by associating test clients with the SUT ports, performing any desired learning transmissions, and then generating unidirectional test traffic between the test clients. The test then calculates frame loss rate as defined in RFC 2544, and forwarding rate according to RFC 2285. Proprietary signatures and tags are inserted into the test traffic to ensure accurate measurement results."""
        
        Method2 = """The test is repeated for each combination of test conditions (i.e., frame size and ILOAD), and the required number of trials. The results are recorded separately for each trial, as well as being averaged into the graphs shown above."""
        
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title( "Unicast Packet Loss Report", self.DUTinfo )
        MyReport.InsertHeader( "Overview" )
        MyReport.InsertParagraph( Overview )
        MyReport.InsertParagraph( Overview2 )
        MyReport.InsertHeader( "Frame Loss Rate" )
        MyReport.InsertParagraph( FL_text1 )
        MyReport.InsertParagraph( FL_text2 )
	## when the results are more take care of the graphs
        thresholdforplots=15
        if len(self.FrameSizeList ) >= thresholdforplots:
                results_modified=[]
                iload_modified=[]
                sample_interval=len(self.FrameSizeList )/thresholdforplots
                for i in range (0,len(self.FrameSizeList ),sample_interval+1):
                    results_modified=results_modified+[Results[i+1]]
                    ## Add the iload to ilaod list#index 1
                    iload_modified=iload_modified+ [Results[i+1][1]]
        if len(self.FrameSizeList ) < thresholdforplots:
               for eachILOAD in self.ILOADlist:
                   MyReport.InsertObject( self.CreateFrameLossRateGraph( eachILOAD, Results ) )
        else:
              for eachILOAD in iload_modified:
                   MyReport.InsertObject( self.CreateFrameLossRateGraph( eachILOAD, results_modified ) )
        MyReport.InsertHeader( "Forwarding Rate" )
        MyReport.InsertParagraph( FR_text1 )
        MyReport.InsertParagraph( FR_text2 )
        if self._anyUserSpecifiedTheoreticals():
            userSpecifedRatesText = "<i>At least one of the Medium Capacity values shown is user specified</i>"
            MyReport.InsertParagraph( userSpecifedRatesText )
            
        if len(self.FrameSizeList ) < thresholdforplots:
             for eachILOAD in self.ILOADlist:
                 MyReport.InsertObject( self.CreateForwardingRateGraph( eachILOAD, Results ) )
        else:
             for eachILOAD in iload_modified:
                 MyReport.InsertObject( self.CreateForwardingRateGraph( eachILOAD,results_modified ) )
        MyReport.InsertPageBreak()

        MyReport.InsertHeader( "Test Conditions" )
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Frame Sizes', str( self.FrameSizeList ), "Frame sizes in bytes" ),
                             ( 'ILOAD', str( self.ILOADlist ), "Traffic load, frames/sec" ) ]
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 1.25*inch, 3.0*inch, 1.75*inch ] ) # 6-inch total

        MyReport.InsertHeader( "Test Configuration" )
        ConfigParamters = [ ( 'Parameter', 'Value', 'Description'),
                            ( 'Learning Time', "%d sec" % ( self.FlowLearningTime ), "Transmission time (seconds) for initial learning packets, to allow the SUT to set up forwarding tables" ),
                            ( 'Transmit Time', "%d sec" % ( self.IntendedTransmitTime ), "Trial duration (seconds) - i.e., duration of test traffic" ),
                            ( 'Number of Trials', "%d" % ( self.Trials ), "Number of times measurements are repeated for averaging" ),
                            ( 'Settle Time', "%d sec" % (self.SettleTime), 'Idle time after test traffic transmission completes' ) ]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ('Client Contention', 'ON', 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
        MyReport.InsertParameterTable(ConfigParamters, columns=[2*inch, 0.75*inch, 3.25*inch])
        
        MyReport.InsertHeader( "Test Topology" )
        MyReport.InsertParagraph( Topology )
        MyReport.InsertClientMap( self.SourceClients, self.DestClients, self.BiDirectional, self.CardMap )
        # count ports used in client lists
        portlist = []
        for eachClient in self.SourceClients + self.DestClients:
            port = eachClient[ 1 ] # extract portname from client tuple
            if port not in portlist:
                portlist.append( port )
        numPorts = len( portlist )
        MyReport.InsertParagraph( "A total of %d ports were used in this test." % numPorts )
        #MyReport.InsertPageBreak()

        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        allClientList = self.SourceClients + self.DestClients
        allClientList.sort()
        for eachClient in allClientList:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject
            
            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )

        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])
        
        MyReport.InsertHeader( "Methodology" )
        MyReport.InsertParagraph( Method1 )
        MyReport.InsertParagraph( Method2 )
        MyReport.InsertPageBreak()
        #___________________________________TEL_________________________________________________ 
        if self.UserPassFailCriteria['user']=="True":
           MyReport.InsertHeader( "Detailed Results" )
           MyReport.InsertDetailedTable( Results, columns = [ 0.5*inch,
                                                           0.6*inch,
                                                           0.4*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch, 
                                                           0.75*inch ] )
           ################## Patch For incorporatingh P/F criteria#########################
           NoteText=""" Note: Abbreviations used: USC-User Spefied Criteria and and LT-Loss Tolerance """
           MyReport.InsertParagraph(NoteText)
           ConfigParamters=[]
           fail_count_lt =0
           #fail_count_fr =0
           iteration_count=-1
           for temper in Results:
              iteration_count=iteration_count+1
              if temper[-1]== 'FAIL':
                 fail_count_lt=fail_count_lt+1
              else:
                 pass
              #if temper[-2]== 'FAIL':
              #   fail_count_fr=fail_count_fr+1
              #else:
              #   pass
           #print " the fail stats are %f and %f" %(fail_count_lt,fail_count_fr)
           #per_lt_pass= (float(iteration_count - fail_count_lt)/iteration_count)* 100
           #per_fr_pass= (float(iteration_count - fail_count_fr)/iteration_count)* 100
           MyReport.InsertHeader("User specified P/F criteria" )
           userspecifiedtext= """  With this feature user can decide the criteria for pass or fail of the test.User can configure the loss tolerance allowed
 based on which the test is evaluated to Pass/Fail"""
           MyReport.InsertParagraph (userspecifiedtext)
           ConfigParamters = [ ( 'Parameter', 'User defined Value','Overall Result'),
                            ( 'Loss Tolerance', "%d " %int(self.UserPassFailCriteria['ref_tolerance']) ,
 "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,(iteration_count-fail_count_lt),fail_count_lt))]
           #print "The config paramters going into the PDF are %s"%ConfigParamters
           MyReport.InsertParameterTable(ConfigParamters, columns = [1.25*inch, 1.5*inch, 1.75*inch ])
        else:
          MyReport.InsertHeader( "Detailed Results" )
          MyReport.InsertDetailedTable( Results, columns = [ 0.5*inch,
                                                           0.6*inch,
                                                           0.4*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch,
                                                           0.75*inch])
        #___________________________________TEL_________________________________________________ 
 
  
        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename ,
                               reportObject = MyReport)

        # other info section
        MyReport.InsertHeader( "Other Info" )
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        MyReport.Print()
        
    # CHB - add function for special Results
    def SaveSpecialResults(self):
        import os.path
        #Save the results to a file
        WaveEngine.CreateCSVFile(os.path.join(self.LoggingDirectory, self.CSVSpecialfilename), self.ResultsForCSVSpecialfile)

    def run(self):
        # For debuging the reports
        #self.LoggingDirectory = "/home/keith/Veriwave/WaveApps/Results/20060324-110245"
        #self.ReadResults()
        #self.PrintReport() 
        #return
        
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            # CHB init the special file
            self.ResultsForCSVSpecialfile = []
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, 
#                                 self.ClientLearningTime, 
#                                 self.ClientLearningRate)
            self.configureFlows()
            self.setQoShandshakeFlag()
            if self.biFlow:
                self._connectBiFlows()
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            # CHB Add Special CSV file
            if self.enableCustomCSV == True:
                self.SaveSpecialResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus = self.FinalResult 
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.SaveResults()
            self.ExitStatus = 2
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """
        Method = """The Packet Loss Benchmarking test allows you to present the system under test (SUT) with an intended load (ILOAD) and measure the response in terms of forwarding rate and loss packets. If you have multiple clients, the ILOAD is divided evenly between the clients sourcing traffic into the SUT. You can specify a variety of ILOAD conditions and the test will produce the measured results for each ILOAD.

Forwarding rate is measured by counting the number of packets that have been successfully received at the destination port(s) over the course of the test. Packet loss is calculated by taking the difference between the offered packets and the received packets."""
        return Method
    
    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        { 'Frame Loss [ILOAD=100]': <obj>,
          'Frame Loss [ILOAD=200]': <obj>,
          'Latency [framesize=100, ILOAD=100]': <obj>,
          <chart title>, <chart object> }
        """
        
        # code from Jerry to strip off irrelevant headings
        results = []
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                results.append(line[0:9])
            if len(line) == 0:
                flag = True
        # create charts
        charts = {}
        for iload in self.ILOADlist:
            c = self.CreateForwardingRateGraph( iload, results )
            t = c.title
            charts[ t ] = c
        for iload in self.ILOADlist:
            c = self.CreateFrameLossRateGraph( iload, results )
            t = c.title
            charts[ t ] = c
        
        return charts

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateForwardingRateGraph(self, DesiredFrameRate, ResultData):
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.0 * inch

        #Extract the data from the CSV file
        _ExtractedData= {}
        for eachLine in ResultData:
            eachLine=eachLine[:9]
            if len(eachLine) !=9 :
                continue
            (FrameSize, FrameRate, TrialNumber, Theroy_FPS, Theroy_BPS, OLOAD_FPS, FR_FPS, FR_BPS, FrameLossRate) = eachLine
            if not isnum(FrameSize):
                continue
            if float(DesiredFrameRate) != float(FrameRate):
                continue
            if _ExtractedData.has_key(int(FrameSize)):
                (m,n, TotalOLOAD_FPS, TotalOLOAD_BPS, TotalFR_FPS, TotalFR_BPS, Count) = _ExtractedData[int(FrameSize)]
                _ExtractedData[int(FrameSize)] = (Theroy_FPS, Theroy_BPS, TotalOLOAD_FPS + OLOAD_FPS, TotalOLOAD_BPS + (OLOAD_FPS * 8 * FrameSize), TotalFR_FPS + FR_FPS, TotalFR_BPS + FR_BPS, Count + 1)
            else:
                 _ExtractedData[int(FrameSize)] = (Theroy_FPS, Theroy_BPS, OLOAD_FPS, (OLOAD_FPS * 8 * FrameSize), FR_FPS, FR_BPS, 1)
        FrameSizeList = _ExtractedData.keys()
        FrameSizeList.sort()
       
        graphTitle = "Forwarding Rate with %.1f pkts/sec offered" % (float(DesiredFrameRate))
        FrameSizeData1 = ()
        FrameSizeData2 = ()
        FrameSizeTheory = ()
        FrameSizeName = []
        if len(_ExtractedData) > 0:
            for eachFrameSize in FrameSizeList:
                (Theroy_FPS, Theroy_BPS, TotalOLOAD_FPS, TotalOLOAD_BPS, TotalFR_FPS, TotalFR_BPS, Count) = _ExtractedData[eachFrameSize]
#                Theroy_Mbps = Theroy_BPS / 1000000.0
#                OLOAD_Mbps  = TotalOLOAD_BPS  / (int(Count) * 1000000.0)
#                FR_Mbps     = TotalFR_BPS  / (int(Count) * 1000000.0)
                OLOAD_FPS  = TotalOLOAD_FPS  / int(Count)
                FR_FPS     = TotalFR_FPS  / int(Count)
#                FrameSizeData1   += (OLOAD_Mbps, )
#                FrameSizeData2   += (FR_Mbps, )
#                FrameSizeTheory += (Theroy_Mbps, )
                FrameSizeData1   += (OLOAD_FPS, )
                FrameSizeData2   += (FR_FPS, )
                FrameSizeTheory += (Theroy_FPS, )
                FrameSizeName.append(str(eachFrameSize))

        return self.ForwardingRateGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeTheory, ], [FrameSizeData1, FrameSizeData2], graphTitle)

    def CreateFrameLossRateGraph(self, DesiredFrameRate, ResultData):
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.0 * inch

        #Extract the data from the CSV file
        _ExtractedData= {}
        for eachLine in ResultData:
            eachLine=eachLine[:9] 
            if len(eachLine) != 9:
                continue
            (FrameSize, FrameRate, TrialNumber, Theroy_FPS, Theroy_BPS, OLOAD_FPS, FR_FPS, FR_BPS, FrameLossRate) = eachLine
            if not isnum(FrameSize):
                continue
            if float(DesiredFrameRate) != float(FrameRate):
                continue
            if _ExtractedData.has_key(int(FrameSize)):
                (m,n, TotalLossRate, Count) = _ExtractedData[int(FrameSize)]
                _ExtractedData[int(FrameSize)] = (Theroy_FPS, Theroy_BPS, TotalLossRate + float(FrameLossRate), Count + 1)
            else:
                 _ExtractedData[int(FrameSize)] = (float(Theroy_FPS), float(Theroy_BPS), float(FrameLossRate), 1)
        FrameSizeList = _ExtractedData.keys()
        FrameSizeList.sort()
       
        graphTitle = "Frame Loss Rate with %.1f pkts/sec offered" % (float(DesiredFrameRate))
        
        FrameSizeData1 = ()
        FrameSizeName = []
        for eachFrameSize in FrameSizeList:
            (Theroy_FPS, Theroy_BPS, TotalLossRate, Count) = _ExtractedData[eachFrameSize]
            FrameLoss  = TotalLossRate  / int(Count)
            # VPR 4180 - clamp negative values
            if FrameLoss < 0.0:
                FrameLoss = 0.0
            FrameSizeData1   += (FrameLoss, )
            FrameSizeName.append(str(eachFrameSize))
        return self.FrameLossRateGraph(GraphWidth, GraphHeight, FrameSizeName, [], [FrameSizeData1], graphTitle)

    class ForwardingRateGraph(FlowableGraph):
        """
        Forwarding Rate Graph
        """
        def __init__(self, width, height, names, line, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataLine  = line
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataLine, self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str("%.1f FPS" % eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
                
            # Bar chart of measured data
            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis - 20 # padding for legend
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                # add valid data to chart
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # add value labels above bars
                bc.barLabelFormat = "%.2f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # add message informing user there is no valid data
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            
            # veriwave colors
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            # set axis ranges
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
#            bc.valueAxis.labelTextFormat = "%.1f Mbps"
            bc.valueAxis.labelTextFormat = "%.1f FPS"
            # set axis labels
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            # add bar chart
            self.drawing.add(bc)

            #Put the labels on the center of the graph
            self._drawLabels(self.title, "Frame Size", "")

            # Add Legend in upper left corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height + 3 * legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'Offered Load', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[1].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'Forwarding Rate', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight

            # theoretical line chart
            if self.validData and len(self.dataLine[0]) > 0:
                # if one datapoint, draw horizontal line across chart
                DashArray = [2,2]
                if len(self.dataLine[0]) == 1:
                    yPos = bc.height * (self.dataLine[0][0] - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
                    self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.blue, strokeWidth=1, strokeDashArray = DashArray))
                # theoretical line
                lc = HorizontalLineChart()    
                lc.x = bc.x
                lc.y = bc.y
                lc.height = bc.height
                lc.width  = bc.width
                # line axis values
                lc.valueAxis.valueMin  = self.valueMin
                lc.valueAxis.valueMax  = self.valueMax
                lc.valueAxis.valueStep = self.valueStep
                lc.valueAxis.visible   = False
                lc.data = self.dataLine
                # line formatting
                lc.lines[0].strokeColor = colors.blue
                lc.lines[0].strokeDashArray = DashArray
                lc.lines[0].symbol = makeMarker('FilledDiamond')
                lc.joinedLines = 1
                self.drawing.add(lc)
                # add legend
                self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=colors.blue, strokeWidth=1, strokeDashArray=DashArray))
                self.drawing.add(String(legendX + 22, legendY, 'Medium Capacity', fontName='Helvetica', fontSize=8))
                legendY -= legendHeight
            # all done

    class FrameLossRateGraph(FlowableGraph):
        def __init__(self, width, height, names, line, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataLine  = line
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart 

            self._setScale([self.dataLine, self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth("%.3f%%" % (eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis - 20 # padding for legend
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                # add valid data to chart
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # add value labels above bars
                bc.barLabelFormat = "%.2f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                bc.data = [ (0,), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            # format chart
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            # axis values
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            # axis formatting
            if self.valueStep >= 10.0:
                bc.valueAxis.labelTextFormat = "%.0f%%"
            elif self.valueStep >= 1.0:
                bc.valueAxis.labelTextFormat = "%.1f%%"
            elif self.valueStep >= 0.1:
                bc.valueAxis.labelTextFormat = "%.2f%%"
            else:
                bc.valueAxis.labelTextFormat = "%.3f%%"
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0

            self._drawLabels(self.title, "Frame Size", "Percent Loss")

            # What if all loss is Zero
            if self.valueMin == 0.0 and self.valueMax == self.valueStep and self.validData:
                bc.valueAxis.labelTextFormat = "%.3f%%"
                Label_Zero = Label()
                Label_Zero.fontSize = 12
                Label_Zero.angle = 0
                Label_Zero.dx = self.graphCenterX
                Label_Zero.dy = self.graphCenterY
                Label_Zero.boxAnchor = 'c'
                Label_Zero.setText("ALL DATA IS ZERO")
                self.drawing.add(Label_Zero)
            self.drawing.add(bc)
            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height + legendHeight

            if len(self.dataLine) > 0 and self.validData:
                # if one datapoint, draw horizontal line across chart
                DashArray = [2,2]
                if len(self.dataLine[0]) == 1:
                    yPos = bc.height * (self.dataLine[0][0] - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
                    self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.blue, strokeWidth=1, strokeDashArray = DashArray))
                # theoretical line                           
                lc = HorizontalLineChart()    
                lc.x = bc.x
                lc.y = bc.y
                lc.height = bc.height
                lc.width  = bc.width
                # axis values
                lc.valueAxis.valueMin  = self.valueMin
                lc.valueAxis.valueMax  = self.valueMax
                lc.valueAxis.valueStep = self.valueStep
                lc.valueAxis.visible   = False
                lc.data = self.dataLine
                # dashed line with diamond markers
                lc.lines[0].strokeDashArray = [2,2]
                lc.lines[0].symbol = makeMarker('FilledDiamond')
                lc.joinedLines = 1
                self.drawing.add(lc)
                self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=lc.lines[0].strokeColor, strokeWidth=1, strokeDashArray = lc.lines[0].strokeDashArray))
                self.drawing.add(String(legendX + 22, legendY, 'Theory', fontName='Helvetica', fontSize=8))
                legendY -= legendHeight
            # all done
            
                
##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    parser.add_option("--dbsupport",
                    dest="dbsupport", action="store_true", default=False,
                    help="save Results to the database")
    parser.add_option("--pf",
                    dest="passfail", action="store_true", default=False,
                    help="user pass/fail criteria enable/disable")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    if options.dbsupport:
        userTest.DbSupport = True
    if options.passfail:
        userTest.UserPassFailCriteria['user'] = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
