#unicast_max_forwarding_rate
#
# Objective: Find the maximum rate the DUT can forward frames through
#            an ineration search.  Try different RFC2544 packet sizes.
#
import sys, time, sched, traceback
import WaveEngine
from basetest import *
from optparse import OptionParser
from vcl import *
from CommonFunctions import *

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}
          
        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}

        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of '00:00:00:00:00:00'
                       tells the system to pick the first on on the list
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.10',  '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.100', '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        """
        self.FrameSizeList  = [ 128, 256, 1024 ]
        self.Trials         =  1  
        self.TransmitTime   =  5.0

        ##################  Goal Seeking parameters  ##############################
        """
        The goal seeking parameters are used to define how the goal seeking algorithm will arrive at a solution.
        SearchResolutionPercent - Determines how precise the search for the final result needs to be. For instance,
                                  a value of 0.1 means that the search will stop if the current result is within 0.1% 
                                  of the previous iteration result. 
        """
        self.SearchResolutionPercent = 0.1

        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the test details. This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_unicast_max_forwarding_rate.csv'
        self.ReportFilename   = 'Report_unicast_max_forwarding_rate.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_unicast_max_forwarding_rate.csv'
        self.RSSIFilename    = 'RSSI_unicast_max_forwarding_rate.csv'
        
        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at teh configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 2
        self.FlowLearningRate   = 100
        self.ResultsforDb=[]
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.FinalResult=0  

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
         """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  10.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =   0.25
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        """
        self.FlowOptions    = {'Type': 'UDP', 'PhyRate': 54 }


########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.51 $' 
        self.date    = '$Date: 2007/07/05 23:14:35 $' 

        #Does not make sense to run this test bi-directional since we are the maximum rate in one direction
        self.BiDirectional  = False

        self.FlowMap        = WaveEngine.CreateFlows_Pairs
        # These parameters control the search algorthim.
        self.SearchInitailSlice      = 5
        self.SearchIterations        = 6 
        self.SearchHighListLength    = 3
    
    def getTestName(self):
        
        return 'unicast_max_forwarding_rate'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        
        #These are the test specific parameters that get passed down from the GUI for the test execution
        self.SearchResolutionPercent = float(waveTestSpecificStore['unicast_max_forwarding_rate']['SearchResolution'])
        frameSizeList = []
        frameSizeList = waveTestSpecificStore['unicast_max_forwarding_rate']['FrameSizeList']
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
                
        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
            if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
            if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
                if waveTestSpecificStore['unicast_max_forwarding_rate']['AcceptableForwardingRate']:
                    if float (waveTestSpecificStore['unicast_max_forwarding_rate']['AcceptableForwardingRate']) >=0: 
                        self.UserPassFailCriteria['ref_max_forward_rate']=float(waveTestSpecificStore['unicast_max_forwarding_rate']['AcceptableForwardingRate'])
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableForwardingRate should be a positive number\n",WaveEngine.MSG_ERROR)
                        raise  WaveEngine.RaiseException
                else:
                    #WaveEngine.OutputstreamHDL("\nUser has not given the value for <AcceptableForwardingRate> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                    self.UserPassFailCriteria['ref_max_forward_rate']=90
                if waveTestSpecificStore['unicast_max_forwarding_rate']['ForwardingRateMode']:
                    if str(waveTestSpecificStore['unicast_max_forwarding_rate']['ForwardingRateMode'])== ("Percentage" or "Specify"):
                        self.UserPassFailCriteria['ref_max_forward_rate_mode']=str(waveTestSpecificStore['unicast_max_forwarding_rate']['ForwardingRateMode'])
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter ForwardingRateMode should be either Percentgae/Specify\n",WaveEngine.MSG_ERROR)
                        raise  WaveEngine.RaiseException
                else:
                    #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ForwardingRateMode> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                    self.UserPassFailCriteria['ref_max_forward_rate_mode']="Percentage" 
        #___________________________________TEL_________________________________________________


        # all good
        return True

        
    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters):
        Completed = PassedParameters['Queue']
        CounterObject =  PassedParameters['Counters']
        (TotalTX, TotalRX) = CounterObject.Query()
        ILOADtext = Float2EngNotation(float(PassedParameters['ILOAD']) , self.DisplayPrecision)
        OLOADtext = Float2EngNotation(TotalTX , self.DisplayPrecision)
        FRtext    = Float2EngNotation(TotalRX , self.DisplayPrecision)
        WaveEngine.OutputstreamHDL("\rFrameSize: %s ILOAD=%spkt/sec, OLOAD=%spkt/sec, FR=%spkt/sec, (%.f%% Time:%.1f)" % (PassedParameters['FrameSize'], ILOADtext, OLOADtext, FRtext, Completed, Timeleft), WaveEngine.MSG_OK)
        return True

    def FastTransmitIteration(self, TXtime, RXtime, CounterObject, UpdateTime, GroupName, UpdateFunction, PassedParameters):
        PassedParameters['Counters'] = CounterObject
        scheduler = sched.scheduler(time.time, time.sleep)

        #               delay, priority,  action, arguments
        scheduler.enter(    0,        1, WaveEngine.startFlowAndNoteTime, (GroupName,) )
    
        # Sample counters starting 1.5 secs after start of TX
        for n in range(int((TXtime-1.5) * 2.0) + 1):
            scheduler.enter(1.5 + n * 0.5,       2, CounterObject.Sample, ())

        #Update the display
        for n in range(int((TXtime + RXtime) / UpdateTime)):
            ElapsedTime = UpdateTime * (n+1)
            Timeleft    = (TXtime + RXtime) - ElapsedTime
            Transmitting_Flag = 'TX'
            if ElapsedTime > TXtime:
                Transmitting_Flag = 'RX'
            # Do not call the realtime stats when its close to stopping the flows
            if TXtime - ElapsedTime > UpdateTime or ElapsedTime > TXtime:
                scheduler.enter(ElapsedTime,     100, UpdateFunction, (Transmitting_Flag, Timeleft, ElapsedTime, PassedParameters))

        #Stop the test
        scheduler.enter(TXtime,     3, WaveEngine.stopFlowAndNoteTime, (GroupName,))
        scheduler.enter(TXtime + RXtime, 100, UpdateFunction, (Transmitting_Flag, 0.0, TXtime + RXtime, PassedParameters))

        #Run the Iteration
        scheduler.run()
        
        return WaveEngine.getLatestFlowTime(GroupName)
    
    def startTest(self, FuncRealTime):
        self.ResultsForCSVfile.append(('Frame Size', 'Trial', 'Theoretical pkts/sec', 'Theoretical bits/sec','ILOAD pkts/sec', 'OLOAD pkts/sec', 'Forwarding Rate pkts/sec', 'Forwarding Rate bits/sec') )
        if  self.UserPassFailCriteria['user']=="True":
            self.ResultsforDb=self.ResultsforDb+[("FrameSize","Trial","MediumCapacity","ILOAD","OLOAD","FR","USC:FR")] 
        else:
            self.ResultsforDb=self.ResultsforDb+[("FrameSize","Trial","MediumCapacity","ILOAD","OLOAD","FR")] 
        MeasurementQueue = []
        sort = Sorter()
        calcTheoFrdRate = self.getMediumCapacityCalculator()
        PassedParam = {'FrameSize': 'Learning', 
                       'ILOAD': self.FlowLearningRate * float(len(self.FlowList)), 
                       'CardList': self.CardList, 
                       'Type': self.FlowOptions['Type'], 
                       'Queue': 1}
        PassedParam['Counters'] =  SampleOLOAD_FR(self.CardList, 
                                                  self.FlowLearningRate * float(len(self.FlowList)), 
                                                  self.FlowOptions['Type'])
        self._doFlowLearning(FuncRealTime, PassedParam)
        
        for eachSize in self.FrameSizeList:
            FrameSize = int(eachSize)
            TheoreticalMFR = calcTheoFrdRate(FrameSize)
            TheoreticalBPS = 8 * FrameSize * TheoreticalMFR
            #TheoreticalMFR, TheoreticalBPS = self._getTheoretRatesBasedOnWEcalc(FrameSize)        
            MaxPerFlowRate =  1.25 * TheoreticalMFR / float(len(self.FlowList))
            for TrialNumber in range(1, 1 + self.Trials):
                WaveEngine.WriteDetailedLog(['Frame Size', FrameSize, 'Trial', TrialNumber])
                for x in range(self.SearchInitailSlice):
                    MeasurementQueue.append((self.SearchInitailSlice - x ) * (MaxPerFlowRate / float(self.SearchInitailSlice)) )
                ResultList = [(0,0,0)]
                SearchCount = int(self.SearchIterations)
                percentSliceMajor = 100.0 / float(SearchCount)
                QueueSize = len(MeasurementQueue)
                percentSliceMinor = percentSliceMajor / float(QueueSize)
                ResolutionPktPerSec = MaxPerFlowRate * float(self.SearchResolutionPercent) / 100.0 

                #Run the fast search algorithm
                while len(MeasurementQueue) > 0:
                    ILOAD = MeasurementQueue.pop()
                    self._applyFlowRate({'AggregateFlowRate':ILOAD}, FrameSize)
                    self.writeRSSIinfo()
                    percentCompeleted = percentSliceMajor * (int(self.SearchIterations) - SearchCount) + percentSliceMinor * (QueueSize - len(MeasurementQueue))
                    PassedParam = { 'FrameSize': FrameSize, 'ILOAD': ILOAD * float(len(self.FlowList)), 'CardList': self.CardList, 'Type': self.FlowOptions['Type'], 'Queue': percentCompeleted}
                    IterationCounters = SampleOLOAD_FR(self.CardList, ILOAD * float(len(self.FlowList)), self.FlowOptions['Type'])
                    retVal = self.FastTransmitIteration(self.TransmitTime, self.SettleTime, IterationCounters, self.UpdateInterval, "XmitGroup", FuncRealTime, PassedParam )
                    if retVal:
                        self.TransmitTime = retVal
                    (OLOAD, FR) = IterationCounters.Query()
                    ResultList.append( (ILOAD, OLOAD, FR) )

                    if len(MeasurementQueue) == 0:
                        sort(ResultList, 2) # Sort by FR
                        MaxPoint = ResultList[-1]
                        Highest  = ResultList[-self.SearchHighListLength:]
                        sort(ResultList, 0)   #Sort by ILOAD
                        sort(Highest, 0) #Sort by ILOAD
                        ILOADlow  = Highest[0][0]
                        ILOADhigh = Highest[-1][0]
                        WaveEngine.OutputstreamHDL("\n\nHighest %s" % (Highest), WaveEngine.MSG_DEBUG)
                        SearchCount -= 1
                        if ILOADhigh - ILOADlow > ResolutionPktPerSec and SearchCount > 0:
                            sMessage = "\n"
                            LastValue = 0
                            for (ILOAD, OLOAD, FR) in ResultList:
                                WaveEngine.OutputstreamHDL(sMessage, WaveEngine.MSG_DEBUG)
                                sMessage = "\nILOAD=%9.1f OLOAD=%9.1f FR=%9.1f " % (ILOAD, OLOAD, FR)
                                if ILOAD == ILOADlow:
                                    sMessage += " <=== Low "
                                    LastValue = ILOAD
                                if ILOAD == ILOADhigh:
                                    sMessage += " <=== High"
                                if ILOAD <= ILOADlow:
                                    continue
                                if ILOAD > ILOADhigh:
                                    #break
                                    continue
                                Midpoint = ( ILOAD + LastValue) / 2
                                MeasurementQueue.append(Midpoint)
#                                sMessage += " LastValue= %9.1f Midpoint= %9.1f" % (LastValue, Midpoint)
                                LastValue = ILOAD
                            sMessage += "\n"    
                            WaveEngine.OutputstreamHDL(sMessage, WaveEngine.MSG_DEBUG)
                            QueueSize = len(MeasurementQueue)
                            percentSliceMinor = percentSliceMajor / float(QueueSize)
                    # FIXME: remove the TCP settling time when we fix problem with 
                    #        back to back TCP connect-disconnect
                    if self.FlowOptions['Type'] == 'TCP':
                        # Wait for 2 seconds to make sure we get all the TCP packets
                        WaveEngine.Sleep(2, 'TCP settling time') 
                    # Certain DUT do not like the constant traffic
                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
                WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)

                #Sort by ILOAD    
                sort(ResultList, 0)
                for (ILOAD, OLOAD, FR) in ResultList:
                    self.ResultsForCSVfile.append( (FrameSize, TrialNumber, int(TheoreticalMFR), int(TheoreticalBPS), ILOAD*float(len(self.FlowList)), OLOAD, FR, FR * 8 * FrameSize) )
                (ILOAD, OLOAD, FR) = MaxPoint
                WaveEngine.OutputstreamHDL("Completed: Framesize:%d found the maximum Forwarding rate of %.1f pkts/sec at ILOAD=%.1f, OLOAD=%.1f\n" % (FrameSize, FR, ILOAD, OLOAD), WaveEngine.MSG_SUCCESS )


                MC=float(TheoreticalBPS)/1000000 ## in Mbps
                if  self.UserPassFailCriteria['user']=="True":
                    TestResult =''
                    user_fr=((float(self.UserPassFailCriteria['ref_max_forward_rate'])/100) * MC)
                    FR_Mbps=float(FR * 8* FrameSize)/1000000
                    if self.UserPassFailCriteria['ref_max_forward_rate_mode']== "Percentage":
                        if (user_fr > FR_Mbps):
                            WaveEngine.OutputstreamHDL("The criteria for forwarding rate given by the user is Failed: User-%s Achieved-%s"%(user_fr,FR_Mbps),WaveEngine.MSG_WARNING)
                            TestResult= TestResult+'FAIL'
                        else:
                            WaveEngine.OutputstreamHDL("The criteria for forwarding rate given by the user is met: User-%s Achieved-%s"%(user_fr,FR_Mbps),WaveEngine.MSG_SUCCESS)
                            TestResult= TestResult+'PASS'
                    elif self.UserPassFailCriteria['ref_max_forward_rate_mode']== "Specify" :
                        if  FR_Mbps > self.UserPassFailCriteria['ref_max_forward_rate'] :
                            WaveEngine.OutputstreamHDL("The criteria for forwarding rate given by the user is met; User-%s Achieved-%s"%(self.UserPassFailCriteria['ref_max_forward_rate'],FR_Mbps),WaveEngine.MSG_SUCCESS)
                            TestResult= TestResult+'PASS'
                        else:
                            WaveEngine.OutputstreamHDL("The criteria for forwarding rate given by the user is failed; User-%s Achieved-%s"%(self.UserPassFailCriteria['ref_max_forward_rate'],FR_Mbps),WaveEngine.MSG_WARNING)
                            TestResult= TestResult+'FAIL'
                    self.ResultsforDb=self.ResultsforDb+[(FrameSize,TrialNumber,MC,ILOAD,OLOAD,FR,TestResult)]
                else:
                    self.ResultsforDb=self.ResultsforDb+[(FrameSize,TrialNumber,MC,ILOAD,OLOAD,FR)]
                #print "The results going to DB are %s" %self.ResultsforDb
                WaveEngine.WriteDetailedLog(['',])
                WaveEngine.CheckEthLinkWifiClientState(self.CardList, self.ListOfClients)
    
    def PrintReport(self):
        import os.path
        #Strip off the DUT info
        Results = []
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                Results.append(line)
            if len(line) == 0:
                flag = True
        # Text Paragraphs
        Overview =  """The maximum forwarding rate test measures the highest rate at which the system under test (SUT) can transfer frames between its ports, regardless of loss; it measures the ultimate traffic handling capacity of the SUT. This test measures the maximum forwarding rate according to RFC 2285."""
        
        Overview2 = """It is useful to compare the maximum forwarding rate and the throughput measurements - a large difference between the two metrics indicates potential SUT datapath problems."""
        
        FrSizeDesc = """The following graph shows the measured maximum forwarding rate performance of the SUT, in Mbps at the destination port, for the specified frame size(s) in bytes. The aggregate theoretical maximum capacity of the links carrying traffic is also indicated."""
        
        FrSizeDesc2 = """Ideally, the maximum forwarding rate should be as close as possible to the theoretical capacity. Values higher than the theoretical capacity indicates that the SUT has aggressive medium access behavior. Values considerably lower than the theoretical capacity show performance bottlenecks in the SUT."""
        
        FwdProfileDesc = """The following graphs plot the measured forwarding rate actually achieved by the SUT, in Mbps, as a function of the traffic intended load (ILOAD) in frames/sec. Ideally, each graph should show a linear increase until the maximum forwarding rate is reached, at which point the graph should flatten out. However, this is not always the case; the SUT may achieve its maximum forwarding rate at less than the maximum possible ILOAD, in which case the graph will slope downwards or show peaks, rather than flattening out. These forwarding rate profile graphs are useful for understanding the behavior of the SUT forwarding datapath."""
        
        FwdProfileDesc2 = """The value at the extreme right of each graph is commonly known as the forwarding rate at maximum offered load (FRMOL, see RFC 2285). It indicates the forwarding rate at the point where every active SUT port is fully loaded."""
        
        Topology = """The test topology is shown below. Traffic is transmitted in the direction of the arrows. The test client port identifiers and IP addresses are indicated in the boxes, together with the security mode and channel ID for WLAN clients."""
        
        Method1 = """The test is performed by associating test clients with the SUT ports, generating frame traffic between them at various traffic loads, and measuring the rate at which traffic is forwarded through the SUT. A modified binary search algorithm is used to find the maximum forwarding rate. The binary search algorithm iterates until the forwarding rate has been measured to a granularity less than the user-specified search resolution."""
        
        Method2 = """If multiple frame sizes and trials are specified, the test is iterated over these frame sizes for the required number of trials, and the results are reported separately for each frame size and trial."""
        
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Maximum Forwarding Rate Report", self.DUTinfo, self.TestID)

        MyReport.InsertHeader( "Overview" )
        MyReport.InsertParagraph( Overview )
        MyReport.InsertParagraph( Overview2 )

        MyReport.InsertHeader( "Measured Rate" )
        MyReport.InsertParagraph( FrSizeDesc )
        
        if self._anyUserSpecifiedTheoreticals():
            userSpecifedRatesText = "<i>At least one of the Theoretical values shown is user specified</i>"
            MyReport.InsertParagraph( userSpecifedRatesText )
        if  self.UserPassFailCriteria['user']=="True":    
             MyReport.InsertObject( self.CreateFrameSizeVersusForwardingRateGraph( Results,
                                                         GraphWidth  = 5.5 * inch,
                                                         GraphHeight = 2.5 * inch ) )
        else:
             MyReport.InsertObject( self.CreateFrameSizeVersusForwardingRateGraph( Results,
                                                         GraphWidth  = 5.5 * inch,
                                                         GraphHeight = 2.5 * inch ) )

        MyReport.InsertParagraph( FrSizeDesc2 )

        MyReport.InsertHeader( "Forwarding Rate Profile" )
        MyReport.InsertParagraph( FwdProfileDesc )
        MyReport.InsertParagraph( FwdProfileDesc2 )
        for eachFrameSize in self.FrameSizeList:
            for TrialNumber in range( 1, 1 + self.Trials ):
                if  self.UserPassFailCriteria['user']=="True":
                       MyReport.InsertObject( self.CreateILOADVersusForwardingRateGraph( eachFrameSize,
                                                                                  TrialNumber,
                                                                                  Results,
                                                                                  GraphWidth  = 5.5 * inch,
                                                                                  GraphHeight = 2.5 * inch ) )
                else:
                      MyReport.InsertObject( self.CreateILOADVersusForwardingRateGraph( eachFrameSize,
                                                                                  TrialNumber,
                                                                                  Results,
                                                                                  GraphWidth  = 5.5 * inch,
                                                                                  GraphHeight = 2.5 * inch ) )

        MyReport.InsertPageBreak()

        MyReport.InsertHeader( "Test Conditions" )
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Frame Sizes', str( self.FrameSizeList ), "Frame sizes in bytes" ) ]
                             #( 'ILOAD', str( self.ILOADlist ), "Traffic load, frames/sec" ) ]
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 1.25*inch, 3.0*inch, 1.75*inch ] ) # 6-inch total

        MyReport.InsertHeader( "Test Configuration" )
        ConfigParamters = [ ( 'Parameter', 'Value', 'Description'),
                            ( 'Learning Time', 
                              "%.1f sec" % ( self.FlowLearningTime ), 
                              "Transmission time (seconds) for initial learning packets, to allow the SUT to set up forwarding tables" ),
                            ( 'Achieved Transmit Time', 
                              "%.2f sec" % ( self.TransmitTime ), 
                              "Trial duration (seconds) - i.e., duration of test traffic" ),
                            ('Settle Time', 
                             "%d secs" % (self.SettleTime), 
                             'The number of seconds to wait for the SUT to finish forwarding frames before making the final measurement'),
                            ('Aging Time', 
                             "%d secs" % (self.AgingTime), 
                             'The number of seconds the SUT needs to recover between each iteration (i.e., each frame size)'),
                            ( 'Number of Trials', 
                              "%d" % ( self.Trials ), 
                              "Number of times measurements are repeated for averaging" ),
                            ( 'Search Resolution', 
                              "%.2f%%" % (self.SearchResolutionPercent), 
                              "Granularity of measured values, in percent of theoretical maximum capacity" ) ]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ( 'Client Contention', 'ON', 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.' ), )
        MyReport.InsertParameterTable( ConfigParamters, columns = [ 2.0*inch,
                                                                    0.75*inch,
                                                                    3.25*inch ] )
        
        MyReport.InsertHeader( "Test Topology" )
        MyReport.InsertParagraph( Topology )
        MyReport.InsertClientMap( self.SourceClients, self.DestClients, self.BiDirectional, self.CardMap )
        # count ports used in client lists
        portlist = []
        for eachClient in self.SourceClients + self.DestClients:
            port = eachClient[ 1 ] # extract portname from client tuple
            if port not in portlist:
                portlist.append( port )
        numPorts = len( portlist )
        MyReport.InsertParagraph( "A total of %d ports were used in this test." % numPorts )
        #MyReport.InsertPageBreak()

        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        allClientList = self.SourceClients + self.DestClients
        allClientList.sort()
        for eachClient in allClientList:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject

            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )

        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])
        
        MyReport.InsertHeader( "Methodology" )
        MyReport.InsertParagraph( Method1 )
        MyReport.InsertParagraph( Method2 )
        MyReport.InsertPageBreak()
       
        MyReport.InsertHeader( "Detailed Results" )
        MyReport.InsertDetailedTable( Results, columns = [ 0.5*inch,
                                                           0.6*inch,
                                                           0.8*inch,
                                                           0.8*inch,
                                                           0.8*inch,
                                                           0.8*inch,
                                                           0.8*inch,
                                                           0.8*inch ] )


        if self.UserPassFailCriteria['user'] =="True":
           MyReport.InsertHeader( "Results Summary" )
           MyReport.InsertDetailedTable( self.ResultsforDb, columns = [ 1.0*inch,
                                                              1.0*inch,
                                                              1.0*inch,
                                                              1.0*inch,
                                                              1.0*inch,
                                                              1.0*inch ,
                                                              1.0*inch ] )
           NoteText=""" Note: Abbreviations used: USC-User Spefied Criteria,FR-Forwarding Rate """
           MyReport.InsertPageBreak()
           MyReport.InsertParagraph(NoteText)
           iteration_count=-1
           fail_count =0
           fail_perc  =0
           for each_tup in self.ResultsforDb:
               iteration_count=iteration_count+1
               for each_value in each_tup:
                   if each_value == 'FAIL':
                      fail_count=fail_count+1
           #fail_perc=float(fail_count/iteration_count)* 100
           MyReport.InsertHeader( "User Specified P/F criteria" )
           ConfigParameters = [ ( 'Parameter', 'User defined Value', 'Overall Result' ),
                              ( 'Forwarding Rate Mode',"%s" %self.UserPassFailCriteria['ref_max_forward_rate_mode'] , "NA" ),
                              ( 'AcceptableForwarding rate ', "%s" %self.UserPassFailCriteria['ref_max_forward_rate'], 
 "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,(iteration_count-fail_count),fail_count))]
           if fail_count != 0:
              self.FinalResult =3
           MyReport.InsertParameterTable( ConfigParameters, columns = [ 3.0*inch, 1.25*inch, 1.75*inch ] ) # 6-inch total
        #MyReport.InsertPageBreak()
        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename ,
                               reportObject = MyReport)
        
        # other info section
        MyReport.InsertHeader( "Other Information" )
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        MyReport.Print()

    def run(self):
        # For debuging Reports
        #self.LoggingDirectory = "/home/keith/Veriwave/WaveApps/Results/20060329-102259"
        #self.ReadResults()
        #self.PrintReport() 
        #return

        #Perform some basic parameter validation before starting the test
        if self.TransmitTime < 2.0:
            WaveEngine.OutputstreamHDL("Error: Transmit Time MUST be 2 seconds or greater\n" , WaveEngine.MSG_ERROR )
            return

        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, 
#                                 self.ClientLearningTime, 
#                                 self.ClientLearningRate)
            self.configureFlows()
            self.setQoShandshakeFlag()
            if self.biFlow:
                self._connectBiFlows()
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus=self.FinalResult 
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """
        msg = """The Max Forwarding Rate (MFR) Benchmarking test identifies the maximum rate at which the system under test (SUT) can forward packets, regardless of loss. The test determines the MFR by using a modified binary Search algorithm."""
        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        
        # strip off irrelevant headings
        results = []
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                results.append(line)
            if len(line) == 0:
                flag = True
        # create charts
        charts = {}
        for eachFrameSize in self.FrameSizeList:
            for TrialNumber in range(1, 1 + self.Trials):
                c = self.CreateILOADVersusForwardingRateGraph(eachFrameSize, TrialNumber, results)
                t = c.title
                charts[ t ] = c
        c = self.CreateFrameSizeVersusForwardingRateGraph( results )
        t = c.title
        charts[ t ] = c
        
        return charts

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateFrameSizeVersusForwardingRateGraph(self, ResultData, GraphWidth = None, GraphHeight = None ):
        if not GraphWidth: GraphWidth  = 6.0 * inch
        if not GraphHeight: GraphHeight = 3.5 * inch

        #Extract the data from the CSV file
        _ExtractedData= {}
        for (line) in ResultData:
            if len(line) == 0:
              break
            (FrameSize, TrialNumber, Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, FR_FPS, FR_BPS) = line
            if not isnum(FrameSize):
                continue
            if _ExtractedData.has_key(int(FrameSize)):
                (m,n, ILOAD, OLOAD, MaxFR_FPS, MaxFR_BPS) = _ExtractedData[int(FrameSize)]
                if FR_BPS > MaxFR_BPS:
                    ILOAD     = ILOAD_FPS
                    OLOAD     = OLOAD_FPS
                    MaxFR_FPS = FR_FPS
                    MaxFR_BPS = FR_BPS
                    _ExtractedData[int(FrameSize)] = (Theroy_FPS, Theroy_BPS, ILOAD, OLOAD, MaxFR_FPS, MaxFR_BPS)
            else:
                 _ExtractedData[int(FrameSize)] = (Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, FR_FPS, FR_BPS)
        FrameSizeList = _ExtractedData.keys()
        FrameSizeList.sort()
       
        graphTitle = "Maximum Forwarding Rate"
        FrameSizeData1  = ()
        FrameSizeTheory = ()
        FrameSizeName   = []
        for eachFrameSize in FrameSizeList:
            (Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, FR_FPS, FR_BPS) = _ExtractedData[eachFrameSize]
            Theroy_Mbps = Theroy_BPS / 1000000.0
            MFR_Mbps    = FR_BPS / 1000000.0
            FrameSizeData1   += (MFR_Mbps, )
            FrameSizeTheory += (Theroy_Mbps, )
            FrameSizeName.append(str(eachFrameSize))
        return self.ForwardingRateGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeTheory, ], [FrameSizeData1], graphTitle)

    def CreateILOADVersusForwardingRateGraph( self, Frame_Size, Trial_Number, ResultData, GraphWidth = None, GraphHeight = None ):
        if not GraphWidth: GraphWidth  = 6.0 * inch
        if not GraphHeight: GraphHeight = 3.0 * inch

        #Extract the data from the CSV file
        _ExtractedData= []
        MaxFR_FPS   = 0.0
        MaxFR_ILOAD = 0.0
        MaxFR_BPS   = 0.0
        for (line) in ResultData:
            if len(line) == 0:
              break
            (FrameSize, TrialNumber, Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, FR_FPS, FR_BPS) = line
            if not isnum(FrameSize):
                continue
            if int(Frame_Size) != int(FrameSize) or int(Trial_Number) != int(TrialNumber):
                continue
            _ExtractedData.append( (ILOAD_FPS, FR_BPS / 1000000.0), )
            if FR_BPS > MaxFR_BPS:
                MaxFR_ILOAD = ILOAD_FPS
                MaxFR_BPS   = FR_BPS
        graphTitle = "Maximum Forwarding Rate for Size:%s Trial:%s" % (Frame_Size, Trial_Number)
        return self.MaximumForwardingRateGraph(GraphWidth, GraphHeight, [ _ExtractedData ], MaxFR_ILOAD, graphTitle)

    class ForwardingRateGraph(FlowableGraph):
        def __init__(self, width, height, names, line, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataLine  = line
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataLine, self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str('%.1f Mbps' % eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis - 20 # padding for legend
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            
            if self.validData:
                # add valid data to chart
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # add value labels above bars
                bc.barLabelFormat = "%.2f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            # chart formatting
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.labelTextFormat = '%.1f Mbps'
            # axis values
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            # axis labels
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            # add chart
            self.drawing.add(bc)

            self._drawLabels(self.title, "Frame Size", "")

            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height + 2 * legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'Forwarding Rate', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight

            # theoretical line
            if len(self.dataLine) > 0 and self.validData:
                # if one datapoint, draw horizontal line across chart
                DashArray = [2,2]
                if len(self.dataLine[0]) == 1:
                    yPos = bc.height * (self.dataLine[0][0] - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
                    self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.red, strokeWidth=1, strokeDashArray = DashArray))
                # theoretical line
                lc = HorizontalLineChart()    
                lc.x = bc.x
                lc.y = bc.y
                lc.height = bc.height
                lc.width  = bc.width
                # axis values
                lc.valueAxis.valueMin  = self.valueMin
                lc.valueAxis.valueMax  = self.valueMax
                lc.valueAxis.valueStep = self.valueStep
                lc.valueAxis.visible   = False
                lc.data = self.dataLine
                # line format
                lc.lines[0].strokeDashArray = [2,2]
                lc.lines[0].symbol = makeMarker('FilledDiamond')
                lc.joinedLines = 1
                # add chart
                self.drawing.add(lc)
                self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=lc.lines[0].strokeColor, strokeWidth=1, strokeDashArray = lc.lines[0].strokeDashArray))
                self.drawing.add(String(legendX + 22, legendY, 'Theory', fontName='Helvetica', fontSize=8))
                legendY -= legendHeight
           # done

    class MaximumForwardingRateGraph(FlowableGraph):
        def __init__(self, width, height, line, MaxPoint, title):
            FlowableGraph.__init__(self, width, height)
            self.dataLine  = line
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.MaxPoint  = MaxPoint
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors
            from reportlab.graphics.charts.utils import nextRoundNumber
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.lineplots import LinePlot
            from reportlab.graphics.charts.linecharts import Label
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            self._setScale(self.dataLine)
            
            self.drawing = Drawing(self.width, self.height)
    
            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str('%.3f Mbps' % eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            lp = LinePlot()
            SizeYaxis += lp.yValueAxis.tickLeft
            lp.x = x1 - x + SizeYaxis
            lp.y = y1 - y + SizeXaxis
            lp.height = Height - SizeXaxis - 20 # padding for legend
            lp.width  = Width  - SizeYaxis - lp.yValueAxis.tickLeft
            self.graphCenterX = lp.x + lp.width/2
            self.graphCenterY = lp.y + lp.height/2

            if self.validData:
                # add valid data to chart
                lp.xValueAxis.configure(self.dataLine)
                lp.yValueAxis.configure(self.dataLine)
                # Forwarding rate can't be negative thus set the min Y axis 
                # value to 0 
                lp.yValueAxis.valueMin = 0                              
                lp.data = self.dataLine
                lp.joinedLines = 1
                (R,G,B) = VeriwaveYellow
                lp.lines[0].strokeColor = colors.Color(R,G,B)
            else:
                # no valid data
                lp.xValueAxis.valueMin = 0
                lp.xValueAxis.valueMax = 1
                lp.xValueAxis.valueSteps = [0, 1]
                lp.yValueAxis.valueMin = 0
                lp.yValueAxis.valueMax = 1
                lp.yValueAxis.valueSteps = [0, 1]
                lp.data = [ ((0,0),), ]

                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            
            # format chart
            lp.yValueAxis.labelTextFormat = '%.3f Mbps'
            self.drawing.add(lp)

            self._drawLabels(self.title, "ILOAD pkts/sec", "")

            # Draw a line representing MFR on the X axis
            if self.validData:
                xPos = lp.width * (self.MaxPoint - lp.xValueAxis._valueMin) / (lp.xValueAxis._valueMax - lp.xValueAxis._valueMin)
                if xPos == 0:
                    # Fixed the line when the forwarding rate is 0 fps 
                    self.drawing.add(Line(lp.x + xPos, lp.y, lp.x + xPos, lp.y, strokeColor=colors.red, strokeWidth=1, strokeDashArray = [2,2]))
                    xPos = 50
                else:
                    self.drawing.add(Line(lp.x + xPos, lp.y, lp.x + xPos, lp.y + lp.height, strokeColor=colors.red, strokeWidth=1, strokeDashArray = [2,2]))
                # add label for MFR
                textString = "%.0f " % self.MaxPoint
                textWidth = self._stringWidth( textString, STATE_DEFAULTS['fontName'], 9 )
                self.drawing.add( String( lp.x + xPos - textWidth, lp.y + lp.height/2 + 6,
                                          textString,
                                          fontName = STATE_DEFAULTS['fontName'], fontSize = 9 ) )
                textString = "pkts/sec "
                textWidth = self._stringWidth( textString, STATE_DEFAULTS['fontName'], 9 )
                self.drawing.add( String( lp.x + xPos - textWidth, lp.y + lp.height/2 - 6,
                                          textString,
                                          fontName = STATE_DEFAULTS['fontName'], fontSize = 9 ) )
                
            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = lp.x + 5
            legendY = lp.y + lp.height + legendHeight
            self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=colors.red, strokeWidth=1, strokeDashArray = [2,2]))
            self.drawing.add(String(legendX + 22, legendY, 'Maximum', fontName='Helvetica', fontSize=8))

#This is an object to 

class SampleOLOAD_FR:
        def __init__(self, ListofPorts, ILOAD, PktType):
            self.Ports = ListofPorts
            self.ILOAD = ILOAD
            self.PktType = PktType
            self.TotalOLOAD = 0
            self.TotalFR    = 0
            self.TotalCount = 0

        def Sample(self):
            TotalTX = 0
            TotalRX = 0
            if self.ILOAD > 0.0:
                WaveEngine.WriteDetailedLog(['Port Name', 'ILOAD fps', 'TX %s frame Rate' % (self.PktType), 'RX %s frame Rate' % (self.PktType), 'Samples'])
            self.TotalCount += 1
            for Portname in self.Ports:
                WaveEngine.VCLtest("stats.read('%s')" % (Portname))
                if self.PktType == 'TCP':
                    FrameTX = stats.txTcpFramesOkRate
                    FrameRX = stats.rxTcpPacketsOkRate
                elif self.PktType == 'UDP':
                    FrameTX = stats.txUdpFramesOkRate
                    FrameRX = stats.rxUdpPacketsOkRate
                else:
                    FrameTX = stats.txIpPacketsOkRate
                    FrameRX = stats.rxIpPacketsOkRate
                self.TotalOLOAD += FrameTX
                self.TotalFR    += FrameRX
                if self.ILOAD > 0.0:
                    WaveEngine.WriteDetailedLog([Portname, '', FrameTX, FrameRX])
            if self.ILOAD > 0.0:
                WaveEngine.WriteDetailedLog(['Total', self.ILOAD, self.TotalOLOAD/self.TotalCount, self.TotalFR/self.TotalCount, self.TotalCount ])
            return self.TotalOLOAD/self.TotalCount, self.TotalFR/self.TotalCount            
    
        def Query(self):
            if self.TotalCount > 0:
                return self.TotalOLOAD/self.TotalCount, self.TotalFR/self.TotalCount            
            else:
                return 0.0, 0.0

                
##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
