#unicast_call_capacity
#
# Objective: Measure the maximum number of voice calls a system can handle.
#
import sys, time, sched, math, re, traceback
from basetest import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *
from odict import *

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>                    
        """
#        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}
        self.ClientOptions = {'PhyRate': 11, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}
          
        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic).
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of 00:00:00:00:00:00
                       tells the system to pick the first on on the list.
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """
        # This is the Server
        self.SourceClients = [ ('Server', 'Server', '00:00:00:00:00:00', 'DEFAULT', '192.168.0.10', '255.255.0.0', '192.168.0.1', (), Security_None, {} )]
        # These are the Badges
        self.DestClients   = [ ('Clients', 'AP1',   '00:00:00:00:00:00', 'DEFAULT', '192.168.1.100', '255.255.0.0', '192.168.0.1', (), Security_None, self.ClientOptions)]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  The total number of seconds to transmit an make the measurement.  Actual call transmit 
                        time will be slightly less dedepending upon the ClientCallDelay
        SampleTime -    This is the amount of time for a test iteration to execute.  Units: seconds.
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        self.Trials         =   1
        self.TransmitTime   = 150 
        self.SampleTime     =  30
        self.AgingTime      =   0
        
        ################### Badge Parameters ##########################
        """
        The parameters in this group describes the traffic between the clients.
        ClientPercentLocal - The percentage of calls between badges on the same AP.  100% means that all calls
                             are between badges on the same AP.
        ClientFrameSize -    The size of the audio frames in bytes.
        ClientFrameRate -    The number of frames per second to transmit each audio stream
        ClientCallDelay -    The number of seconds to stagger start each of the calls.  The first call will start
                             at 1 * ClientCallDelay, the second call will start at 2 * ClientCallDelay, third at
                             3 * ClientCallDelay, ....
        ClientFlowOptions -  Additional options to modify the audio frames contents/behavior 
        """
        self.ClientPercentLocal          = 100
        self.ClientFrameSize             = 128
        self.ClientFrameRate             = 1000.0/36.0
        self.ClientCallDelay             = 1
        self.ClientFlowOptions           = {'Type': 'UDP', 'PhyRate': 11, 'srcPort': 5002, 'destPort': 5002}

        ################### Server Parameters ##########################
        """
        The parameters in this group describes the traffic between each of the clients andthe server
        ServerFrameSize -    The size of the audio frames in bytes.
        ServerFrameRate -    The number of frames per second to transmit each audio stream.
        ServerFlowOptions -  Additional options to modify the audio frames contents/behavior 
        """
        self.ServerFrameSize           = 150
        self.ServerFrameRate           = 1.0/30.0
        self.ServerFlowOptions         = {'Type': 'UDP', 'PhyRate': 11, 'srcPort': 5902, 'destPort': 5903}

        ##################  Goal Seeking parameters  ##############################
        """
        The goal seeking parameters are used to define how the goal seeking algorithm will arrive at a solution.
        SearchMinimum -                The lower boundary for the goal seeking algorthim.  The algorthim will not search for
                                       values less than this.  Unit is in active calls.
        SearchMaximum -                The upper boundary for the goal seeking algorthim.  The algorthim will not search for
                                       values higher than this.  The binary searcg algorithm will use this as the inital value.
                                       If it passed, then the test is complete.  Otherwise the next value is half way between
                                       the SearchMinimum and SearchMaximum.  Unit is in active calls.
        SearchResolutionCount   -      Determines how precise the search for the final result needs to be. For instance,
                                       a value of 0.1 means that the search will stop if the current result is within 1 count 
                                       of the previous iteration result. 
        SearchAcceptLossPercent -      Determines how much packet loss will be acceptable in seeking the throughput result. 
                                       Ordinarily, throughput is defined as the maximum forwarding rate with zero frame loss.
                                       However, since 802.11 is a lossy medium it may not be possible in some circumstances to
                                       achieve zero frame loss. This parameter can be used in those situations to allow the search
                                       process to obtain the throughput goal. 
        ClientAcceptableOLOADPercent - The percentage that the offered frame rate can go below the intended rate before the
                                       call is dropped.  A congested channel will throttle the transmit rate down, otherwise the
                                       client's transmitted frame rate should be equal to the ClientFrameRate.
        """
        self.SearchMinimum               = 1
        self.SearchMaximum               = 16
        self.SearchResolutionCount       = 1
        
        self.ServerAcceptableLossCount    = 10
        self.ClientAcceptableLossPercent  = 0.5
        self.ClientAcceptableOLOADPercent = 95.0
        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the raw test details.  This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_unicast_call_capacity.csv'
        self.ReportFilename   = 'Report_unicast_call_capacity.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_unicast_call_capacity.csv'
        self.RSSIFilename    = 'RSSI_unicast_call_capacity.csv'
        
        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        """
        self.ClientLearningTime =   0 
        self.ClientLearningRate =  10

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  25.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  10.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =  1.0
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0
        
########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.23 $' 
        self.date    = '$Date: 2007/06/25 23:58:47 $' 

    def getTestName(self):
        
        return 'unicast_call_capacity'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
    
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore )
        #These are the test specific parameters that get passed down from the GUI for the test execution
        data = waveTestSpecificStore['unicast_call_capacity']
        for key in data.keys():
            # automatically handle all key/data pairs.
            cmdStr = "self.%s = %s" % ( key, data[ key ] )
            exec( cmdStr )

        # all good
        return True


    def copyClients(self):
        Count =  2 * int(self.SearchMaximum / len(self.DestClients))
        for x in range(len(self.DestClients)):
            (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, IncrTuple, Security, Options) = self.DestClients[x]
            if len(IncrTuple) == 3:
                (n, incMAC, incIP) = IncrTuple
            else:
                if Base_MAC.upper() == 'DEFAULT':
                    incMAC = 'DEFAULT'
                else:
                    incMAC = '0:0:0:0:0:1'
                incIP  = '0.0.0.1'
            self.DestClients[x] = (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, (Count, incMAC, incIP), Security, Options)
        WaveEngine.OutputstreamHDL("Completed: Setting test to %d clients per card\n" % (Count), WaveEngine.MSG_SUCCESS)

    # This replaces basetest with the custom mapping.  Feeel the power of WaveEngine
    def configureFlows(self):
        #Split up the map by Port
        PortRef = OrderedDict()
        for eachClient in self.ListofDesClient:
            (n, Portname, type) = self.ListofDesClient[eachClient]
            if PortRef.has_key(Portname):
                PortRef[Portname].append(eachClient)
            else:
                PortRef[Portname] = [eachClient, ]

        # Make sure all the wirless ports have the same number of clients (Algorithm limitation)
        ClientsPerPort = 0
        for eachPort in PortRef.keys():
            l = len(PortRef[eachPort])
            if ClientsPerPort > 0:
                if l != ClientsPerPort:
                    WaveEngine.OutputstreamHDL("Error: Port %s has a different number of client than expected.\n" % (eachPort), WaveEngine.MSG_ERROR)
                    raise WaveEngine.RaiseException()
            else:
                 ClientsPerPort = l   
            #print "Port=", eachPort, len(PortRef[eachPort])
        if self.ClientPercentLocal < 100.0:
            portCount = len(PortRef)
            if portCount % 2 == 1:
                WaveEngine.OutputstreamHDL("Error: Algorithm only match up clients on different ports if there is an even number of ports.\n" , WaveEngine.MSG_ERROR)
                raise WaveEngine.RaiseException()

        #Now comes the crunchy frog part
        CountofPairs = 0
        CountofLocal = 0
        indexClient = 0
        self.ClientCallPairs = []
        ServerNameList = self.ListofSrcClient.keys()
        while indexClient < ClientsPerPort:
            if CountofPairs > 0 or CountofLocal > 0:
                ratio = 100.0 * float(CountofLocal) / float(CountofPairs + CountofLocal)
            else:
                ratio = 0.0
            #print "Loop", indexClient, "ratio=", ratio
            if ratio > self.ClientPercentLocal:
                # Port part time
                LastClient = None
                for eachPort in PortRef.keys():
                    ListofName = PortRef[eachPort]
                    if LastClient != None:
                        #print "Remote", LastClient, ListofName[indexClient]
                        self.ClientCallPairs.append( CallSession(LastClient, ListofName[indexClient], ServerNameList[0]), )
                        LastClient = None
                        CountofPairs += 2
                    else:
                        LastClient = ListofName[indexClient]
                indexClient += 1    
            else:
                # 2 local port time
                for eachPort in PortRef.keys():
                    ListofName = PortRef[eachPort]
                    # fix for VPR 3685 to protect the index lookup
                    if indexClient >= len( ListofName )-1:
                        break
                    #print "Local", ListofName[indexClient], ListofName[indexClient+1]
                    self.ClientCallPairs.append( CallSession(ListofName[indexClient], ListofName[indexClient+1], ServerNameList[0]), )
                    CountofLocal += 2
                indexClient += 2
               
        #Setup the Server Keep Alives first
        FlowOptionsServr = self.ServerFlowOptions.copy()
        FlowOptionsServr['FrameSize']    = self.ServerFrameSize
        FlowOptionsServr['RateMode']     = 'pps'
        FlowOptionsServr['IntendedRate'] = self.ServerFrameRate
        FlowOptionsServr['NumFrames']    = 1

        #Now set up the client pairing        
        FlowOptionsClient = self.ClientFlowOptions.copy()
        FlowOptionsClient['FrameSize']    = self.ClientFrameSize
        FlowOptionsClient['RateMode']     = 'pps'
        FlowOptionsClient['IntendedRate'] = self.ClientFrameRate
        FlowOptionsClient['NumFrames']    = WaveEngine.MAXtxFrames

        #Create a list used for ARPing
        self.FlowList = OrderedDict()
        for eachCall in self.ClientCallPairs:
            flowDict = eachCall.CreateFlows(FlowOptionsClient, FlowOptionsServr, self.ListOfClients)
            self.FlowList.update(flowDict)
        self._createFlowGroup(self.FlowList, "XmitGroup")
        self.TotalFlows = len(self.FlowList)

    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters):
        TotalCalls  = 0
        for eachCall in self.ClientCallPairs:
            if eachCall.ActiveStatus:
                TotalCalls += 1
        
        # Get the latency counters
        latencyMin = WaveEngine.MAXlatency
        latencyMax = 0.0
        latencyAvg = 0.0
        TotalRX    = 0
        WaveEngine.WriteDetailedLog(['Port Name', "minimum Latency Overall", "maximum Latency Overall", "average Latency Overall", 'rxSignature'])
        for Portname in self.DesCardList:
            WaveEngine.VCLtest("stats.setDefaults()")
            WaveEngine.VCLtest("stats.read('%s')" % (Portname))
            if WaveEngine.GetCachePortInfo(Portname) == '8023':
                rxSignature = stats.rxSignatureValid
            else:
                rxSignature = stats.rxSignatureValidFrames
            # VCL returns uS
            if stats.minimumLatencyOverall < latencyMin:
                latencyMin = stats.minimumLatencyOverall
            if stats.maximumLatencyOverall > latencyMax:
                latencyMax = stats.maximumLatencyOverall
            latencyAvg += rxSignature * stats.averageLatencyOverall
            TotalRX    += rxSignature
            WaveEngine.WriteDetailedLog([Portname, stats.minimumLatencyOverall, stats.maximumLatencyOverall, stats.averageLatencyOverall, rxSignature])
        latencyMin = latencyMin / 1000000.0
        latencyMax = latencyMax / 1000000.0
        if TotalRX > 0:
            latencyAvg = latencyAvg / (TotalRX * 1000000.0)
            self.RealtimeData['latencyAvg'] = "%ss" % (Float2EngNotation(latencyAvg, self.DisplayPrecision))
        else:        
            latencyAvg = 0.0
            self.RealtimeData['latencyAvg'] = "N/A"

        #logic to change latency buckets
        AcceptableDelta = 0.25
        if latencyMin > 0.0 and latencyMax > 0.0:
            if self.LatencyMinimum > 0 :
                DeltaMin = abs(latencyMin - self.LatencyMinimum) / self.LatencyMinimum
            else:
                DeltaMin = 100.0
            if self.LatencyMaximum > 0 :
                DeltaMax = abs(latencyMax - self.LatencyMaximum) / self.LatencyMaximum
            else:
                DeltaMax = 100.0
            if DeltaMin > AcceptableDelta or DeltaMax > AcceptableDelta:
                self.LatencyBucketSettings = WaveEngine.ConfigureLatencyBuckets(self.DesCardList, latencyMin, latencyMax * 2.0)
                self.LatencyMinimum = latencyMin
                self.LatencyMaximum = latencyMax
                for eachCall in self.ClientCallPairs:
                    eachCall.LatencyBucketCount  = {}
                    eachCall.LatencyBucketValues = self.LatencyBucketSettings
                _Detailed = ["New Buckets", ElapsedTime, '', '', '', '', '', '', '', '', '']
                for x in range( 16 ):
                    _Detailed.append("< %ss" % (Float2EngNotation(self.LatencyBucketSettings[x] / 1000000.0, self.DisplayPrecision)))
                WaveEngine.WriteDetailedLog(_Detailed)
                    
        JitterTotal = 0.0
        JitterCount = 0.0
        TotalOLOAD  = 0.0
        TotalFR     = 0.0
        for eachCall in self.ClientCallPairs:
            TotalOLOAD += eachCall.OLOAD
            TotalFR    += eachCall.FR
            if eachCall.LatencyJitter != None:
                JitterTotal += eachCall.LatencyJitter
                JitterCount += 1.0
        if JitterCount > 0:
            Jitter = JitterTotal/JitterCount
            self.RealtimeData['jitter'] = "%ss" % (Float2EngNotation(Jitter, self.DisplayPrecision))
        else:
            self.RealtimeData['jitter'] = Jitter = "N/A"
        
        ErrorStatus = PassedParameters['Error']
        WaveEngine.OutputstreamHDL("\rActiveCalls=%d OLOAD=%spps FR=%spps MinLatency=%ss AvgLatency=%s MaxLatency=%ss Jitter=%s (%s)" %\
                (TotalCalls, Float2EngNotation(TotalOLOAD, self.DisplayPrecision), Float2EngNotation(TotalFR, self.DisplayPrecision), Float2EngNotation(latencyMin, self.DisplayPrecision), self.RealtimeData['latencyAvg'], Float2EngNotation(latencyMax, self.DisplayPrecision), self.RealtimeData['jitter'], int2time(ElapsedTime)), WaveEngine.MSG_OK)
        self.ResultsForCSVfile.append( (PassedParameters['Trial'], self.RealtimeData['MaxCalls'], int2time(ElapsedTime), TotalCalls, \
                TotalOLOAD, TotalFR, latencyMin, latencyMax, latencyAvg, Jitter, ErrorStatus))
        return True

    def startTest(self, FuncRealTime):

        #Put the flows in there starting groups
        WaveEngine.VCLtest("flowGroup.create('%s')" % ("KeepAlive"))
        for eachCall in self.ClientCallPairs:
            for eachFlow in eachCall.ServerFlowList.keys():
                MoveFlow(eachFlow, "XmitGroup", "KeepAlive")
            #Set the PASS/FAIL criteria for eachof the calls
            eachCall.ServerAcceptableLossCount    = self.ServerAcceptableLossCount
            eachCall.ClientAcceptableLossPercent  = self.ClientAcceptableLossPercent
            eachCall.ClientAcceptableOLOADPercent = self.ClientAcceptableOLOADPercent

        for TrialNumber in range(1, 1 + self.Trials):
            #Initailize the binary search logic
            SearchLogic = WaveEngine.BinarySerach()
            SearchLogic.minimum(self.SearchMinimum)
            SearchLogic.maximum(self.SearchMaximum)
            SearchLogic.resolution(self.SearchResolutionCount)

            #Now do the Iterrations
            while SearchLogic.searching():
                WaveEngine.ClearAllCounter(self.CardList)
                WaveEngine.WriteAPinformation(self.ListOfClients)
                self.ResultsForCSVfile.append( ('Trial', 'Total Calls', 'Time', 'Active Calls', 'Offered Load fps', 'Forwarding Rate fps', 'Minimum Latency', 'Maximum Latency', 'Average Latency', 'Jitter', 'Status') )
                self.RealtimeData = {'latencyAvg': 'N/A', 'jitter': 'N/A', 'MaxCalls': int(SearchLogic.query()) }
                self.LatencyMinimum = 0
                self.LatencyMaximum = 0
                scheduler = sched.scheduler(time.time, time.sleep)

                # Setup calls
                EventTime = self.ClientCallDelay
                count = 0
                for eachCall in self.ClientCallPairs:
                    eachCall.ClearCounters()
                    #                   delay, priority,  action, arguments
                    if int(SearchLogic.query()) > count:
                        scheduler.enter(EventTime, 1, eachCall.StartCall, ("XmitGroup", ))
                    count += 1
                    EventTime += self.ClientCallDelay

                # Check the keepAlives
                EventTime = self.ClientCallDelay
                KeepAliveTime = 1.0 / self.ServerFrameRate
                for eachCall in self.ClientCallPairs:
                    Timer = EventTime
                    while self.TransmitTime > Timer:
                        scheduler.enter(Timer,       10, eachCall.CheckKeepAlive, ("KeepAlive", TrialNumber, Timer))
                        Timer += KeepAliveTime
                    EventTime += self.ClientCallDelay

                # Check the Audio every sample
                EventTime = self.ClientCallDelay
                for eachCall in self.ClientCallPairs:
                    Timer = EventTime + self.SampleTime
                    while self.TransmitTime > Timer:
                        scheduler.enter(Timer,       20, eachCall.CheckCallQuality, (TrialNumber, Timer))
                        Timer += self.SampleTime
                    EventTime += self.ClientCallDelay
                    
                # Now the real time stats
                Parameters     = {'Trial': TrialNumber, 'Error': ''}
                PassParameters = {'Trial': TrialNumber, 'Error': 'PASS'}
                for n in range(int(self.TransmitTime / self.UpdateInterval)):
                    ElapsedTime = self.UpdateInterval * (n+1)
                    Timeleft    = self.TransmitTime - ElapsedTime
                    if Timeleft <= 0:
                        scheduler.enter(ElapsedTime, 100,  self.PrintRealtimeStats, ('TX', Timeleft, ElapsedTime, PassParameters))
                    else:
                        scheduler.enter(ElapsedTime, 100,  self.PrintRealtimeStats, ('TX', Timeleft, ElapsedTime, Parameters))
 
                #Run the Iteration
                self.LatencyBucketSettings = None
                WaveEngine.OutputstreamHDL("\nTrial: %d Attempting %d calls\n" % (TrialNumber, int(SearchLogic.query())), WaveEngine.MSG_OK)
                try:
                    scheduler.run()
                except WaveEngine.RaiseIterationFailed, MoreInfo:
                    Parameters['Error'] = MoreInfo.String
                    WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_SUCCESS)
                    self.PrintRealtimeStats('', self.TransmitTime - MoreInfo.ElapsedTime, MoreInfo.ElapsedTime, Parameters)
                    WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_SUCCESS)
                    SearchLogic.FAIL()
                else:
                    WaveEngine.OutputstreamHDL(" PASS\n", WaveEngine.MSG_SUCCESS)
                    SearchLogic.PASS()
                    
                # Stop all the calls
                WaveEngine.WriteDetailedLog(['',])
                for eachCall in self.ClientCallPairs:
                    eachCall.StopSession("XmitGroup", "KeepAlive")

                # Add the overall loss rate for each of the flows
                self.ResultsForCSVfile.append( ('Trial', 'Total Calls', 'Flow name', 'Total Transmit', 'Total Receive', 'Frame Loss Rate') )
                for eachCall in self.ClientCallPairs:
                    for Flowname in eachCall.ClientLastRXCount.keys():
                        if eachCall.ClientLastTXCount[Flowname] > 0:
                            FrameLossRate = 100.0 * (eachCall.ClientLastTXCount[Flowname] - eachCall.ClientLastRXCount[Flowname]) / eachCall.ClientLastTXCount[Flowname]
                        else:
                            FrameLossRate = 0.0
                        self.ResultsForCSVfile.append( (TrialNumber, self.RealtimeData['MaxCalls'], Flowname, eachCall.ClientLastTXCount[Flowname], eachCall.ClientLastRXCount[Flowname], FrameLossRate) )
                self.ResultsForCSVfile.append( ('',) )

                # Certain DUT do not like the constant traffic
                if self.AgingTime > 0:
                    WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')

            # Print results for the trail
            if SearchLogic.neverpassed:
                self.ResultsForCSVfile.append( (TrialNumber, 0) )
                WaveEngine.OutputstreamHDL("Error: Trial=%d failed every pass. No measurement.\n" % (TrialNumber), WaveEngine.MSG_ERROR)
            else:
                self.ResultsForCSVfile.append( (TrialNumber, SearchLogic.minimum) )
                WaveEngine.OutputstreamHDL("Completed: Trial %d passed with %d calls\n" % (TrialNumber, SearchLogic.minimum), WaveEngine.MSG_SUCCESS)

    # Extract data from the CVS file and puts store it as the object's attribute
    def ParseCVSdata(self, dataFromFile):
        # Data for the detailed section of the Report
        self._DetailedResults  = []
        # For the CallsvsTime graph
        self._CallsvsTimeData  = {}
        # For the TrialvsCalls graph
        self._TrialvsCallsData = {}
        # For the Latency Graphs
        self._LatencyData = {}
        
        flagTitle   = False
        CurrentTrial    = 0
        CurrentMaxCalls = 0
        ElaspedTime     = self.SampleTime
        LastLine        = None
        for line in dataFromFile:
            if len(line) != 11:
                continue
            
            (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus) = line
            if not isnum(Trial):
                if not flagTitle:
                    self._DetailedResults.append( (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus), )
                    flagTitle = True
                    continue
            else:
                n = time2int(Time)
                if not self._CallsvsTimeData.has_key(Trial):
                    self._CallsvsTimeData[Trial] = {}
                if self._CallsvsTimeData[Trial].has_key(MaxCalls):
                    if n > self._CallsvsTimeData[Trial][MaxCalls]:
                        self._CallsvsTimeData[Trial][MaxCalls] = n
                else:
                    self._CallsvsTimeData[Trial][MaxCalls] = n
                        
                #EXtract data for Trials vs. Calls graph
                if not self._TrialvsCallsData.has_key(Trial):
                    self._TrialvsCallsData[Trial] = 0
                if n == self.TransmitTime and len(ErrorStatus) < 5:
                    if MaxCalls > self._TrialvsCallsData[Trial]:
                        self._TrialvsCallsData[Trial] = MaxCalls
                    
                #Detected a new run
                if int(CurrentTrial) != int(Trial) or CurrentMaxCalls != MaxCalls:
                    if LastLine != None:
                        (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus) = LastLine
                        self._DetailedResults.append( (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus), )
                        (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus) = line
                    ElaspedTime     = self.SampleTime
                    CurrentTrial    = Trial
                    CurrentMaxCalls = MaxCalls
                    
                # Get the date for the latenncy graph
                if not self._LatencyData.has_key(Trial):
                    self._LatencyData[Trial] = {}
                if self._LatencyData[Trial].has_key(MaxCalls):
                    (TotalMin, TotalMax, TotalAvg, Count) = self._LatencyData[Trial][MaxCalls]
                    if TotalMin > latencyMin and latencyMin > 0.0:
                        TotalMin = latencyMin
                    if latencyMax > TotalMax:
                        TotalMax = latencyMax
                    self._LatencyData[Trial][MaxCalls] = (TotalMin, TotalMax, TotalAvg + latencyAvg, Count + 1)
                else:
                    if latencyMin > 0.0:
                        self._LatencyData[Trial][MaxCalls] = (latencyMin, latencyMax, latencyAvg, 1)
                    else:
                        self._LatencyData[Trial][MaxCalls] = (3.14159, latencyMax, latencyAvg, 1)

                #Data for the detailed results
                latencyMin = "%ss" % (Float2EngNotation(float(latencyMin), self.DisplayPrecision) )
                latencyMax = "%ss" % (Float2EngNotation(float(latencyMax), self.DisplayPrecision) )
                latencyAvg = "%ss" % (Float2EngNotation(float(latencyAvg), self.DisplayPrecision) )
                if isnum(jitter):
                    jitter = "%ss" % (Float2EngNotation(float(jitter), self.DisplayPrecision) )
                        
                #Only print everyUpdate time
                if time2int(Time) >= ElaspedTime:
                    self._DetailedResults.append( (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus), )
                    ElaspedTime += self.SampleTime
                    LastLine = None
                else:
                    LastLine = (Trial, MaxCalls, Time, ActiveCalls, OLOAD, FR, latencyMin, latencyMax, latencyAvg, jitter, ErrorStatus)

                
    def PrintReport(self):
        import os.path
        # TEXT Stuff here
        Overview = "A goal-seeking test that determines the maximum call loading capacity of a DUT when a badge "\
                   "to badge calls are placed while the badges maintain connection with the call server. The application "\
                   "generates reports capturing the number of calls placed, number of calls succeeded, number of calls "\
                   "failed, min/max/avg latency and jitter."
        TrialCall= "Call Capacity per Trial graph shows the maximum sustainable calls at which none of the calls are "\
                   "dropped by the System Under Test.  Calls are initialed at the beginning of the test duration and the "\
                   "call quality must not drop below the acceptable limits for the entire configured Test Duration.  Larger "\
                   "numbers mean that more people can use the network."
        CallsTime= "During the Test Duration, if the quality of a call drops below the acceptable limits, then the Test "\
                   "Duration is terminated and the binary search attempts a lower number of calls.  These graphs plot for "\
                   "every trail, how long a test iteration lasted.  If a test iteration passed, then the time will match the "\
                   "configured Test Duration.  Ideally the left side of the graphs should have bars touching the red Test "\
                   "Duration line.  As the number of calls increase, the time will decrease.  The rate and shape of the "\
                   "decreasing Time is of interest."
        Latency  = "The latency graph compares the minimum, maximum, and average latency times for all voice frames "\
                   "forwarded by the SUT. The lower the latency the better overall performance. Also, the smaller the "\
                   "difference between the maximum and minimum latency values the better a system will perform."
        Method   = "In each iteration of the test, the test procedure is executed at a specific call load until such a "\
                   "time when the DUT starts dropping calls.  The Test procedure involves badge clients performing a "\
                   "call setup for about 1 sec with the call server and then establishing a call with another client.  "\
                   "Each badge client has 2 flows including a call flow and a heart-beat flow with the call server.  "\
                   "The heart-beat flow uses keep-alive packets which are UDP packets about 150 bytes in length sent "\
                   "from client to server every 30 secs and the server acknowledges on every keep-alive received.  "\
                   "The call flow between clients uses Audio packets which are UDP packets about 364 bytes in length "\
                   "sent every 36ms. The iteration is a failure if 10 consecutive keepalives fail or if the number of "\
                   "call failures exceeds a specific threshold set by the user."
        RSSIdetails="The RSSI is sampled each test iteration just before transmitting data.  The RSSI value "\
                    "can range from -127 dBm to + 127 dBm.  Desired RSSI values are in the range of -60 dBm to -20 dBm."

        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Call Capacity Report", self.DUTinfo)
        MyReport.InsertHeader("Overview")
        MyReport.InsertParagraph(Overview)
        self.ParseCVSdata(self.ResultsForCSVfile)
        
        MyReport.InsertHeader("Call Capacity")
        MyReport.InsertObject(self.CreateTrialvsCallsGraph(self._TrialvsCallsData))
        MyReport.InsertParagraph(TrialCall)
        #MyReport.InsertPageBreak()
        
        MyReport.InsertHeader("Time Duration per Trial")
        MyReport.InsertParagraph(CallsTime)
        for TrialNumber in range(1, 1 + self.Trials):
            MyReport.InsertObject(self.CreateCallsVStimeGraph(self._CallsvsTimeData, TrialNumber, self.TransmitTime))
            
        MyReport.InsertHeader("Latency per Trial")
        MyReport.InsertParagraph(Latency)
        for TrialNumber in range(1, 1 + self.Trials):
            MyReport.InsertObject(self.CreateLatencyGraph(self._LatencyData, TrialNumber))
            
        MyReport.InsertHeader("Test Configuration")
        ConfigParamters = [('Parameter', 'Value', 'Description'),
                           ('Transmit Time', "%d secs" % (self.TransmitTime), 'The number of seconds that the WaveTest will transmit for each iteration.'),
                           ('Client Call Delay', "%d secs" % (self.ClientCallDelay), 'The number of seconds between adding another call'),
                           ('Aging Time', "%d secs" % (self.AgingTime), \
                            'The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to zero.'),
                           ('Search Minimum', self.SearchMinimum, \
                            'The lower boundary for the goal seeking algorithm.  The algorithm will not search for values less than this.'),
                           ('Search Maximum', self.SearchMaximum, \
                            'The upper boundary for the goal seeking algorithm.  The algorithm will not search for values higher than this.'),
                           ('Search Resolution', self.SearchResolutionCount, \
                            'Determines how precise the search for the final result needs to be.'),
                           ('Sample Time', "%d secs" % (self.SampleTime), 'The time between sampling counters for computing if a call was dropped'),
                           ('Maximum Call Packet Loss', "%s%%" % (str(EngNotation2Int(Float2EngNotation(float(self.ClientAcceptableLossPercent), 2)))), \
                            'Determines the maximum packet loss a call can have before being dropped.'),
                           ('Minimum Call OLOAD', "%s%%" % (str(EngNotation2Int(Float2EngNotation(float(self.ClientAcceptableOLOADPercent), 2)))), \
                            'Determines the minimum transmit rate a call can have before being dropped.'),
                           ('Maximum Missed Server Polls', self.ServerAcceptableLossCount, \
                            'The maximum number of consecutive lost hello frames before a call is dropped by the server'),
                           ('Trials', self.Trials, 'Number of times the measurement will be repeated.  Multiple trials are used for averaging the measurement.')]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ('Client Contention', "%d%%" % (self.testOptions['ContentionProbability']) , 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
        MyReport.InsertParameterTable(ConfigParamters, columns=[2*inch, 0.75*inch, 3.25*inch])
        
        MyReport.InsertHeader("Client Map")
        MyReport.InsertClientMap(self.SourceClients, self.DestClients, True, self.CardMap)
        
        MyReport.InsertHeader("Methodology")
        MyReport.InsertParagraph(Method)
        MyReport.InsertPageBreak()

        MyReport.InsertHeader("Detailed Results")
        MyReport.InsertDetailedTable(self._DetailedResults, columns=[0.4*inch, 0.4*inch, 0.60*inch, 0.45*inch, 0.63*inch, 0.63*inch, 0.63*inch, 0.63*inch, 0.63*inch, 0.63*inch, 0.70*inch])

        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename ,
                               reportObject = MyReport, 
                               text1 = RSSIdetails)
        
        MyReport.InsertHeader("Other Info")
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        MyReport.Print()

    def run(self):
        # For Testing reports
        #self.ReadResults()
        #self.PrintReport()
        #return

        #Adding some error checking to make sure the test is valid
        TotalSamples = int(self.TransmitTime/self.SampleTime)
        if TotalSamples <= 1:
            WaveEngine.OutputstreamHDL('ERROR: The TransmitTime MUST be at least 2 times longer than the SampleTime', WaveEngine.MSG_ERROR)
            return
    
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            
            self.copyClients()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, 
#                                 self.ClientLearningTime, 
#                                 self.ClientLearningRate)
            self.configureFlows()
            self.setQoShandshakeFlag()
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.SaveResults()
            self.ExitStatus = 2
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus
            
    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """
        msg =  "A goal-seeking test that determines the maximum call loading capacity of a DUT when "\
                "badge to badge calls are placed while the badges maintain connection with the call server. "\
                "Measured metrics include the number of calls placed, number of calls succeeded, "\
                "number of calls failed, min/max/avg latency and jitter."
        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        self.ParseCVSdata(self.ResultsForCSVfile)
        # create charts
        charts = {}
        c = self.CreateTrialvsCallsGraph(self._TrialvsCallsData)
        t = c.title
        charts[ t ] = c
        for TrialNumber in range(1, 1 + self.Trials):
            c = self.CreateCallsVStimeGraph(self._CallsvsTimeData, TrialNumber, self.TransmitTime)
            t = c.title
            charts[ t ] = c
            c= self.CreateLatencyGraph(self._LatencyData, TrialNumber)
            t = c.title
            charts[ t ] = c
        return charts

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateTrialvsCallsGraph(self, DataDict):
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.0 * inch
        CallNames = DataDict.keys()
        CallNames.sort()
        CallTime = []
        CallName = []
        for eachCall in CallNames:
            CallTime.append(DataDict[eachCall])
            CallName.append(str(eachCall))
        return self.TrialvsCallsGraph(GraphWidth, GraphHeight, CallName, [CallTime, ], "Call Capacity per Trial")

    def CreateCallsVStimeGraph(self, DataDict, Trial, TestDuration):
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.5 * inch

        graphTitle = "Trial %s: Successful Calls vs. Time" % (Trial)
        CallNames = DataDict[Trial].keys()
        CallNames.sort()
        CallTime = []
        CallName = []
        for eachCall in CallNames:
            CallTime.append(DataDict[Trial][eachCall])
            CallName.append(str(eachCall))
        return self.CallsVStimeGraph(GraphWidth, GraphHeight, CallName, [CallTime, ], graphTitle, TestDuration)

    def CreateLatencyGraph(self, ResultData, Trial):
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.5 * inch

        FrameSizeList = ResultData[Trial].keys()
        FrameSizeList.sort()
        
        graphTitle = "Trial %s: Latency versus Calls" % (Trial)
        FrameSizeData1 = ()
        FrameSizeData2 = ()
        FrameSizeData3 = ()
        FrameSizeName = []
        for eachFrameSize in FrameSizeList:
            (TotalMin, TotalMax, TotalAvg, Count) = ResultData[Trial][eachFrameSize]
            FrameSizeData1 += (TotalMin, )
            FrameSizeData2 += (TotalMax, )
            FrameSizeData3 += (TotalAvg/Count, )
            FrameSizeName.append(str(eachFrameSize))
        return self.LatencyGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeData1, FrameSizeData2, FrameSizeData3], graphTitle)

    class TrialvsCallsGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title
            
        def _customSecondsLabelFormat( self, value ):
            return str(int(value))

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            #self._drawBox(x1, y1, Width, Height)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            countSteps = int(self.valueMax / self.valueStep)
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(self._customSecondsLabelFormat(eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
            
            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft   
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                if len(self.dataNames) < 16:
                    bc.barLabelFormat = self._customSecondsLabelFormat
                    bc.barLabels.dy = 0.08*inch
                    bc.barLabels.fontSize = 9
            else:
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            bc.valueAxis.labelTextFormat = self._customSecondsLabelFormat
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            self.drawing.add(bc)

            #Put the labels on the center of the graph
            self._drawLabels(self.title, "Trial", "Calls")


    class CallsVStimeGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, title, TestDuration):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title
            self.TestDuration = TestDuration

        def _customSecondsLabelFormat( self, value ):
            return str(int2time(value))

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)
            #self._drawBox(x1, y1, Width, Height)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            countSteps = int(self.valueMax / self.valueStep)
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(self._customSecondsLabelFormat(eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )
            
            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft   
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                if len(self.dataNames) < 8:
                    bc.barLabelFormat = self._customSecondsLabelFormat
                    bc.barLabels.dy = 0.08*inch
                    bc.barLabels.fontSize = 9
            else:
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.labelTextFormat = self._customSecondsLabelFormat
            bc.valueAxis.valueMin  = self.valueMin
            bc.valueAxis.valueMax  = self.valueMax
            bc.valueAxis.valueStep = self.valueStep
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            self.drawing.add(bc)

            # Add A line showing the test duration
            DashArray = [2,2]
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height - 12
            yPos = bc.height * (self.TestDuration - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
            self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.red, strokeWidth=1, strokeDashArray = DashArray))
            self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=colors.red, strokeWidth=1, strokeDashArray = DashArray))
            self.drawing.add(String(legendX + 22, legendY, 'Test Duration', fontName='Helvetica', fontSize=8))

            #Put the labels on the center of the graph
            self._drawLabels(self.title, "Calls", "Time")

    class LatencyGraph(FlowableGraph):
        def __init__(self, width, height, names, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _customSecondsLabelFormat( self, value ):
            return str( "%ss" % Float2EngNotation( value, 2 ) )
        
        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.axes import XCategoryAxis,YValueAxis
            from reportlab.graphics.charts.textlabels import Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            
            self.originX = x
            self.originY = y
            self._setScale([self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            countSteps = int(self.valueMax / self.valueStep)
            SizeYaxis = 0.0
            for n in range(countSteps + 1):
                eachValue = self.valueMin + n * self.valueStep
                textString = self._customSecondsLabelFormat( eachValue )
                SizeYaxis = max(SizeYaxis, self._stringWidth(textString, STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.x = x1 - x + SizeYaxis
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis
            bc.width  = Width  - SizeYaxis
            self.graphCenterX = bc.x + bc.width/2
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                bc.valueAxis.valueMin  = self.valueMin
                bc.valueAxis.valueMax  = self.valueMax
                bc.valueAxis.valueStep = self.valueStep
                bc.valueAxis.labelTextFormat = self._customSecondsLabelFormat
                # add value labels above bars
                if len(self.dataNames) < 6:
                    bc.barLabelFormat = self._customSecondsLabelFormat
                    bc.barLabels.dy = 0.08*inch
                    bc.barLabels.fontSize = 9
            else:
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                bc.valueAxis.valueMin  = 0
                bc.valueAxis.valueMax  = 1
                bc.valueAxis.valueStep = 1
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            self.drawing.add(bc)

            #Adjust the labels to be the center of the graph
            self._drawLabels(self.title, "Calls", "Latency")

            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height - 12
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'MIN', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[1].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'MAX', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[2].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'AVG', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight


##################################### Helper Functions ###################################
def int2time(n):
    hrs = int(n / 3600)
    min = int( (n - 3600*hrs) / 60)
    sec = int(n % 60 )
    return "%0d:%02d:%02d" % (hrs, min, sec)

def time2int(str):
    REvalue = re.search("(\d+):(\d+):(\d+)", str)
    return int(REvalue.group(1))*3600 + int(REvalue.group(2))*60 + int(REvalue.group(3))

# Test to see if I can move the flow
def MoveFlow(FlowName, SrcGroup, DesGroup):
    if SrcGroup not in flowGroup.getNames():
        WaveEngine.OutputstreamHDL("Error: Trying to move flow %s from %s to %s, but %s does not exsist.\n" %\
                (FlowName, SrcGroup, DesGroup, SrcGroup), WaveEngine.MSG_ERROR)
        return
    if DesGroup not in flowGroup.getNames():
        WaveEngine.OutputstreamHDL("Error: Trying to move flow %s from %s to %s, but %s does not exsist.\n" %\
                (FlowName, SrcGroup, DesGroup, DesGroup), WaveEngine.MSG_ERROR)
        return
    if FlowName in flowGroup.getFlowNames(SrcGroup):
        WaveEngine.VCLtest("flowGroup.move('%s', '%s', '%s')"   % (FlowName, SrcGroup, DesGroup))
        return
    for fgname in flowGroup.getNames():
        if FlowName in flowGroup.getFlowNames(fgname):
            WaveEngine.OutputstreamHDL("Error: Trying to move flow %s from %s to %s, but the flow belongs to %s.\n" %\
                (FlowName, SrcGroup, DesGroup, fgname), WaveEngine.MSG_ERROR)
    return        

class CallSession:
    def __init__(self, ClientLeft, ClientRight, ClientServer):
        self.ClientLeft   = ClientLeft 
        self.ClientRight  = ClientRight 
        self.ClientServer = ClientServer
        self.ClientFlowList = {}
        self.ServerFlowList = {}
        self.ActiveStatus   = False
        self.TempGroupName  = 'Temp'

        # PASS/FAIL criteria
        self.ServerAcceptableLossCount    = 10
        self.ClientAcceptableLossPercent  = 0.5
        self.ClientAcceptableOLOADPercent = 95

        self.ClearCounters()
        
        #RealTime Stats
    def ClearCounters(self):
        self.ServerLastRXcount     = 0
        self.ServerConsectRXLost   = 0
        self.ClientLastTimeChecked = 0
        self.OLOAD                 = 0.0
        self.FR                    = 0.0
        self.ClientLastRXCount     = {}
        self.ClientLastTXCount     = {}
        self.LatencyBucketValues   = []
        self.LatencyBucketCount    = {}
        self.LatencyAverage        = None
        self.LatencyJitter         = None
        
    def CreateFlows(self, ClientFlowOptions, ServerFlowOptions, ClientDict):
        ClientLeft = {}
        if not ClientDict.has_key(self.ClientLeft):
            WaveEngine.OutputstreamHDL("FAULT DETECTED: CallSession.CreateFlows cannot find %s in ClientDict" % (self.ClientLeft), WaveEngine.MSG_ERROR)
            raise WaveEngine.RaiseException()
        ClientLeft[self.ClientLeft]   = ClientDict[self.ClientLeft]
        ClientRight = {}
        if not ClientDict.has_key(self.ClientRight):
            WaveEngine.OutputstreamHDL("FAULT DETECTED: CallSession.CreateFlows cannot find %s in ClientDict" % (self.ClientRight), WaveEngine.MSG_ERROR)
            raise WaveEngine.RaiseException()
        ClientRight[self.ClientRight] = ClientDict[self.ClientRight]
        ClientServer = {}
        ClientServer[self.ClientServer] = ClientDict[self.ClientServer]
        clients = ClientLeft.copy()
        clients.update(ClientRight)
        self.ServerFlowList = WaveEngine.CreateFlows_PartialMesh(ClientServer, clients, True, ServerFlowOptions) 
        self.ClientFlowList = WaveEngine.CreateFlows_Pairs(ClientLeft, ClientRight, True, ClientFlowOptions)
        self.ClientILOAD = ClientFlowOptions['IntendedRate']
        clients = self.ServerFlowList.copy()
        clients.update(self.ClientFlowList)
        return clients
        
    def StartCall(self, GroupName):
        if self.TempGroupName not in flowGroup.getNames():
            WaveEngine.VCLtest("flowGroup.create('%s')" % (self.TempGroupName))
        for eachFlowName in self.ClientFlowList.keys():
            MoveFlow(eachFlowName, GroupName, self.TempGroupName)
        WaveEngine.VCLtest("action.startFlowGroup('%s')" % (self.TempGroupName))
        self.ActiveStatus = True

        for eachFlowName in self.ClientFlowList.keys():
            MoveFlow(eachFlowName, self.TempGroupName, GroupName)
        self.ClientLastTimeChecked = time.time()

    def CheckKeepAlive(self, GroupName, Trial, ElapsedTime):
        FailedKeepAlive = False
        if self.TempGroupName not in flowGroup.getNames():
            WaveEngine.VCLtest("flowGroup.create('%s')" % (self.TempGroupName))
        WaveEngine.WriteDetailedLog(['CheckKeepAlive', 'Time', 'src_port', 'src_client', 'des_port', 'des_client', 'txFlowFramesOk', 'txFlowOctetsOk', 'rxFlowFramesOk', 'rxFlowOctetsOk', 'Lost'])
        for eachFlow in self.ServerFlowList.keys():
            (src_port, src_client, des_port, des_client) = self.ServerFlowList[eachFlow]
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (des_port, eachFlow))
            if self.ServerLastRXcount == flowStats.rxFlowFramesOk:
                self.ServerConsectRXLost += 1
            else:
                self.ServerConsectRXLost = 0
            self.ServerLastRXcount   =  flowStats.rxFlowFramesOk
            WaveEngine.WriteDetailedLog([eachFlow, ElapsedTime, src_port, src_client, des_port, des_client, flowStats.txFlowFramesOk, flowStats.txFlowOctetsOk, flowStats.rxFlowFramesOk, flowStats.rxFlowOctetsOk, self.ServerConsectRXLost])
            if self.ServerConsectRXLost >= self.ServerAcceptableLossCount:
                FailedKeepAlive = True 
                WaveEngine.OutputstreamHDL("\n FAIL Flow %s has stopped forwarding" % (eachFlow), WaveEngine.MSG_WARNING)
            MoveFlow(eachFlow, GroupName, self.TempGroupName)
        
        #Send another Keep Alive Packet
        WaveEngine.ModifyFlows(self.ServerFlowList, {'NumFrames': 1})
        WaveEngine.VCLtest("action.startFlowGroup('%s')" % (self.TempGroupName))
        for eachFlow in self.ServerFlowList.keys():
            MoveFlow(eachFlow, self.TempGroupName, GroupName)
            
        if FailedKeepAlive:
            raise WaveEngine.RaiseIterationFailed('Keep Alive', ElapsedTime)

    def CheckCallQuality(self, Trial, ElapsedTime):
        FailedCallQuality = None
        if not self.ActiveStatus:
            return 
        
        WaveEngine.WriteDetailedLog(['CheckCallQuality', 'Time',  'src_port', 'src_client', 'des_port', 'des_client', 'txFlowFramesOk', 'txFlowOctetsOk', 'rxFlowFramesOk', 'rxFlowOctetsOk', 'LossRate'])
        for Flowname in self.ClientFlowList.keys():
            if not self.ClientLastTXCount.has_key(Flowname):
                self.ClientLastTXCount[Flowname]  = 0
                self.ClientLastRXCount[Flowname]  = 0
            (src_port, src_client, des_port, des_client) = self.ClientFlowList[Flowname]
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (des_port, Flowname))
            TXDelta = flowStats.txFlowFramesOk - self.ClientLastTXCount[Flowname]
            if TXDelta > 0:
                Loss     = (flowStats.txFlowFramesOk - self.ClientLastTXCount[Flowname])  - (flowStats.rxFlowFramesOk - self.ClientLastRXCount[Flowname])
                LossRate = 100.0 * (Loss) / (flowStats.txFlowFramesOk - self.ClientLastTXCount[Flowname])
            else:
                WaveEngine.OutputstreamHDL("\nWarning: Flow %s TX has not changed (Current: %d, Last: %d)\n" % (Flowname, flowStats.txFlowFramesOk, self.ClientLastTXCount[Flowname]),  WaveEngine.MSG_WARNING)
                Loss     = TXDelta
                LossRate = 0.0
            _Detailed = [Flowname, ElapsedTime, src_port, src_client, des_port, des_client, flowStats.txFlowFramesOk, flowStats.txFlowOctetsOk, flowStats.rxFlowFramesOk, flowStats.rxFlowOctetsOk, LossRate]
            self.OLOAD = TXDelta / ( time.time() - self.ClientLastTimeChecked)
            self.FR    = (flowStats.rxFlowFramesOk - self.ClientLastRXCount[Flowname]) / ( time.time() - self.ClientLastTimeChecked)
            
            self.ClientLastTXCount[Flowname] = flowStats.txFlowFramesOk
            self.ClientLastRXCount[Flowname] = flowStats.rxFlowFramesOk

            #Get Latency Buckets
            LatencyCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            DeltaCount   = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            for x in range( 16 ):
                LatencyCount[x] = int(flowStats.getRxFlowLatencyBucket(x))
                

            if self.LatencyBucketCount.has_key(Flowname) and len(self.LatencyBucketValues) == 16:
                LastCount    = self.LatencyBucketCount[Flowname]
                #Compute Jitter for the flow
                Midpoint  = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                Weighting = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                Variance  = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                SumofWeighting = 0.0
                SumOfCount     = 0
                SumofVariance  = 0.0
                for x in range( 16 ):
                    DeltaCount[x] = LatencyCount[x] - LastCount[x]
                    _Detailed.append(DeltaCount[x])
                    Midpoint[x] = self.LatencyBucketValues[x]
                    if x > 0:
                        Midpoint[x] += (self.LatencyBucketValues[x] - self.LatencyBucketValues[x-1]) / 2.0
                    Weighting[x]     = Midpoint[x] * DeltaCount[x]
                    SumofWeighting  += Weighting[x]
                    SumOfCount      += DeltaCount[x]
                self.LatencyAverage = SumofWeighting / SumOfCount

                #Print a warning if the Latency values exceeded Maximum
                if DeltaCount[15] > 0:
                    WaveEngine.OutputstreamHDL("\nWarning: Flow %s has %d packets that latency values exceed %ss " %\
                        (Flowname, DeltaCount[15], Float2EngNotation(self.LatencyBucketValues[14]/1000000.0, 3)) , WaveEngine.MSG_WARNING)

                for x in range( 16 ):
                    Variance[x] = (self.LatencyAverage - Midpoint[x]) * (self.LatencyAverage - Midpoint[x]) * DeltaCount[x]
                    SumofVariance += Variance[x]
                self.LatencyJitter = sqrt(SumofVariance/ float(SumOfCount-1)) / 1000000.0
            else:
                self.LatencyAverage = None
                self.LatencyJitter  = None
            self.LatencyBucketCount[Flowname] = LatencyCount
            WaveEngine.WriteDetailedLog(_Detailed)
            
            #Don't look at % if lost only one packet beacuse there may be a frame in flight
            if LossRate > self.ClientAcceptableLossPercent and Loss > 1 :
                WaveEngine.OutputstreamHDL("\n FAIL Flow %s loss is %.2f%%" % (Flowname, LossRate) , WaveEngine.MSG_WARNING)
                FailedCallQuality = 'Excessive Loss'

            # Check to make sure we are transmitting enough frames
            percent = 100 * self.OLOAD / self.ClientILOAD 
            if self.ClientAcceptableOLOADPercent > percent:
                WaveEngine.OutputstreamHDL("\n FAIL Flow %s TX rate to low (%.1f%% of ILOAD)" % (Flowname, percent) , WaveEngine.MSG_WARNING)
                FailedCallQuality = 'TX congestion'

        self.ClientLastTimeChecked = time.time()
        if FailedCallQuality != None:
            raise WaveEngine.RaiseIterationFailed(FailedCallQuality, ElapsedTime)

    def StopSession(self, ClientGroupName, ServerGroupName):
        #Here is where I stop the flows
        if self.TempGroupName not in flowGroup.getNames():
            WaveEngine.VCLtest("flowGroup.create('%s')" % (self.TempGroupName))
        for eachFlowName in self.ClientFlowList.keys():
            MoveFlow(eachFlowName, ClientGroupName, self.TempGroupName)
        for eachFlowName in self.ServerFlowList.keys():
            MoveFlow(eachFlowName, ServerGroupName, self.TempGroupName)
        WaveEngine.VCLtest("action.stopFlowGroup('%s')" % (self.TempGroupName))
        for eachFlowName in self.ClientFlowList.keys():
            MoveFlow(eachFlowName, self.TempGroupName, ClientGroupName)
        for eachFlowName in self.ServerFlowList.keys():
            MoveFlow(eachFlowName, self.TempGroupName, ServerGroupName)
        self.ActiveStatus = False

##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()

    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
