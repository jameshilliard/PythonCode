#unicast_max_client_capacity
#
# Objective: measure the maximum number of clients that
# an Access Point can hold

import os, sys, time, traceback
from basetest import *
import WaveEngine
import Qlib
from CommonFunctions import *
from optparse import OptionParser
from vcl import *

#Hidden module variables declaration
_lenOfResultCsvFile = 10

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  11)
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        self.Security_None = {'Method': 'NONE'}
        self.Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        self.Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}

        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of '00:00:00:00:00:00'
                       tells the system to pick the first on on the list
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.2',  '255.255.0.0', '192.168.1.1', (), self.Security_None, {})]
        self.DestClients   = [('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.120', '255.255.0.0', '192.168.1.1', (), self.Security_None, self.ClientOptions )]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        ILOADlist -     List of intended loads. The intended load is expressed in frames/sec, 
                        and is applied at the port level. The port load is divided equally 
                        between all source clients on a port. Units: frames/second
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds. 
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration. In this test we shall
                        set the default to 5 seconds between turning the radio off and on so as to make sure that we do
                        not overwhelm the AP while deauthenticating and destroying clients from the previous run and
                        creating clients during the next run.
        """
        self.FrameSizeList  = [512]
        self.ILOADlist      = [10]
        self.Trials         =  1  
        self.TransmitTime   = 10
        self.AgingTime      = 5 
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.FinalResult=0
 
         ##################  Goal Seeking parameters  ##############################
        """
        The goal seeking parameters are used to define how the goal seeking algorithm will arrive at a solution.
        SearchMinimum -           The lower boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values less than this.  Unit is in number of clients.
        SearchMaximum -           The upper boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values higher than this.  The binary search algorithm will use this as the inital value.
                                  If it passed, then the test is complete.  Otherwise the next value is half way between
                                  the SearchMinimum and SearchMaximum. Unit is in number of clients.
        SearchResolutionAbsolute -Determines how precise the search for the final result needs to be.Unit is in number of
                                  clients. The default value is set to 1.
        SearchAcceptLossPercent - Determines how much packet loss will be acceptable in seeking the throughput result. 
                                  Ordinarily, throughput is defined as the maximum forwarding rate with zero frame loss.
                                  However, since 802.11 is a lossy medium it may not be possible in some circumstances to
                                  achieve zero frame loss. This parameter can be used in those situations to allow the search
                                  process to obtain the maximum number of clients goal. 
        """
        self.SearchMaximum           = None
        #self.SearchMinimum           = None
        #self.SearchResolutionAbsolute = 1
        self.SearchAcceptLossPercent = 50.0
        
        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the raw test details.  This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_unicast_maximum_client_capacity.csv'
        self.ReportFilename   = 'Results_unicast_maximum_client_capacity.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_unicast_maximum_client_capacity.csv'
        self.RSSIFilename    = 'RSSI_unicast_max_client_capacity.csv'
        
        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        LearningTime -      Amount of time to spend sending learning frames. 
        SettleTime -        Amount of time the test will wait for activity to settle or propagate through the SUT
                            before taking the measurements. Units: seconds
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results.
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.LearningTime   =   2
        self.SettleTime     =   2
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  100.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =  0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability'] = 0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions - Dictionary of options used to configure data flows. 
        Field Definitions:
          Type - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP', 
        """
        self.FlowOptions    = {'Type': 'UDP', 'PhyRate': 54 }
        self.BiDirectional  = False

########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.65 $' 
        self.date    = '$Date: 2007/06/25 23:59:01 $' 
        # FIXME - Ask Carl why moved it here.  
        self.FlowMap = WaveEngine.CreateFlows_Pairs
        self.finalGraphs = odict.OrderedDict()
        self.sourceGrpList = []
        self.destGrpList = []
        self.createBackupClientsCopy()
        self.mapType = 0 # We only support Ethernet to wireless mapping for now
    
    def getTestName(self):
        
        return 'unicast_max_client_capacity'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        #ThFse are the test specific parameters that get passed down from the GUI for the test execution
        iLoadlist = []
        frameSizeList = []
        iLoadList = waveTestSpecificStore['unicast_max_client_capacity']['ILoadList']
        frameSizeList = waveTestSpecificStore['unicast_max_client_capacity']['FrameSizeList']
        if (len(iLoadList) != 0):
            self.ILOADlist = []
            for eachILoadValue in iLoadList:
                self.ILOADlist.append(int(eachILoadValue))
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
        #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
            if  waveTestStore['LogsAndResultsInfo']['db']== "True":
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
            if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
                if waveTestSpecificStore['unicast_max_client_capacity']['ExpectedClientConnections']:
                    if int (waveTestSpecificStore['unicast_max_client_capacity']['ExpectedClientConnections']) >= 0:
                        self.UserPassFailCriteria['ref_min_client']=int(waveTestSpecificStore['unicast_max_client_capacity']['ExpectedClientConnections'])
                    else:
                        WaveEngine.OutputstreamHDL("\nThe value for the parameter ExpectedClientConnections should be a positive integer\n",WavEngine.MSG_ERROR)
                        raise  WaveEngine.RaiseException
                else:
                    WaveEngine.OutputstreamHDL("\nUser has not given any value for <ExpectedClientConnections> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                    self.UserPassFailCriteria['ref_min_client']=127
        #___________________________________TEL_________________________________________________

        
        #This sets association rate and association timeout on all the client groups
        #All the client groups shall have the same values for all the 2 parameters below
        #because those params are stored in the waveTestStore dict
        self.AssociateRate    = float(waveTestStore['Connection']['AssocRate'])
        self.AssociateTimeout = float(waveTestStore['Connection']['AssocTimeout'])
        # Note: we removed Association Retry from the UI because we think it's
        # confusing the user and doesn't help the variable connection process at
        # all. 
        self.AssociateRetries = 0
        self.ConnectionType = str(waveTestStore['Connection']['ConnectionType'])

        self.mapType = int(waveMappingStore[0])
        self.mapSrcGrp = waveMappingStore[1] 
        self.mapDstGrp = waveMappingStore[2]
        self.oneToManyMapping = 'True' # Only allowed Many to One mapping
        self.BiDirectional  = False # Only allowed unidirectional traffic
        self.SearchMaximum = waveTestSpecificStore['unicast_max_client_capacity']['MaxSearchValue']
        #self.SearchAcceptLossPercent = float(waveTestStore['TestParameters']['LossTolerance'])
        self.createBackupClientsCopy() 
        if self.FlowOptions['Type'] == 'TCP':
            self.flowType = 'biflow'
        else:
            self.flowType = 'flow'
        
        # all good
        return True

    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters ):
        TotalTX = 0
        TotalRX = 0
        PktType = PassedParameters['Type'] 
        for Portname in PassedParameters['CardList']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname), globals())
            if PktType == 'TCP':
                TotalTX += stats.txTcpFramesOkRate
                TotalRX += stats.rxTcpPacketsOkRate
            elif PktType == 'UDP':
                TotalTX += stats.txUdpFramesOkRate
                TotalRX += stats.rxUdpPacketsOkRate
            else:
                TotalTX += stats.txIpPacketsOkRate
                TotalRX += stats.rxIpPacketsOkRate
        ILOADtext = Float2EngNotation(float(PassedParameters['ILOAD']) , self.DisplayPrecision)
        OLOADtext = Float2EngNotation(TotalTX , self.DisplayPrecision)
        FRtext    = Float2EngNotation(TotalRX , self.DisplayPrecision)
        WaveEngine.OutputstreamHDL("\rILOAD=%spkts/sec, OLOAD=%spkts/sec, FR=%spkts/sec, (%2s %4.1f secs)" % (ILOADtext, OLOADtext, FRtext, TXstate, ElapsedTime), WaveEngine.MSG_OK)
        return True

    def startTest(self, FuncRealTime):
        if self.UserPassFailCriteria['user'] == "True":
           self.ResultsForCSVfile.append(('Frame Size', 'ILOAD', 'Trial',
                                       'Theoretical Rate pkts/sec',
                                       'Theoretical Rate bits/sec', 'OLOAD',
                                       'Fwd Rate pkts/sec',
                                       'Fwd Rate bits/sec',
                                       'Num Of Clients',
                                       'Group_BSSID','USC:MC'))
        else: 
           self.ResultsForCSVfile.append(('Frame Size', 'ILOAD', 'Trial',
                                          'Theoretical Rate pkts/sec',
                                          'Theoretical Rate bits/sec', 'OLOAD',
                                          'Fwd Rate pkts/sec',
                                          'Fwd Rate bits/sec',
                                          'Num Of Clients',
                                          'Group_BSSID'))

        # Loop through each Frame Size and Intended Load pair across the
        # number of trials
        for eachSize,eachILOAD in map(None,self.FrameSizeList,self.ILOADlist):  
            if self.SearchMaximum:
            # If the Search Maximum Value is not an integer number
            # then set the maximum value to 255
                if isnum(self.SearchMaximum):
                    _maximum = int(self.SearchMaximum) 
                else:
                    _maximum = 255
                    WaveEngine.OutputstreamHDL(
                        "Warning: Invalid value for max client number '%s', using default: %d\n" % 
                        (self.SearchMaximum, _maximum), 
                        WaveEngine.MSG_WARNING)
            else:
                _maximum = 255
            
            self.copyClients(_maximum)
            self.sourceGrpList = self.SourceClients[:]
            self.destGrpList = self.DestClients[:]  
            numOfAPs = len(self.destGrpList)
                           
            for TrialNumber in range(1, 1 + self.Trials):
                self.numClients = _maximum
                
                # print out the trial #      
                WaveEngine.OutputstreamHDL("\nTrial %d: %s byte frames at %s pkts/sec for %d clients\n" %
                (TrialNumber, eachSize,
                 Float2EngNotation(eachILOAD, self.DisplayPrecision),
                 self.numClients),
                 WaveEngine.MSG_OK)      
                               
                #Test each wireless port sequentially
                for apToTest in range(numOfAPs):   
                    SuccessFlag = "False"                               
                    # Empty the FlowList from previous run
                    self.FlowList = {}                      
                    # Destroy all the flow group names, flow names, mc names and
                    # ec names from a previous run
                    for fgname in flowGroup.getNames():
                        WaveEngine.VCLtest("action.stopFlowGroup('%s')" %(fgname))
                        WaveEngine.VCLtest("flowGroup.destroy('%s')" %(fgname))
                    for flowname in flow.getNames():
                        WaveEngine.VCLtest("%s.destroy('%s')" %(self.flowType, flowname))
                    for flowname in biflow.getNames():
                        WaveEngine.VCLtest("%s.destroy('%s')" %(self.flowType, flowname))                        
                    for name in mc.getNames():
                        WaveEngine.VCLtest("mc.deauthenticate('%s', %d)" %(name, 1))
                        WaveEngine.VCLtest("mc.destroy('%s')" %(name))
                    for name in ec.getNames():
                        WaveEngine.VCLtest("ec.destroy('%s')" %(name))
                            
                    wifiPortList = []
                    
                    self.VerifyBSSID_MAC()
                    
                    # Build a list of the wifi ports from the source and destination
                    # groups as we need to turn the radio off on 
                    for eachSrcGroup in range(0,len(self.SourceClients)):
                        srcPortName = self.SourceClients[eachSrcGroup][1]
                        if srcPortName in self.CardMap.keys():
                            x = self.CardMap[srcPortName]
                            if len(x) == 4:
                                wifiPortList.append(srcPortName)    
                    for eachDestGroup in range(0,len(self.DestClients)):
                        destPortName = self.DestClients[eachDestGroup][1]
                        if destPortName in self.CardMap.keys():
                            x = self.CardMap[destPortName]
                            if len(x) == 4:
                                wifiPortList.append(destPortName)
                    #Force the radio off to make sure the AP does not see the card
                    #WaveEngine.OutputstreamHDL("Turning radio off\n", WaveEngine.MSG_OK)
                    for eachWifiPort in wifiPortList:
                        port.read(eachWifiPort)
                        port.setRadio('off')
                        port.write(eachWifiPort)
                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')
                    # turn the radio on again
                    for eachWifiPort in wifiPortList:
                        port.read(eachWifiPort)
                        port.setRadio('on')
                        port.write(eachWifiPort)
                    FrameRate = float(eachILOAD)
                    self.FrameSize = int(eachSize)
                    # use the same mac addresses for the clients
    
                    # Create clients for the test
                    # Pop the first entry in the dest grp list, since we're testing
                    # the APs sequentially.
                    
                    self.DestClients = [tuple(self.destGrpList[apToTest])] 
                    srcClientTuples = self._createDictOfClientTuples(self.SourceClients) 
                    destClientTuples = self._createDictOfClientTuples(self.DestClients)         
                    srcClients, _ = self.createClients(srcClientTuples)
                    destClients, _ = self.createClients(destClientTuples)
                    self._updateClientLists(srcClients, destClients)
                            
                    WaveEngine.WriteAPinformation(self.ListOfClients)
                    (RetVal, McConnectedCtr, EcConnectedCtr) = self.connectClientsSeq()
                    if self.mapType != 3:
                        connectedCtr = McConnectedCtr
                    else:
                        connectedCtr = EcConnectedCtr
                    if self.mapType == 2 or self.mapType == 3:
                        connectedCtr = connectedCtr / 2
                    if connectedCtr == 0:
                        # if failed to connect all mc, terminate the test
                        WaveEngine.OutputstreamHDL(
                           "\nFailed to connect sufficient number of clients to run the test %s" % 
                           '- terminating test\n', WaveEngine.MSG_ERROR)
                        raise  WaveEngine.RaiseException
                    if RetVal < 0:
                        # if failed, it means we were only able to connect x clients
                        # If y is the number of clients created by CreateClients(),
                        # we need to remove y-x clients from ListofSrcClient and
                        # ListofDesClient and update ListOfClients
                        self.destroyClients(connectedCtr)
                    
                    self.numClients = connectedCtr
                    # have to update the # of clients in self.DestClients tuple
                    [(BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, 
                     Gateway, (i,j,k), Security, Options)] = self.DestClients    
                    i = connectedCtr                 
                    self.DestClients = [(BaseName, PortName, BSSID, Base_MAC, Base_IP, 
                                          Subnet, Gateway, (i,j,k), Security, Options)]
                    FrameRatePerPort = FrameRate # / float(self.numClients)
                    NumFrames = -1    # Set to the largest positive integer for the
                                      # 64-bit counter in VCL
                    
                    TempDict = {'FrameSize': self.FrameSize,
                                'IntendedRate': FrameRate,
                                'NumFrames': NumFrames,
                                'RateMode': 'pps'}
                    self.FlowOptions.update(TempDict)
                    # Configure flows for the test
                    self.configureFlows(1, 'One To Many', connectBiflow=False)      
                    
                    # If TCP traffic, connect biflow sequentially
                    if self.FlowOptions['Type'] == 'TCP':
                        if self.connectTcpSeq() == 0:
                            # if all TCP connects failed, terminate the test
                            WaveEngine.OutputstreamHDL(
                                "\nTCP connect operation failed on all client(s) - terminating test\n", WaveEngine.MSG_ERROR)
                            raise  WaveEngine.RaiseException                            
                    
                    # only do ARP for non TCP traffic
                    if self.flowType != 'biflow':              
                        #Do arp exchanges for the test
                        arpFailed = False
                        while self.numClients > 0 and \
                              WaveEngine.ExchangeARP(self.FlowList,"XmitGroup",
                                                     self.ARPRate,
                                                     self.ARPRetries,
                                                     self.ARPTimeout) < 0:
                            # if ExchangeARP failed, disassoc 1 client and retry ARP
                            WaveEngine.OutputstreamHDL(
                            "\nFailed to receive all ARP response(s) %s" % 
                            '', WaveEngine.MSG_ERROR)
                            
                            WaveEngine.VCLtest("flowGroup.read('%s')" % 'XmitGroup')
                            arpCount = flowGroup.doArpStatus('XmitGroup')
                            # if all ARPs failed, terminate the test
                            if arpCount == 0:
                                arpFailed = True
                                break
                            
                            WaveEngine.OutputstreamHDL(
                            "\nDisassociating 1 client and retrying ARPs %s" %
                            '', WaveEngine.MSG_OK) 
                            flowListKeys = self.FlowList.keys()
                            flowListKeys.sort()
                            self.destroyFlows([flowListKeys[-1],])   
                        
                        if arpFailed == True:
                            # if all ARPs failed, terminate the test
                            WaveEngine.OutputstreamHDL(
                            "\nARP Failed on all client(s) %s" % 
                            '- terminating test\n', WaveEngine.MSG_ERROR)
                            self.numClients = 0
                            raise  WaveEngine.RaiseException                       
                    
                    connectedCtr = self.numClients
                    
                    # Keep on retrying until num of client is 0
                    while self.numClients > 0:                                 
                        TheoreticalMFR = WaveEngine.SUTtheoreticalThroughput(
                                         self.ListOfClients, self.FlowList, '--',
                                         self.FrameSize,self.FlowOptions['PhyRate'])                                                     
                                        
                        WaveEngine.ClearAllCounter(self.CardList)
                        WaveEngine.OutputstreamHDL(
                        "\nTrial %d: Transmitting %s byte frames at %s pkts/sec for %d clients\n"
                                                   % (TrialNumber, self.FrameSize,
                                                      Float2EngNotation(FrameRate,
                                                      self.DisplayPrecision),
                                                      self.numClients),
                                                      WaveEngine.MSG_OK)
                        bssidName = self.DestClients[0][2]
                        clientcontext='%s_%s'%(self.DestClients[0][0],bssidName)
                        WaveEngine.WriteDetailedLog([''])
                        WaveEngine.WriteDetailedLog(['FrameSize:', self.FrameSize,
                                                     'ILOAD:', FrameRate,
                                                     'Trial:', TrialNumber,
                                                     'Number of Clients:',self.numClients,
                                                     'BSSID:', bssidName])
                        time.sleep(0.8)
                        PassedParam = {'ILOAD': FrameRate,
                                       'CardList': self.CardList,
                                       'Type': self.FlowOptions['Type']}
                        retVal = self._transmitIteration(self.TransmitTime,
                                                     self.SettleTime,
                                                     self.UpdateInterval,
                                                     "XmitGroup", True,
                                                     FuncRealTime, PassedParam)
                        if retVal:
                            self.TransmitTime = retVal
                            
                        if self.FlowOptions['Type'] == 'TCP':
                            # Wait for 2 seconds to make sure we get all the TCP packets
                            WaveEngine.Sleep(2, 'TCP settling time')                         
                                                   
                        WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
                        
                        # This is a hack since flows counter do not work with less
                        # than 88 byte frames
                        if self.FrameSize < 88:
                            (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = \
                            WaveEngine.MeasurePort_OLOAD_FR_LOSSRate(self.CardList,
                                                                     self.TransmitTime,
                                                                     self.FlowOptions['Type'],self.FrameSize)
                        else:
                            (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = \
                            WaveEngine.MeasureFlow_OLOAD_FR_LossRate(self.FlowList,
                                                                     self.TransmitTime,self.FrameSize)                   
                        
                        WaveEngine.OutputstreamHDL(
                            "Completed: Forwarding rate for %d byte frames for %d clients is %.1f (or %s bits/sec)\n" %
                            (self.FrameSize, self.numClients, FR,
                             Float2EngNotation(FR_bps, self.DisplayPrecision)),
                             WaveEngine.MSG_SUCCESS)
                        
                        # check frame loss per client
                        (result, frameLossClient) = self.checkFrameLoss()
                        
                        if result == 'Failed':
                            WaveEngine.OutputstreamHDL(
                            "Frame Loss Rate for one of the client is %.2f%%\nFrame loss percentage is greater than accepted loss tolerance\n" %
                            (frameLossClient), WaveEngine.MSG_SUCCESS)
                            
                            # VPR 4668: if after 10% of the connected clients have been disconnected 
                            #           and the DUT still has unacceptable packet loss (tolerance 
                            #           should be 50%), end the test with a warning.
                            if ((connectedCtr - self.numClients) / float(connectedCtr)) >= 0.1:
                                WaveEngine.OutputstreamHDL("Test aborted due to unacceptable packet loss after disconnecting 10%% of maximum connected clients.\nMaximum number of connected clients: %d." % (self.numClients), WaveEngine.MSG_WARNING)
                                self.numClients = 0
                                if self.UserPassFailCriteria['user'] == "True":
                                    TestResult='FAIL'  
                                    self.ResultsForCSVfile.append(
                                    (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                                    TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                                    self.numClients, clientcontext,TestResult))
                                else:
                                   self.ResultsForCSVfile.append(
                                       (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                                       TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                                       self.numClients, clientcontext))
                                if TestResult == 'FAIL':
                                     self.FinalResult=3

                                return
                            """
                            # VPR 4660: check if the AP is still alive by scanning the BSSIDs and
                            #           compare them with the BSSIDs on the cache
                            WaveEngine.OutputstreamHDL("Scanning for BSSIDs:%s" %(''), WaveEngine.MSG_OK)
                            grpBSSIDKeys = self.grpBssidDict.keys()
                            currPort2BSSID = WaveEngine.GetBSSIDdictonary(self.SrcCardList+self.DesCardList, timeout=1)
                            for grpname in grpBSSIDKeys:
                                portname, bssid = self.grpBssidDict[grpname]
                                if currPort2BSSID.has_key(portname):
                                    for item in currPort2BSSID[portname]:
                                        if item == bssid:
                                            break
                                    else:
                                        WaveEngine.OutputstreamHDL("%sCouldn't locate the desired BSSID, the AP is no longer responding. Test stopped." %
                                                                   (''), WaveEngine.MSG_ERROR)
                                        self.numClients = 0
                                        self.ResultsForCSVfile.append(
                                            (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                                            TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                                            self.numClients, bssidName))
                                        return 
                                else:
                                    WaveEngine.OutputstreamHDL("%sCouldn't locate the desired BSSID, the AP is no longer responding. Test stopped." %
                                                               (''), WaveEngine.MSG_ERROR)
                                    self.numClients = 0
                                    self.ResultsForCSVfile.append(
                                        (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                                        TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                                        self.numClients, bssidName))
                                    return                                 
                            """                             
                            # Disassociate 1 client and retry again
                            WaveEngine.OutputstreamHDL(
                                "Disassociating %d client and retrying\n" % (1), WaveEngine.MSG_SUCCESS)                            
                            flowListKeys = self.FlowList.keys()
                            flowListKeys.sort()
                            self.destroyFlows([flowListKeys[-1],])                        
                        else:
                            WaveEngine.OutputstreamHDL(
                            "Average frame loss rate for %d clients is %.2f%%\n" %
                            (self.numClients,FrameLossRate), WaveEngine.MSG_SUCCESS)
                            SuccessFlag = "True"
                            break
                    if  self.UserPassFailCriteria['user'] == "True":
                        if  self.numClients >= int (self.UserPassFailCriteria['ref_min_client']) :
                            TestResult='PASS'
                            WaveEngine.OutputstreamHDL("Test has achieved the Pass/Fail criteria configured by the user: User-%s,Achieved-%s\n" %(int(self.UserPassFailCriteria['ref_min_client']),self.numClients),WaveEngine.MSG_SUCCESS)
                        else:
                            TestResult='FAIL'  
                            WaveEngine.OutputstreamHDL("Test has failed to achieve the Pass/Fail criteria configured by the user: User-%s,Achieved-%s\n" %(int(self.UserPassFailCriteria['ref_min_client']),self.numClients),WaveEngine.MSG_WARNING)
                       
                        self.ResultsForCSVfile.append(
                        (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                        TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                        self.numClients, clientcontext,TestResult))
                        if TestResult == 'FAIL':
                                self.FinalResult=3
                    else:  
                       self.ResultsForCSVfile.append(
                           (self.FrameSize, FrameRate, TrialNumber, TheoreticalMFR,
                           TheoreticalMFR * 8 * self.FrameSize, OLOAD, FR, FR_bps,
                           self.numClients, clientcontext))
                    # Print results for that frame size
                    if SuccessFlag == "False":
                        WaveEngine.WriteDetailedLog(['FrameSize:', self.FrameSize,
                                                     'ILOAD:', FrameRate,
                                                     'Trial:', TrialNumber,
                                                     'Number of Clients:','None within range',
                                                     'PASS/FAIL:','FAIL'])
                        WaveEngine.OutputstreamHDL(
                        "FAILED: Current number of clients = %d, Framesize = %d Bytes, Intended Load = %.2f pkts/sec - failed on this pass.\n" %
                        (self.numClients,int(self.FrameSize),FrameRate), 
                         WaveEngine.MSG_WARNING)
                    else:
                        WaveEngine.WriteDetailedLog(['FrameSize:', self.FrameSize,
                                                     'ILOAD:', FrameRate,
                                                     'Trial:', TrialNumber,
                                                     'Number of Clients:', self.numClients,
                                                     'PASS/FAIL:','PASS'])
                        WaveEngine.OutputstreamHDL(
                        "Completed: Maximum Number of Clients = %d at Framesize = %d Bytes and Intended Load = %.2f pkts/sec.\n" %
                        (self.numClients,self.FrameSize,FrameRate), 
                         WaveEngine.MSG_SUCCESS)
                    if self.flowType == 'biflow':
                        # disconnect all TCP flows
                        if self.connectTcpFlows(self.FlowList, operation='disconnect') < 0:
                            WaveEngine.OutputstreamHDL("Error: failed to disconnect TCP flows", WaveEngine.MSG_ERROR)
                       
############################## connectClientsSeq ############################### 
# Wrapper function for _connectClientsSeq()
    def connectClientsSeq(self):
        return self._ConnectClientsSeq(self.ListofSrcClient, self.ListofDesClient)

############################# _connectClientsSeq ############################### 
# Connects clients to the AP sequentially
# Input:
# - SrcClients, DestClients
# Returns: (ElapsedTime, McConnectedCtr, EcConnectedCtr)
# ElapsedTime: Positive number is time in Seconds to complete all Assocations
#              Negative number means not all clients reached expected state
# McConnectedCtr: # of connected mobile clients
# EcConnectedCtr: # of connected Ethernet clients
    def _ConnectClientsSeq (self, SrcClients, DestClients):
        ElapsedTime      = -1
        NoErrFlag        = "True" 
        noSummary        = True
        ClientListLength = len(SrcClients.keys()) + len(DestClients.keys())
        McConnectedCtr   = 0            
        EcConnectedCtr   = 0
        ClientTimeout    = float(self.AssociateTimeout)   
        retry            = 1
        WaveEngine.OutputstreamHDL("\nAttempting to connect the client(s)%s" % '', WaveEngine.MSG_OK)
    
        SrcKeys = SrcClients.keys() # Fetch all the ec & mc client's name 
        DestKeys= DestClients.keys()
        SrcKeys.sort()              # sort them
        DestKeys.sort()
        StartTime = time.time()
        
        if self.oneToManyMapping == 'True':
            # For One To Many, we try to connect the Source clients first
            for SrcClientName in SrcKeys:     
                                        # Try to connect the Source client
                ConnResult = WaveEngine.AggregateConnectClients({SrcClientName:SrcClients[SrcClientName]}, 
                                                                retry, ClientTimeout, noSummary) 
                if ConnResult >= 0:     # if successful, try to connect next client
                    if SrcClients[SrcClientName][2] == 'mc':
                        McConnectedCtr += 1
                    else:
                        EcConnectedCtr += 1
                else:
                    NoErrFlag = "False" # if drop here, we failed to connect 
                    break            
            else:     
                # if drop here, we managed to connect all Source clients
                for DestClientName in DestKeys:   
                                            # Try to connect the dest client
                    ConnResult = WaveEngine.AggregateConnectClients({DestClientName:DestClients[DestClientName]}, 
                                                                    retry, ClientTimeout, noSummary)                
                    if ConnResult >= 0:     # if successful, try to connect next client
                        if DestClients[DestClientName][2] == 'mc':
                            McConnectedCtr += 1
                        else:
                            EcConnectedCtr += 1                        
                    else:                     
                        NoErrFlag = "False" # if drop here, we failed to connect 
                        break                 
        else:
            for SrcClientName, DestClientName in zip(SrcKeys, DestKeys):   
                                        # Try to connect the source client
                ConnResult = WaveEngine.AggregateConnectClients({SrcClientName:SrcClients[SrcClientName]}, 
                                                                retry, ClientTimeout, noSummary) 
                if ConnResult >= 0:     # if successful, try to connect dest client
                    if SrcClients[SrcClientName][2] == 'mc':
                        McConnectedCtr += 1
                    else:
                        EcConnectedCtr += 1                    
                    ConnResult = WaveEngine.AggregateConnectClients({DestClientName:DestClients[DestClientName]}, 
                                                                    retry, ClientTimeout, noSummary)                   
                    if ConnResult >= 0:
                        if DestClients[DestClientName][2] == 'mc':
                            McConnectedCtr += 1
                        else:
                            EcConnectedCtr += 1                        
                        continue        # successful connecting client pair, do next one  
                                        
                NoErrFlag = "False"     # if drop here, we failed to connect 
                break

        if NoErrFlag == "True":
            ElapsedTime = time.time() - StartTime
            WaveEngine.OutputstreamHDL("\nCompleted: All clients were connected in %.2f seconds" % \
               (ElapsedTime), WaveEngine.MSG_SUCCESS)                             
        else:
            WaveEngine.OutputstreamHDL("\n%d client(s) connected, %d failed" % \
               (McConnectedCtr+EcConnectedCtr, ClientListLength-McConnectedCtr-EcConnectedCtr), WaveEngine.MSG_WARNING)   
                  
        WaveEngine.OutputstreamHDL("\nSetting up the flow for %d client(s)" % (McConnectedCtr+EcConnectedCtr), WaveEngine.MSG_OK)        
            
        return (ElapsedTime, McConnectedCtr, EcConnectedCtr)

################################ connectTcpSeq ################################# 
# Connects TCP flow sequentially
# Input:
# Output: number of successful connection
    def connectTcpSeq(self):
        failedList = []
        WaveEngine.OutputstreamHDL("\nAttempting TCP connect operation", WaveEngine.MSG_OK)
        flowLen = len(self.FlowList)
        flowListKeys = self.FlowList.keys()
        flowListKeys.sort()
        failedCtr = 0
        #startTime = vclTime()
        for flowName in flowListKeys:
            (src_port, src_client, des_port, des_client) = self.FlowList[flowName]
            connectTime = vclTime()
            if WaveEngine.ConnectBiflow([flowName,], clientTimeOut=10, totalTimeOut=0, 
                                       expectedState=WaveEngine.BIFLOW_STATE_READY, 
                                       operation='connect', noSummary=True) < 0:
                # if drop here, we failed to connect
                WaveEngine.OutputstreamHDL("\nFailed to connect %s, destroying the flow and mobile client associated with it" % (flowName), WaveEngine.MSG_ERROR)
                self.destroyFlows([flowName,])
                failedCtr += 1
            else:
                WaveEngine.OutputstreamHDL("\r%.2fsec %s forward & reverse flows achieved %s state" % 
                                          ((vclTime()-connectTime), flowName, WaveEngine.BIFLOW_STATE_READY), WaveEngine.MSG_OK)

        WaveEngine.OutputstreamHDL("\nCompleted %d TCP connect operation" % (self.numClients), WaveEngine.MSG_OK)                    
        if failedCtr > 0:
            WaveEngine.OutputstreamHDL("\nFailed to connect %d client(s)\n" % (failedCtr), WaveEngine.MSG_OK)
        
        return self.numClients
        
################################ destroyClient ################################# 
# Destroy flows and the mobile clients associated with them
# Assumption: unidrectional Ethernet to wireless traffic, mapping is one to many, 
# Input:
# - flowNameList: list of flow names
    def destroyFlows(self, flowNameList):
        for flowName in flowNameList:
            (src_port, src_client, des_port, des_client) = self.FlowList[flowName]
            if self.flowType == 'biflow':
                if WaveEngine.ConnectBiflow([flowName,], clientTimeOut=10, totalTimeOut=0, 
                                           expectedState=WaveEngine.BIFLOW_STATE_IDLE, 
                                           operation='disconnect', noSummary=True) < 0:
                    # if drop here, we failed to connect
                    WaveEngine.OutputstreamHDL("\nFailed to disconnect %s" % (flowName), WaveEngine.MSG_ERROR)            
            WaveEngine.VCLtest("%s.destroy('%s')" % (self.flowType, flowName))
            WaveEngine.VCLtest("mc.read('%s')" % (des_client))     
            Status = mc.getState() 
            if Status == WaveEngine.ClientState80211Auth or \
               Status == WaveEngine.ClientStateAssoc or \
               Status == WaveEngine.ClientState8021xAuth or \
               Status == WaveEngine.ClientStateDhcp:
                WaveEngine.VCLtest("mc.deauthenticate('%s', %d)" % (des_client, 0))
            #only destroy the dest client, which is a wifi client. 
            #we don't need to destroy the source client because it's one to
            #many mapping
            WaveEngine.VCLtest("mc.destroy('%s')" % (des_client))   
            
            del self.FlowList[flowName] # Remove it from the flow list 
            del self.ListofDesClient[des_client]
            self.numClients -= 1 # decrement the client counter
            self.ListOfClients = {} # update the client lists
            self.ListOfClients.update(self.ListofSrcClient)
            self.ListOfClients.update(self.ListofDesClient)
            self.TotalClients  = len(self.ListOfClients)            
            

################################ checkFrameLoss ################################
# check the frame loss rate per client, return False if frame loss is unacceptable
# this method also deauth and destroy client with 100% frame loss
    def checkFrameLoss(self):
        res = ('Pass', 0)
        for flowName in self.FlowList.keys():
            (src_port, src_client, des_port, des_client) = self.FlowList[flowName]
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (src_port, flowName))
            TXframes = flowStats.txFlowFramesOk
            WaveEngine.VCLtest("flowStats.read('%s','%s')" % (des_port, flowName))
            RXframes = flowStats.rxFlowFramesOk
            
            if TXframes == 0 or RXframes == 0:
                #if drop here, destroy flow, deauth and destroy client 
                WaveEngine.OutputstreamHDL(
                   "\nFrame loss for %s is 100%%. Destroying the client and the flow associated with it." % (des_client), WaveEngine.MSG_OK)
                self.destroyFlows([flowName,])
                lossPct = 100
            elif RXframes > TXframes:
                lossPct = 0
            else:
                lossPct = ((TXframes-RXframes)/ float(TXframes)) * 100
            if lossPct > self.SearchAcceptLossPercent:
                loss = lossPct
                res = ('Failed', loss)
               
        return res

################################ destroyClients ################################
# removed the client pairs (mc/ec) from VCL
# Input:
# - ConnectedCtr: number of connected client pairs
# This method will keep ConnectedCtr client pairs and destroy the rest
    def destroyClients(self, ConnectedCtr):
        WaveEngine.DestroyClients(self.ListofSrcClient[ConnectedCtr:])
        WaveEngine.DestroyClients(self.ListofDesClient[ConnectedCtr:])                                  
        self.ListofSrcClient = self.ListofSrcClient[:ConnectedCtr]
        self.ListofDesClient = self.ListofDesClient[:ConnectedCtr]
        self.ListOfClients = {}
        self.ListOfClients.update(self.ListofSrcClient)
        self.ListOfClients.update(self.ListofDesClient)
        self.TotalClients  = len(self.ListOfClients) 
  
    def createBackupClientsCopy(self):
        #This is to copy from the original client values,before verfiying the BSSID MAC values
        self.OrigSourceClients = self.SourceClients[:]
        self.OrigDestClients = self.DestClients[:]
        
    def copyClients(self,Count):
        for x in range(len(self.SourceClients)):
            (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, IncrTuple, Security, Options) = self.OrigSourceClients[x]
            if len(IncrTuple) == 3:
                (n, incMAC, incIP) = IncrTuple
            else:
                incIP  = '0.0.0.1'
                incMAC = '0:0:0:0:0:1'
            if Base_MAC.upper() == 'DEFAULT':
                incMAC = 'DEFAULT'
            if self.oneToManyMapping == 'True':    
                self.SourceClients[x] = (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, (1, incMAC, incIP), Security, Options)
            else:
                self.SourceClients[x] = (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, (Count, incMAC, incIP), Security, Options)                
        for x in range(len(self.DestClients)):
            (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, IncrTuple, Security, Options) = self.OrigDestClients[x]
            if len(IncrTuple) == 3:
                (n, incMAC, incIP) = IncrTuple
            else:
                incIP  = '0.0.0.1'
                incMAC = '0:0:0:0:0:1'
            if Base_MAC.upper() == 'DEFAULT':
                incMAC = 'DEFAULT'
            self.DestClients[x] = (BaseName, PortName, BSSID, Base_MAC,  Base_IP, Subnet, Gateway, (Count, incMAC, incIP), Security, Options)
        WaveEngine.OutputstreamHDL("\nSetting test for %d clients per card\n" % (Count), WaveEngine.MSG_SUCCESS)        
                
    def PrintReport(self):
        import os.path
        #Strip off the DUT info
        Results = []
        Results_PF=[] 
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                if  self.UserPassFailCriteria['user'] == "True":
                    Results_PF.append(line)
                    Results.append(line[:-1])
                else:
                   Results.append(line)
            if len(line) == 0:
                flag = True
        
        # parse data and calculate min/max/avg for number of clients across multiple trials
        _trialList = []
        _list4graph= []
        for eachLine in Results:
        # strip off irrelevant headings
            if len(eachLine) != _lenOfResultCsvFile:
                continue
            
            (FrameSize, FrameRate, TrialNumber, Theroy_FPS, Theroy_BPS, OLOAD_FPS, 
             FR_FPS, FR_BPS, NumberOfClients, bssidName) = eachLine
             
            if isnum(FrameSize) == False:
                continue
            
            FrameSize =int(FrameSize)
            FrameRate = float(FrameRate)
            if TrialNumber > len(_trialList):
                _trialList.append({}) 

            _list4graph.append({})
            #WaveEngine.OutputstreamHDL("The values of bssidname are : %s" %(bssidName), WaveEngine.MSG_OK) 
            _list4graph[TrialNumber-1][bssidName] = NumberOfClients 
            try:
                _trialList[TrialNumber-1][bssidName.split('_')[2]] = NumberOfClients
            except:
                _trialList[TrialNumber-1][bssidName] = NumberOfClients 
        
        if _trialList == []:
            return
        
        # Text Paragraphs
        Overview= "The Maximum Client Capacity test measures the number of clients that can successfully "\
                  " associate with APs in the SUT and transfer traffic to the distribution system (wired "\
                  "LAN). It measures the ability of APs in the SUT to support a large number of simultaneously "\
                  "connected users."
        FR_text1= "The number of clients graph shows the minimum, maximum and average number of "\
                  "clients across multiple trials that the SUT could handle on a given frame size and "\
                  "intended load with the traffic passing through the SUT within an acceptable loss tolerance of 50%."
        FR_text2= "The graph shown below depict the maximum number of  "\
                  "clients that could be associated across multiple trials and were able "\
                  "to pass traffic within the permissible loss tolerance of 50%."
        TTCliMap= "The test topology is shown below. Traffic is transmitted in the direction of the "\
                  "arrows. The test client port identifiers and IP addresses are indicated in the boxes, "\
                  "together with the security mode and channel ID for WLAN clients."
        Method1 = "This test reports the maximum number of clients that can successfully associate with "\
                  "each AP in the SUT and transfer data. The criterion for a successful association of a client "\
                  "is that it should be able to transfer its share of the aggregate offered load at the "\
                  "pre-determined acceptable loss tolerance of 50%, and remain associated over the duration of the "\
                  "trial."
        Method2 = "The test begins by attempting to associate with the selected AP in the SUT a relatively large "\
                  "number of clients. The clients will be connected in a serial fashion up until the point where the "\
                  "AP no longer associates additional clients. The number of connected clients determines "\
                  "the maximum number of associations the AP can achieved."
        Method3 = "Once this upper limit has been determined, the test then performs any necessary learning "\
                  "traffic transmission, and then runs test traffic through the selected AP from the clients "\
                  "for the specified transmit duration and at the specified intended load (ILOAD)."\
                  "At the end of the transmit duration, the frame loss rate for each client is calculated; "\
                  "If the frame loss per client falls below the acceptable loss tolerance, the maximum number of "\
                  "clients has been found. If the frame loss per client is higher than the permissible value, "\
                  "then one of the client is disassociated and the test again runs "\
                  "traffic through the SUT and measures frame loss for each client. This process of "\
                  "disassociating clients, running traffic and measurement continues until the frame loss "\
                  "falls below the acceptable loss tolerance, or 10% or more clients have been disassociated."
        Method3b= "If there are multiple APs in the SUT, the process described above is done sequentially for each AP. "\
                  "When the test completes, the number of clients for each SUT will be reported as well as the minimum, maximum and "\
                  "average number of clients from all APs in the SUT."
        Method4 = "The traffic load presented to the AP is configured to be unidirectional from "\
                  "Ethernet to wireless. The specified ILOAD "\
                  "is applied for each of the wireless clients presented to the SUT. This test can "\
                  "be performed on a SUT with multiple APs, in which case the number of wireless clients "\
                  "will be evenly distributed across all of the APs."
        Method5 = "Specification of an excessive ILOAD (e.g., one that is greater than the aggregate "\
                  "throughput possible with the SUT) can cause this test to never converge, because the "\
                  "traffic loss will then always exceed the acceptable loss tolerance regardless of the "\
                  "number of clients. It is recommended that a throughput or maximum forwarding rate test "\
                  "be performed first on the SUT, and the ILOAD set accordingly."
        Method6 = "The measurements are repeated (with the same test conditions and configuration parameter "\
                  "each time) if the number of trials is greater than 1. The detailed results are reported "\
                  "separately for each trial, and averaged into the above chart."
        RSSIdetails1="SUT details are given below. The received signal strength indication (RSSI) from "\
                     "the SUT is sampled on each port at the start of each trial; the values in the"\
                     " table are the average over all trials." 
        RSSIdetails2="Desired RSSI values are in the range -25 dBm to -35 dBm. If the RSSI is not in "\
                    "this range, the external attenuation should be modified to bring it into this "\
                    "range. Under no circumstances should the RSSI be allowed to drop below -60 dBm "\
                    "or above -15 dBm."
        DetailedRes="The Intended Load (ILOAD) is the number of frames/second intended for each wireless client."\
                    "The Offered Load (OLOAD) is the aggregate load that is divided evenly "\
                    "among all of the wireless clients that was measured in the test."
        
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return

        MyReport.Title("Maximum Client Capacity Report", self.DUTinfo, self.TestID)
        MyReport.InsertHeader("Overview")
        MyReport.InsertParagraph(Overview)
        MyReport.InsertHeader("Clients Summary")
        MyReport.InsertParagraph(FR_text1)
        
        #generate BSSID list
        _bssidList = _trialList[0].keys()
        _bssidList.sort()
            
        if self.Trials == 1:
            _numOfClientList = []
            _trialMaxVal = []
            _trialAvgVal = []
            _trialMinVal = []
            minVal = WaveEngine.MAXtxFrames
            maxVal = 0
            avgVal = 0
            for item in _bssidList:
                i = _trialList[0][item]
                _numOfClientList.append(i)
                minVal = min(minVal, i)
                maxVal = max(maxVal, i)
                avgVal += i                
            avgVal = avgVal / float(len(_bssidList))
            _trialMinVal.append(minVal)
            _trialAvgVal.append(avgVal)                
            _trialMaxVal.append(maxVal)
                
            # Generate num of client vs BSSIDs graph
            if len(_list4graph[0].keys()) <=11:
                    graphSingleTrialClientVsBssid = Qlib.GenericGraph( 
                        _list4graph[0].keys(),  # x values which is the BSSID
                        "Client Context",     # x label
                        list((_list4graph[0].values(),)), # list of y values
                        "Number of Clients",    # y label
                        "Number of Clients vs. BSSID\nFrame Size: %d bytes, Frame Rate: %d fps" % (FrameSize,FrameRate), # graphtitle
                        ['Bar'], # graph type
                        yAxisDigits = 0, dataLblDigits = 0
                        ) 
                    MyReport.InsertObject(graphSingleTrialClientVsBssid)
                    self.finalGraphs["Number of Clients vs. BSSID - frame size: " + str(FrameSize) + " bytes, frame rate: " + str(FrameRate) + "fps"] = graphSingleTrialClientVsBssid                              

            if len(_bssidList) > 1:
                # Generate aggregate graph
                xVal = "%s bytes @ %s fps" % (str(FrameSize),str(FrameRate))
                graphSingleTrialAggregate = Qlib.GenericGraph( 
                    [xVal],  # x values which is the BSSID
                    "",     # x label
                    list((_trialMinVal, _trialAvgVal, _trialMaxVal)), # list of y values
                    "Number of Clients",    # y label
                    "Min, Avg & Max Number of Client Across All BSSIDs", # graphtitle
                    ['Bar'], # graph type
                    [["Min"],["Avg"],["Max"]], # list of legend name
                    yAxisDigits = 2, dataLblDigits = 2
                )                
                MyReport.InsertObject(graphSingleTrialAggregate)
                self.finalGraphs["Min, Avg & Max Number of Client Across All BSSIDs"] = graphSingleTrialAggregate                              
                        
        else:
            #MyReport.InsertPageBreak()

            _trialBssidVal = odict.OrderedDict()
            _trialMaxVal = []
            _trialAvgVal = []
            _trialMinVal = []
            _trialNumList = []
            for trial in range(len(_trialList)):
                _trialNumList.append(str(trial+1))
                minVal = WaveEngine.MAXtxFrames
                maxVal = 0
                avgVal = 0
                for item in _bssidList:
                    i = _trialList[trial][item]
                    if not _trialBssidVal.has_key(item):
                        _trialBssidVal[item] = []
                    _trialBssidVal[item].append(i)
                    minVal = min(minVal, i)
                    maxVal = max(maxVal, i)
                    avgVal += i                
                avgVal = avgVal / float(len(_bssidList))
                _trialMinVal.append(minVal)
                _trialAvgVal.append(avgVal)                
                _trialMaxVal.append(maxVal)            
            
            if len(_bssidList) == 1:  
                minVal = WaveEngine.MAXtxFrames
                maxVal = 0
                avgVal = 0 
                for key, item in _trialBssidVal.iteritems():
                    for val in item:
                        minVal = min(minVal, val)
                        maxVal = max(maxVal, val)
                        avgVal += val     
                    avgVal = avgVal / float(len(item))                    
                # Generate aggregate graph
                #FIXME: Qlib doesn't like xVal format below
                xVal = "%s bytes @ %s fps" % (str(FrameSize),str(FrameRate))
                graphMultiTrialAggregate = Qlib.GenericGraph( 
                    [xVal],  # x values which is the BSSID
                    "",     # x label
                    list(([minVal], [avgVal], [maxVal])), # list of y values
                    "Number of Clients",    # y label
                    "Min, Avg & Max Number of Client", # graphtitle
                    ['Bar'], # graph type
                    [["Min"],["Avg"],["Max"]], # list of legend name
                    yAxisDigits = 0, dataLblDigits = 2
                )                
                MyReport.InsertObject(graphMultiTrialAggregate)
                self.finalGraphs["Min, Avg & Max Number of Client"] = graphMultiTrialAggregate               
            else:
                #generate aggregate graph
                graphMultiTrialAggregate = Qlib.GenericGraph( 
                    _trialNumList,  # Trials
                    "Trials",     # x label
                    list((_trialMinVal, _trialAvgVal, _trialMaxVal)), # list of y values
                    "Number of Clients",    # y label
                    "Min, Avg & Max Number of Client Across All Trials", # graphtitle
                    ['Bar'], # graph type
                    [["Min"],["Avg"],["Max"]], # list of legend name
                    yAxisDigits = 0, dataLblDigits = 2
                )                
                MyReport.InsertObject(graphMultiTrialAggregate)
                self.finalGraphs["Min, Avg & Max Number of Client Across All Trials"] = graphMultiTrialAggregate                 

            MyReport.InsertPageBreak()
            MyReport.InsertHeader("Multi-trial Results")
            MyReport.InsertParagraph(FR_text2)
 
            graphMultiTrial = {}
            for key, item in _trialBssidVal.iteritems():
                graphMultiTrial[key] = Qlib.GenericGraph( 
                    _trialNumList,  # Trials
                    "Trials",     # x label
                    list((item,)), # list of y values
                    "Number of Clients",    # y label
                    "Number of Clients per Trial - BSSID: %s\nFrame Size: %d bytes, Frame Rate: %d fps" % (str(key),FrameSize,FrameRate), # graphtitle
                    ['Bar'], # graph type
                    yAxisDigits = 0, dataLblDigits = 0
                ) 
                MyReport.InsertObject(graphMultiTrial[key])
                self.finalGraphs["Number of Clients per Trial - BSSID: " + str(key)] = graphMultiTrial[key]                                              
 
        MyReport.InsertPageBreak()   
             
        MyReport.InsertHeader("Test Conditions")    
        ConfigParameters = [('Parameter', 'Value', 'Description'),
                           ('ILOAD', "%d" % (self.ILOADlist[0]),  'Intended load in frames/second for each client')]
        MyReport.InsertParameterTable(ConfigParameters, columns=[2*inch, 0.75*inch, 3.25*inch])             
               
        MyReport.InsertHeader("Test Configuration")
        ConfigParameters = [('Parameter', 'Value', 'Description'),
                           ('Achieved Transmit Time', "%d secs" % (self.TransmitTime), 'The number of seconds that the WaveTest will transmit for each iteration'),                        
                           ('Learning Time', "%d secs" % (self.LearningTime),  'The number of seconds to transmit frames for the DUT/SUT to populate its forwarding tables'),
                           ('Settle Time', "%d secs" % (self.SettleTime), 'The number of seconds to wait for the SUT to finish forwarding frames before making the final measurement'),
                           ('Aging Time', "%d secs" % (self.AgingTime), 'The number of seconds the SUT needs to recover between each iteration. Set to a default value of 5 seconds'),
                           ('Number of Trials', "%d" % (self.Trials), 'Number of times the measurement will be repeated.  Multiple trials are used for averaging the measurement'),
                           ('Frame Size', "%d"% (int(self.FrameSize)), 'MAC frame size used for test traffic in bytes'),
                           ('Initial # of Clients', "%d"% (int(self.SearchMaximum)), 'The maximum number of clients that the test shall begin its search from. Unit is in number of clients'),]
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParameters.append( ('Client Contention', 'ON', 'This enbles 2 or more clients to simultaneously attempt access to the media which results in CRC errored frames.'), )
                  
        MyReport.InsertParameterTable(ConfigParameters, columns=[2*inch, 0.75*inch, 3.25*inch])
        MyReport.InsertHeader("Topology and Client Map")
        MyReport.InsertParagraph(TTCliMap)
        MyReport.InsertClientMap(self.sourceGrpList, self.destGrpList, self.BiDirectional, self.CardMap)

        # Add Client configuration table - THC
        MyReport.InsertHeader( "Client Configuration" )
        cgConfigParams = [ ( 'Client Group', 'PHY Type', 'PHY Rate (Mbps)', 'MCS', 'A-MPDU', 'Port' ) ]
        # Distill client group names from client lists
        clientGroupList = []
        allClientList = self.SourceClients + self.DestClients
        allClientList.sort()
        for eachClient in allClientList:
            clientGroupName = eachClient[ 0 ]
            if clientGroupName not in clientGroupList:
                clientGroupList.append( clientGroupName )

        for clientGroup in clientGroupList:
            propertiesForTTobject = self.clientgroupObjs[clientGroup].propertiesForTTobject

            groupPortName = propertiesForTTobject['portName']
            phyType = propertiesForTTobject['phyType']
            if phyType == 'Ethernet':
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = propertiesForTTobject['linkSpeed']
            elif phyType == '11n':
                mcsIndex = propertiesForTTobject['dataMcsIndex'] 
                phyRate = WaveEngine.get11nPhyRate( int(mcsIndex), 
                                                    propertiesForTTobject['guardInterval'],
                                                    int(propertiesForTTobject['channelBandwidth']))    
                if propertiesForTTobject['EnableAMPDUaggregation'] == 'True':
                    ampduEnabled = 'On'
                else:
                    ampduEnabled = 'Off'
            else:
                mcsIndex = 'N/A'
                ampduEnabled = 'N/A'
                phyRate = str( propertiesForTTobject['dataPhyRate'] )

            # After gathering all the data, append the row to the table
            cgConfigParams.append( (clientGroup, phyType, phyRate, mcsIndex, ampduEnabled, groupPortName) )
            
        MyReport.InsertDetailedTable(cgConfigParams, columns=[ 1*inch, 
                                                               1*inch, 
                                                               1.25*inch, 
                                                               0.5*inch,
                                                               0.75*inch,
                                                               1.5*inch])
        
        MyReport.InsertHeader("Methodology")
        MyReport.InsertParagraph(Method1)
        MyReport.InsertParagraph(Method2)
        MyReport.InsertParagraph(Method3)
        MyReport.InsertParagraph(Method3b)
        MyReport.InsertParagraph(Method4)
        MyReport.InsertParagraph(Method5)
        MyReport.InsertParagraph(Method6)
        MyReport.InsertPageBreak()

        MyReport.InsertHeader("Detailed Results")
        if self.UserPassFailCriteria['user'] =="True":
            MyReport.InsertDetailedTable(Results_PF, columns=[0.5*inch, 0.6*inch, 0.4*inch, 0.70*inch, 0.75*inch, 0.65*inch, 0.60*inch, 0.70*inch, 0.60*inch, 1.2*inch,0.70*inch])
            NoteText=""" Note: Abbreviations used: USC-User Spefied Criteria,MC-Maximum Client Capacity """
            MyReport.InsertParagraph(DetailedRes)
            MyReport.InsertParagraph(NoteText)
            iteration_count=-1
            pass_count =0
            pass_perc  =0
            for each_tup in Results_PF:
               iteration_count=iteration_count+1
               for each_value in each_tup:
                   if each_value == 'PASS':
                      pass_count=pass_count+1
            MyReport.InsertHeader( "User Specified P/F criteria" )
            userspecifiedtext= """  With this feature, user can decide the criteria using which the test is evaluated.We will get
                the input from the user for Minimum Expected clients , based on that we will evaluate the test result as PASS/FAIL. """
            MyReport.InsertParagraph (userspecifiedtext)
  
            ConfigParameters = [ ( 'Parameter', 'User specified Value', 'Overall Result' ),
                              ( 'Minimum Expected clients',"%s" %self.UserPassFailCriteria['ref_min_client'] , 
                              "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,pass_count,(iteration_count-pass_count)))]
            if pass_count != iteration_count:
                self.FinalResult =3
            MyReport.InsertParameterTable( ConfigParameters, columns = [ 3.0*inch, 1.25*inch, 1.75*inch ] ) # 6-inch total

        else: 
            MyReport.InsertDetailedTable(Results, columns=[0.5*inch, 0.6*inch, 0.4*inch, 0.70*inch, 0.75*inch, 0.65*inch, 0.60*inch, 0.70*inch, 0.60*inch, 2.5*inch])
            MyReport.InsertParagraph(DetailedRes)
        self.insertAPinfoTable(RSSIfileName = self.RSSIFilename ,
                               reportObject = MyReport,
                               text1 = RSSIdetails1, text2 = RSSIdetails2)

        # other info section
        MyReport.InsertHeader("Other Info")
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        MyReport.Print()
                    
    def run(self):
        # For debuging the reports
        #self.LoggingDirectory = "C:\\myCVS\\veriwave_sw_tga\\apps\\WaveAppSuite\\logs"
        #self.ReadResults()
        #self.PrintReport() 
        #return
        #
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)

        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            if self.generatePdfReportF:
                self.PrintReport()
            #Update the csv results, pdf charts (if opted by the user) in the GUI
            #'Results' page
            self.ExitStatus=self.FinalResult
            self.updateGUIresultsPage()
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            try:
                WaveEngine.OutputstreamHDL(str(e), WaveEngine.MSG_ERROR)
            except Exception, e:
                print "ERROR: ", str(e)
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        Method = "This test allows the user to calculate the maximum number of clients that can be "\
                 "associated on the SUT at a given time under a given intended load and frame size "\
                 "within an acceptable frame loss tolerance.\n"
        return Method
    
    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        return self.finalGraphs
    
##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False

    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
