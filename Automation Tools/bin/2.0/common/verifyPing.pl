#!/usr/bin/perl -w
#----------------------------------
#Author: Alex_dai
#
#Description: try to ping an ip and see whether it's able to ping thru
#
#Input parameters:
#		ipaddress
#		logfile
#
#Usage: ./verifyPing.pl -d $ip_addr -I $interface -t $timeout -c $pktcount -l $logdir -o $logfile [-n] 
#	./verifyPing.pl -d 192.168.100.1 -I eth0 -t 20 -c 10 -l /../Q2k -o verifyPing_test.log
#
#-----------------------------------	
# History       :
#   DATE        |   REV     | AUTH      | INFO
#31 Oct 2011    |   1.0.0   | Alex      | Inital Version
#30 Nov 2011    |   1.0.1   | Alex      | changed the timeout framework to send five packets every time + loops
#14 Feb 2012    |   1.0.2   | Alex      | add AT_ERROR identifer

my $REV="$0 version 1.0.2 (14 Feb 2012)";
# print REV
print ("$REV\n");


use strict;
use warnings;
use diagnostics;
use Log::Log4perl;
use Pod::Usage;
use Getopt::Long;
use FileHandle;
use Data::Dumper;
use Expect;
#default timeout for each command
my $CMD_TMO = 60; 
#-----<<<----------------
my $FAIL=1;
my $PASS=0;
my $NOFUNCTION="none";
my @junk = split( /\//, $0);
@junk = split('\.',$junk[$#junk]);
my $scriptFn = $junk[0];
my $logdir = `pwd`;
$logdir=~ s/\n//;
#---------------------------------------------------------
# This routine is used to initialize the log feature
#---------------------------------------------------------
sub initLogger {
    my ( $profFile, $junk) = @_;
    my $rc = $PASS;
    my $msg ="Successfully Set Logger";
    my $found=1;
    my $count=0;
    my $localLog;
    #--------------------
    # initialize logger
    #---------------------
    my $temp = $profFile->{scriptname}."_$profFile->{seed}";
    if ( $profFile->{outputfile} =~ /$NOFUNCTION/) {
    while ( $found ) {
	$localLog = $profFile->{logdir}."/".$profFile->{scriptname}."_output_$count.log";
	if ( !(-e $localLog)){
	    $found=0;
	    next;
	}
	$count++;
    }
    }else{
	$localLog = $profFile->{logdir}."/".$profFile->{outputfile};
    }

   
    my $clobberLog = $profFile->{logdir}."/".$profFile->{scriptname}."_clobber_$count.log";
    if ( -e $clobberLog ) {
	$temp = `rm -f $clobberLog`;
    }
    # layout: date-module + line mumber -(info,debug,warn,error,fatal)> message +  new line 
    my $layout = Log::Log4perl::Layout::PatternLayout->new("%d--%F{1}:%L--%M--%p> %m%n");
    my $gName = "initLogger";
    if ( defined $profFile->{gcov}{$gName} ) {
	$profFile->{gcov}{$gName} += 1;
    } else {
	$profFile->{gcov}{$gName} = 1;
    }

    $profFile->{logger}= Log::Log4perl->get_logger();
    
    if ( $profFile->{screenOff} == 0 ) {
	my $screen = Log::Log4perl::Appender->new("Log::Log4perl::Appender::Screen",
						  stderr => 0);	
	$profFile->{logger}->add_appender($screen);
    }
    if ( $profFile->{logOff} == 0 ) {
	my $appender = Log::Log4perl::Appender->new("Log::Log4perl::Appender::File",
						    filename => $localLog,
						    mode => "append");
#	my $writer = Log::Log4perl::Appender->new("Log::Log4perl::Appender::File",
#						  filename => $clobberLog,
#						  mode => "clobber");
	$appender->layout($layout);	
	$profFile->{logger}->add_appender($appender);
#	$profFile->{logger}->add_appender($writer);
    }
    if ( $profFile -> {noprint} ) {
	$profFile->{logger}->info("--> Log initialized <--");
    }
    return($rc,$msg);

}

#-------------------------------------------------------
# Set up Child Process
# !!!!NOTE that the return code of this routine
# is exceptional. The return code is generated by external script
#--------------------------------------------------------
sub executeCmdProcess {
    my ( $profFile)=@_;
    my $tmo = 4;
    my $temp = 0;
    my $rc = $PASS;
    my $limit = 1;
    my $log = $profFile->{logger};
    my $cmd ="";
    my $dest_ip  = $profFile->{dest_ip};
    #my $testLog= $profFile->{outputfile};
    my @buff;
    my $junk;
    my $try= 0;
    my $times;
    my $msg = "";
    my $timeout = 30;
    my $time_n = time();
    my $localtime = "";
    my $bDone = 0;
    my $do_next = 0;

    if($profFile->{timeout} !~ /$NOFUNCTION/){
        $timeout = $profFile->{timeout};
    }
    $times = 0;
    if($profFile->{pktcount} !~ /$NOFUNCTION/){
        $limit = $profFile->{pktcount};
    }

    if ( $profFile->{debug} > 2 ) {  $log->info( "Timeout: ($timeout) ") };
    while ($bDone == 0 && time() - $time_n < $timeout  && $times < $limit){
        #sleep(1);
        $localtime = localtime();
        if ( $profFile->{debug} > 2 ) {  $log->info( "Current time: ($localtime) ") };
        $cmd = "ping $dest_ip -c 2";
        if($profFile->{interface} !~ /$NOFUNCTION/){
            $cmd = $cmd." -I $profFile->{interface}";
        }
        #if($profFile->{timeout} !~ /$NOFUNCTION/){
            $cmd = $cmd." -W 2";
            #}
        if($profFile->{packetsize} !~ /$NOFUNCTION/){
            $cmd = $cmd." -s $profFile->{packetsize}";
        }
        if($profFile->{preload} !~ /$NOFUNCTION/){
            $cmd = $cmd." -l $profFile->{preload}";
        }
        if ( $profFile->{debug} > 2 ) {  $log->info( "stepCmdProcess: cmd($cmd) ") };
        if ( $profFile->{noprint} ) { $log->info("stepCmdProcess with TMO($tmo):cmd($cmd)")};
        {
            my $exp=Expect->spawn("$cmd");
            if ( defined $exp ) {
                $do_next = 0;
                while($bDone == 0 && $do_next == 0){            
                    $exp->expect($tmo,
                        [
                            timeout =>
                            sub {
                                $rc = $FAIL; #failed
                                $msg = "stepCmdExecute:$cmd is TimeOUT";
                                if ( $profFile->{debug} > 2 ) {  $log->info( "$msg ") };
                                if (time() - $time_n >= $timeout){
                                    $bDone = 1;
                                }
                            }
                        ],
                        [
                            "Destination Host Unreachable",
                            sub {
                                $rc =$FAIL;
                                $msg = "Destination Host Unreachable";
                                if ( $profFile->{debug} > 2 ) {  $log->info( "$msg ") };
                                if (time() - $time_n >= $timeout){
                                    $bDone = 1;
                                }
                            }
                        ],
                        [
                            "Destination Net Unreachable",
                            sub {
                                $rc =$FAIL;
                                $msg = "Destination Net Unreachable";
                                if ( $profFile->{debug} > 2 ) {  $log->info( "$msg ") };
                                if (time() - $time_n >= $timeout){
                                    $bDone = 1;
                                }
                            }
                        ],
                        [
                            "bytes from",
                            sub {			      
                                $rc = $PASS;			      
                                $msg = "verifyPing test passed--$dest_ip is reachable.";
                                if ( $profFile->{debug} > 2 ) {  $log->info( "$msg ") };
                                if($profFile->{pktcount} !~ /$NOFUNCTION/){
                                    $times +=1;
                                    if (time() - $time_n >= $timeout){
                                        $bDone = 1;
                                    }
                                }else{
                                    $times +=1;
                                    $bDone = 1;
                                }
                            }
                        ],
                        [ eof => 
                            sub { 
                                $msg = "==>EOF \n";
                                if ( $profFile->{debug} > 2 ) {  $log->info( "$msg ") };
                                $do_next = 1;
                                #break;
                            }
                        ],	 	
                    );
                }
            }
            #$log->info("$msg");
            #$exp->hard_close();
            #$try += 1;
        }
        if ($times >= $limit){
            $rc = $PASS;
            $msg = "Successfully execute --  $cmd" ;
            $bDone = 1;
        }
        else {
            #continue;
            $rc = $FAIL;
        }
        #if ($rc == $FAIL) {
        #    $msg = "Failed to execute $cmd due to $msg" ;
        #} else { 
        #    $rc = $PASS;
        #    $msg = "Successfully execute --  $cmd" ;
        #}  
        #return ($rc,$msg);
    }

    return($rc,$msg);

}

sub executeCmdProcess_Bak {
    my ( $profFile)=@_;
    my $tmo = 4;
    my $temp = 0;
    my $rc = $PASS;
    my $limit;
    my $log = $profFile->{logger};
    my $cmd ="";
    my $dest_ip  = $profFile->{dest_ip};
    #my $testLog= $profFile->{outputfile};
    my @buff;
    my $junk;
    my $try= 0;
    my $times;
    my $msg;

    if($profFile->{pktcount} !~ /$NOFUNCTION/){
        $limit = $profFile->{pktcount}/5;
    }elsif($profFile->{timeout} !~ /$NOFUNCTION/){
	    $limit = $profFile->{timeout}/4;
    }
    
    $cmd = "ping $dest_ip -c 5";
    if($profFile->{interface} !~ /$NOFUNCTION/){
	    $cmd = $cmd." -I $profFile->{interface}";
    }
    if($profFile->{timeout} !~ /$NOFUNCTION/){
	    $cmd = $cmd." -W $profFile->{timeout}";
    }
    if($profFile->{packetsize} !~ /$NOFUNCTION/){
	    $cmd = $cmd." -s $profFile->{packetsize}";
    }
    if($profFile->{preload} !~ /$NOFUNCTION/){
	    $cmd = $cmd." -l $profFile->{preload}";
    }
    if ( $profFile->{debug} > 2 ) {  $log->info( "stepCmdProcess: cmd($cmd) ") };
    if ( $profFile->{noprint} ) { $log->info("stepCmdProcess with TMO($tmo):cmd($cmd)")};

    while ( $try < $limit ) {
        my $exp=Expect->spawn("$cmd");
        $times = 0;
        if ( defined $exp ) {
            while($times<5){            
                $exp->expect($tmo,
			    [
			    timeout =>
			    sub {
			      $rc = $FAIL; #failed
			      $msg = "stepCmdExecute:$cmd is TimeOUT";
                  $times = 5;
			    }
			    ],
			    [
			    "Destination Host Unreachable",
			    sub {
			      $rc =$FAIL;
			      $msg = "Destination Host Unreachable";
			      $times +=1;
			    }
			    ],
                [
			    "Destination Net Unreachable",
			    sub {
			      $rc =$FAIL;
			      $msg = "Destination Net Unreachable";
                  $times += 1;
			    }
			    ],
			    [
			    "bytes from",
			    sub {			      
			      $rc = $PASS;			      
			      $msg = "verifyPing test passed--$dest_ip is reachable.";
			      if($profFile->{pktcount} !~ /$NOFUNCTION/){
				      $times +=1;
			      }else{
                      $times = 5;
                      $try = $limit;
			      }
			    }
			    ],
			    [ eof => 
			    sub { 
			       
#			       $log->info ("==>EOF \n"); 
			       $rc = $FAIL ;
			       $msg = "==>EOF \n";
			       #last;
			    }
			   ],	 	
		    );
        }
	}
	$log->info("$msg");
	$exp->hard_close();
    $try += 1;
    }
	if ($rc == $FAIL) {
	    $msg = "Failed to execute $cmd due to $msg" ;
	} else { 
	    $rc = $PASS;
	    $msg = "Successfully execute --  $cmd" ;
	}  
    return ($rc,$msg);
}
#---------------------------------------------------
# Launch all jobs and check their status
#---------------------------------------------------
sub jobLaunch {
    my ($profFile,$junk) = @_;
    my $rc = $PASS;
    my $log = $profFile->{logger};
    my $msg ;
    #--------------------------------------------------------
    # Start to spawn all processes based on IP, USR and CMD
    #--------------------------------------------------------
   ($rc,$msg) = executeCmdProcess($profFile);
    return ($rc,$msg);
}

#************************************************************
# Main Routine
#************************************************************
MAIN:
my $TRUE=1;
my $FALSE=0;
my $option_h;
my $rc =0;
my $msg;
my $count = 0;
my $globalRc = $PASS;
my $option_man = 0;
my $temp;
my $found =0;
my $key;
my %userInput = (
    "debug" => "0",
    "logdir"=>$logdir,
    "dest_ip"=>$NOFUNCTION,
    "interface"=>$NOFUNCTION,
    "pktcount"=>$NOFUNCTION,
    "outputfile"=>$NOFUNCTION,
    "packetsize"=>$NOFUNCTION,
    "preload"=>$NOFUNCTION,
    "timeout"=>$CMD_TMO,
    "scriptname"=> $scriptFn,
    "screenOff"=> 0,
    "logOff"=> 0,
    "negative"=> 0,
    "errtable"=>[ "Login failed due to a bad username or password",
		  "parser error :",
    ],
    );

#---------------------------------------------
# Initialize Logger 
#---------------------------------------------
$userInput{seed}="0";
$rc = GetOptions( "x=s"=>\$userInput{debug}, 
		  "help|h"=>\$option_h, 
		  "man"=>\$option_man, 
		  "l=s"=>sub {  $userInput{logdir} = $_[1];},
		  "o=s"=>\$userInput{outputfile},
		  "d=s"=>\$userInput{dest_ip},
		  "I=s"=>\$userInput{interface},
		  "c=s"=>\$userInput{pktcount},
		  "t=s"=>\$userInput{timeout},
          "s=s"=>\$userInput{packetsize},
          "p=s"=>\$userInput{preload},
		  "n"=>sub { $userInput{negative} = 1},
		  );
#Using pod2usage to display Help or Man
pod2usage(1) if ( $option_h );
pod2usage(-verbose=>2) if ( $option_man);
($rc,$msg) = initLogger(\%userInput, 0);
if ( $rc == $FAIL) {
    print ("AT_ERROR : RC$rc $msg\n");
    exit 1;
} 
if ( $globalRc == $FAIL) {
    $userInput{logger}->info("AT_ERROR : $msg");
    exit 1;
}

if ( ($userInput{dest_ip} =~ /$NOFUNCTION/) ||  ($userInput{dest_ip} =~ /^\s*$/ )   ) {
    print ("\nAT_ERROR : Missing Destination IP address\n");
    pod2usage(1);
    exit 1;
}


#printf("--------------- Input Parameters  ---------------\n") if $userInput{debug} ;

if ( $userInput{ noprint } ) { 
print("--------------- $scriptFn  Input Parameters  ---------------\n");
    foreach $key ( keys %userInput ) {
#    printf (" $key = $userInput{$key} :: " ) if $userInput{debug} ;
	print (" $key = $userInput{$key} ::\n" );
    }
}

#-------------------------------------------------
#Parsing input file from Management Frame Work  
#-------------------------------------------------
    
($rc,$msg) = jobLaunch(\%userInput ,0);

$userInput{logger}->info("$msg");
if ($userInput{negative}==0){
	if ( $rc == $FAIL) {
   		$userInput{logger}->info("AT_ERROR : $userInput{scriptname}  failed");
    	exit 1;
	}
	$userInput{logger}->info("==> $userInput{scriptname} passed");
	exit (0);
}else{
	if ( $rc == $PASS) {
   		$userInput{logger}->info("AT_ERROR : $userInput{scriptname} negtive test failed");
    	exit 1;
	}
	$userInput{logger}->info("==> $userInput{scriptname} negtive test passed");
	exit (0);
}

__END__


=head1 NAME
verifyPing.pl is used to try to ping an ip and see whether it's able to ping thru

=head1 SYNOPSIS

=over

=item B<verifyPing.pl>
[B<-help|-h>]
[B<-man>]
[B<-o> I<output file to save file >]
[B<-l> I<log file directory>]
[B<-d> I<target address>]
[B<-t> I<time out for each command executed by verifyPing.pl >]
[B<-I> I<interface>]
[B<-c> I<packet count>]
[B<-n> I<negative useage>]


=back

=head1 OPTIONS AND ARGUMENTS

=over

=item B<-help>

Print a brief help message and exit.

=item B<-man>

Print a man page and exit.

=item B<-o>

Output file where the output of ping will be stored

=item B<-l >

Redirect stdout to the /path/verifyPing.log

=item B<-d >

Target ip address

=item B<-I>

Interface

=item B<-t >

Set timeout in seconds for each command ( default = 60 seconds)

=item B<-c>

Packet count

=item B<-x>

Set debug to different level . ( more debug messages with higher number)

=item B<-i>
Insert text file at the beginning of the text file 

=item B<-n>
Negative usage 


=back


=head1 EXAMPLES

=over

1. The following command is used to ping target ip_address 192.168.100.1 with interface eth0 within the timeout=60,and set the counts of packet received as 10 and save the output to "verifyPing_test.log" in the directory /tmp

	 perl verifyPing.pl -d 192.168.100.1 -I eth0 -t 60 -c 10 -l /temp -o verifyPing_test.log

=back

=head1 AUTHOR

Please report bugs using L<http://budz/>

Joe Nguyen  E<lt>joe_nguyen@yahoo.comE<gt>

=cut
