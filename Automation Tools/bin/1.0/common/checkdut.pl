#!/usr/bin/perl -w
#-------------------------------------------------------------------
# Name: Joe Nguyen
# Description:
#---------------- 
#   This script is used to execute ssh and given commands directly without waiting for password prompt 
# Things To Do:
#--------------
#--------------------------------------------------------------------
use strict;
use warnings;
use diagnostics;
use Log::Log4perl;
use Pod::Usage;
use Getopt::Long;
use FileHandle;
use Data::Dumper;
use Expect;
#default timeout for each command
my $CMD_TMO = 300; 
#-----<<<----------------
my $FAIL=1;
my $PASS=0;
my $NOFUNCTION="none";
my @junk = split( /\//, $0);
@junk = split('\.',$junk[$#junk]);
my $scriptFn = $junk[0];
my $logdir = `pwd`;
$logdir=~ s/\n//;
my %userInput = (
    "debug" => "0",
    "logdir"=>$logdir,
    "server"=>$NOFUNCTION,
    "user"=>$NOFUNCTION,
    "password"=>$NOFUNCTION,
    "outputfile"=>$NOFUNCTION,
    "timeout"=>$CMD_TMO,
    "scriptname"=> $scriptFn,
    "screenOff"=> 0,
    "commands"=> [],
    "insert"=> [],
    "logOff"=> 0,
    "errtable"=>[ "Login failed due to a bad username or password",
		  "parser error :",
    ],
    );
#---------------------------------------------------------
# This routine is used to initialize the log feature
#---------------------------------------------------------
sub initLogger {
    my ( $profFile, $junk) = @_;
    my $rc = $PASS;
    my $msg ="Successfully Set Logger";
    my $found=1;
    my $count=$profFile->{seed};
    #--------------------
    # initialize logger
    #---------------------
    my $temp = $profFile->{scriptname}."_$profFile->{seed}";
    my $localLog = $profFile->{logdir}."/$temp.log";
    my $clobberLog = $profFile->{logdir}."/$temp\_clobber.log";
    while ( $found ) {
	$temp = $profFile->{scriptname}."_$count";
	$localLog = $profFile->{logdir}."/$temp.log";
	if (!( -e $localLog )) {
	    $profFile->{seed} = $count;
	    $found = 0;
	    next;
	}
	$count++;
    }
    $clobberLog = $profFile->{logdir}."/$temp\_clobber.log";
    if ( -e $clobberLog ) {
	$temp = `rm -f $clobberLog`;
    }
    # layout: date-module + line mumber -(info,debug,warn,error,fatal)> message +  new line 
    my $layout = Log::Log4perl::Layout::PatternLayout->new("%d--%F{1}:%L--%M--%p> %m%n");
    my $gName = "initLogger";
    if ( defined $profFile->{gcov}{$gName} ) {
	$profFile->{gcov}{$gName} += 1;
    } else {
	$profFile->{gcov}{$gName} = 1;
    }

    $profFile->{logger}= Log::Log4perl->get_logger();
    
    if ( $profFile->{screenOff} == 0 ) {
	my $screen = Log::Log4perl::Appender->new("Log::Log4perl::Appender::Screen",
						  stderr => 0);	
	$profFile->{logger}->add_appender($screen);
    }
    if ( $profFile->{logOff} == 0 ) {
	my $appender = Log::Log4perl::Appender->new("Log::Log4perl::Appender::File",
						    filename => $localLog,
						    mode => "append");
	my $writer = Log::Log4perl::Appender->new("Log::Log4perl::Appender::File",
						  filename => $clobberLog,
						  mode => "clobber");
	$appender->layout($layout);	
	$profFile->{logger}->add_appender($appender);
	$profFile->{logger}->add_appender($writer);
    }
    $profFile->{logger}->info("--> Log initialized <--");
    return($rc,$msg);

}

#-------------------------------------------------------
# Set up Child Process
# !!!!NOTE that the return code of this routine
# is exceptional. The return code is generated by external script
#--------------------------------------------------------
sub executeCmdProcess {
    my ( $profFile)=@_;
    my $tmo = 60; #local time out
    my $temp = 0;
    my $rc = $PASS;
    my $rc2 ;
    my $index;
    my $errindex;
    my $errsize;
    my $errkey;
    my $limit;
    my $log = $profFile->{logger};
    my $cmd ="";
    my $user = $profFile->{user};
    my $pwd = $profFile->{password};
    my $server  = $profFile->{server};
    my $outFile= $profFile->{outputfile};

    my $testLog = $profFile->{logdir}."/".$profFile->{scriptname}."_pingtest.txt";

    my $sendretry = 3;

    my $wait= $profFile->{timeout}/$sendretry;
    my @buff;
    my @junk;
    my $try= 0;
    my $doneflag;
    my $count = 0;
    my $toggle = 0;
    my $allow = 10;
    my $hasPingFailed = 0;
    my $timeout = $profFile->{timeout};
    my $tt = time();
    $temp = system("touch $outFile");
#    $limit = @{$profFile->{commands}};
#    $junk = system("touch $testLog");
#    $log->info("NUMBER OF CMD= $limit" ); # if ( $profFile->{debug} > 2 );
#    for ( $index = 0 ; $index < $limit ; $index++) {
#	$cmd = $cmd.$profFile->{commands}[$index]." ; ";
#    }

    $cmd = "ping  $server -w 10 -c $sendretry ";
    my $msg = "executeCmdProcess: successfully execute $cmd";
    if ( $profFile->{debug} > 2  ) {  $log->info( "stepCmdProcess: cmd($cmd) ") };
    $log->info("stepCmdProcess with TMO($tmo):cmd($cmd)");
    $doneflag = 1;
    # while ( (($count < $wait) && ($doneflag != 0 ) )) {
    while (1){
    my $span = 0;
	my $exp=Expect->spawn("$cmd");
	if ( defined $exp ) {
	$exp->log_file( "$testLog","w");	    
	    $exp->expect($tmo,
			 [
			  timeout =>
			  sub {
			      $log->info("stepCmdExecute:$cmd is TimeOUT ");
			      $rc = $FAIL; #failed
			      $try = 10;
			      $msg = " TIMEOUT ";
			      return;
			  }
			 ],
			 [ eof => 
			   sub { 
			       $log->info ("==>EOF \n"); 
			       $rc = $PASS ;
			       $try = 12;
			   }
			 ],	 	
		);
	}
	$exp->log_file();    
	$exp->soft_close();
	#check for 0% percentage pass
	open (CMDFD,"<$testLog") or die " could not read from  $testLog ";
	@buff = <CMDFD>;    
	$limit=@buff;
	for ($index=0;$index < $limit;$index++) {
	    if ( $buff[$index] =~ /\%/) {
		@junk = split (",",$buff[$index]);
		if ( ($buff[$index] !~ /errors/) ) { 
		    @junk=split('\%',$junk[2]);
		} else {
		    @junk=split('\%',$junk[3]);
		}
        $span = time() - $tt;

 		$temp = $junk[0];
		$toggle+=$allow;
		if ( $junk[0] != 0 ) {
		    $doneflag=1;
            if ($hasPingFailed > 0){
            }else{
                if ($junk[0]==100){
                    $hasPingFailed = 1;
                    $toggle = 0;
                }
            }
            # check timeout
            if ($span >= $timeout){
                $rc = $FAIL ;
                $msg = " Timeout waiting for reach $server ";
                return ($rc,$msg);
            }
		} else {
            # ping success
            if ($hasPingFailed > 0){
                # from ping failed into ping success
                $rc = $PASS ;
                $msg = " Successfully reach $server ";
                return ($rc,$msg);
                #
            }else{
                if ($span >= $timeout){
                    #$rc = $FAIL ;
                    $rc = $PASS ;
                    $msg = " Warning : ping always success,but timeout waiting for no reach $server ";
                    return ($rc,$msg);
                }
            }

	 	   if ( $toggle < $allow ) {
			$doneflag=1;
		    } else {
			$doneflag = 0;
		    }
		}
	    }
	}
	close CMDFD;
	$log->info( "count = $count -- toggle = $toggle");
	$count++;
    #$toggle++ ;
	$temp=`cat $testLog >> $outFile`;
    }
    $temp=0;
    $log->info( "Wait for $temp second");
    sleep $temp;
    $msg = " Successfully reach $server ";
    $log->info( "wait=$wait");
    if ( $count > $wait ) { 
	$msg = " Failed to  reach $server ";
	return ($FAIL,$msg);
    }
    $rc=$PASS;
    return ($rc,$msg);
}
#---------------------------------------------------
# Launch all jobs and check their status
#---------------------------------------------------
sub jobLaunch {
    my ($profFile,$junk) = @_;
    my $rc = $PASS;
    my $log = $profFile->{logger};
    my $msg ;
    #--------------------------------------------------------
    # Start to spawn all processes based on IP, USR and CMD
    #--------------------------------------------------------
   ($rc,$msg) = executeCmdProcess($profFile);
    return ($rc,$msg);
}

#************************************************************
# Main Routine
#************************************************************
MAIN:
my $TRUE=1;
my $FALSE=0;
my $option_h;
my $rc =0;
my $msg;
my $count = 0;
my $globalRc = $PASS;
my $option_man = 0;
my $temp;
my $found =0;
my $key;
#---------------------------------------------
# Initialize Logger 
#---------------------------------------------
$userInput{seed}="0";
$rc = GetOptions( "x=s"=>\$userInput{debug}, 
		  "help|h"=>\$option_h, 
		  "man"=>\$option_man, 
		  "l=s"=>sub {  $userInput{logdir} = $_[1];},
		  "t=s"=>\$userInput{timeout},
		  "o=s"=>\$userInput{outputfile},
		  "u=s"=>\$userInput{user},
		  "p=s"=>\$userInput{password},
		  "d=s"=>\$userInput{server},
		  "v=s"=>sub { if ( exists $userInput{commands}[0] ) { push (@{$userInput{commands}},$_[1]); } else {$userInput{commands}[0]=$_[1]; } } ,
		  "i=s"=>sub { if ( exists $userInput{insert}[0] ) { push (@{$userInput{insert}},$_[1]); } else {$userInput{insert}[0]=$_[1]; } } ,
		  );
#Using pod2usage to display Help or Man
pod2usage(1) if ( $option_h );
pod2usage(-verbose=>2) if ( $option_man);
($rc,$msg) = initLogger(\%userInput, 0);
if ( $rc == $FAIL) {
    print ("RC$rc $msg\n");
    exit 1;
} 
if ( $globalRc == $FAIL) {
    $userInput{logger}->info("$msg");
    exit 1;
}
($key,$temp) = split ('\/',$userInput{server});
$userInput{server} = $key;


#printf("--------------- Input Parameters  ---------------\n") if $userInput{debug} ;
print("--------------- $scriptFn  Input Parameters  ---------------\n");
foreach $key ( keys %userInput ) {
#    printf (" $key = $userInput{$key} :: " ) if $userInput{debug} ;
    print (" $key = $userInput{$key} \n " );
}
print("--------------- $scriptFn  Input Parameters  END---------------\n");

$temp = $userInput{outputfile};
if ( $userInput{outputfile} =~ /$NOFUNCTION/) {
#    $userInput{outputfile} = $userInput{logdir}."/".$userInput{scriptname}."_output_$count.txt"
    $found = 1;
    $count=0 ;
    while ( $found ) {
	$temp= $userInput{logdir}."/".$userInput{scriptname}."_output_$count.txt";
	if ( !(-e $temp)){
	    $found=0;
	    next;
	}
	$count++;
    }
}
$userInput{outputfile} = $temp;







my $limit = @{$userInput{commands}};
my $line;
if ($limit != 0 ) {foreach $line (  @{$userInput{commands}}) { print "$line \n"; } };
#-------------------------------------------------
#Parsing input file from Management Frame Work  
#-------------------------------------------------
    
($rc,$msg) = jobLaunch(\%userInput ,0);

$userInput{logger}->info("$msg");
if ( $rc == $FAIL) {
    $userInput{logger}->info("==> -| FAILED : $userInput{scriptname}  failed");
    exit 1;
}
$userInput{logger}->info("==> -| PASSED : $userInput{scriptname} passed");
exit (0);
1;
__END__


=head1 NAME
checkdut.pl is used to verify if the dut is reacheable after reboot applied

=head1 SYNOPSIS

=over

=item B<checkdut.pl>
[B<-help|-h>]
[B<-man>]
[B<-o> I<output file to save file >]
[B<-l> I<log file directory>]
[B<-t> I<timeout>]
[B<-d> I<target address>]


=back

=head1 OPTIONS AND ARGUMENTS

=over

=item B<-o>

Output file where the output will be stored

=item B<-l >

Redirect stdout to the /path/checkdut.log


=item B<-t >

Set timeout in seconds for each command ( default = 300 seconds)

=item B<-help>

Print a brief help message and exit.

=item B<-man>

Print a man page and exit.

=item B<-x>

Set debug to different level . ( more debug messages with higher number)



=back


=head1 EXAMPLES

=over

1. The following command is used to check esx006 and save the output to "test123.txt" in the directory /tmp
         checkdut.pl -f test123.txt -d esxd006  -l /tmp

=back

=head1 AUTHOR

Please report bugs using L<http://budz/>

Joe Nguyen  E<lt>joe_nguyen@yahoo.comE<gt>

=cut
