#aaa_auth_rate_test

import sys, time, traceback
import sched, math, copy
from basetest import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *
import WaveEngine as WE
import random
import Qlib

class Test( BaseTest ):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,  1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,  4 )
                       }
                            
        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}
          
        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of 00:00:00:00:00:00
                       tells the system to pick the first on on the list.
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """        
        self.SourceClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.10', '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions )]
        self.DestClients   = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.50.20', '255.255.255.0', '192.168.50.1', (), Security_None, self.ClientOptions)]

        
        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the test details. This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_aaa_auth_rate.csv'
        self.ReportFilename   = 'Report_aaa_auth_rate.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_aaa_auth_rate.csv'

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.FinalResult=0
 
        
########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.12 $' 
        self.date    = '$Date: 2007/09/04 18:39:30 $' 
        self.finalGraphs = odict.OrderedDict()
        self.trialResult = odict.OrderedDict()
        
    def getTestName(self):
        return 'aaa_auth_rate'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
        
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
          
         #___________________________________TEL_________________________________________________
        #check for the db key in the waveTestStore['LogsAndResultsInfo'] dictionary if present assign the
        #the corresponding value to DbSupport. Similarly check for the key for pass/fail criteria pf and
        #update the self.UserPassFailCriteria['user'].If user is True then assign the other values for the
        #calculation purpose to judge the pass/fail of the result.
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
            if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
            if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']

            if waveTestSpecificStore['aaa_auth_rate']['ExpectedAuthentications']:
                if float(waveTestSpecificStore['aaa_auth_rate']['ExpectedAuthentications']) >= 0:
                    self.UserPassFailCriteria['ref_min_auth']=float(waveTestSpecificStore['aaa_auth_rate']['ExpectedAuthentications'])/100
                else:
                    WaveEngine.OutputstreamHDL("\nThe value for the parameter ExpectedAuthentications should be a positive number\n",WaveEngine.MSG_ERROR) 
                    raise  WaveEngine.RaiseException 
            else:
                #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ExpectedClientConnections> parameter, hence reverting to default value and proceeding further....\n",WaveEngine.MSG_WARNING)
                self.UserPassFailCriteria['ref_min_auth']= 1.0
        #___________________________________TEL_________________________________________________


        
        wmlTestDict = waveTestSpecificStore['aaa_auth_rate']              
        self.invalidTestResult = False
        self.authRate = int(wmlTestDict['AuthenticationRate'])
        self.resultSampleTime = int(wmlTestDict['ResultSampleTime'])
        self.disconnectClients = str(wmlTestDict['DisconnectClients'])
        self.failedTestList = []
        self.invalidTestList = []
        self.createClientLists(waveClientTableStore, waveSecurityStore)
        
        clientTableKeys = waveClientTableStore.keys()
        for clientName in clientTableKeys:
            if waveClientTableStore[clientName]['Enable'] == True or \
               waveClientTableStore[clientName]['Enable'] == 'True':
                # figure out if this is an Ethernet or wireless test
                if waveClientTableStore[clientName]['Interface'] in WE.WiFiInterfaceTypes:
                    self.clientType = 'mc'
                else:
                    self.clientType = 'ec'
                break            

    def startTest(self):
        self.authCounts = {}
        self.prevEapolSuccessCount = {}   
                         
        WaveEngine.OutputstreamHDL("Creating clients, please wait..", WaveEngine.MSG_OK)
        # We only need to create the source clients since this is a connection rate
        # test and we don't need to send traffic to destination clients  
        self.ListOfClients = {}
        #With the changes involving the create of self.clientgroupObjs, we 
        #don't need self.ListOfClients anymore, leaving it as the clean up is
        #not being done now, it is preserved for now    
        for groupName in self.clientgroupObjs:
            if self.clientgroupObjs[groupName].enabled:
                groupTuple = self.clientgroupObjs[groupName].groupTuple
                thisGroupClients = WaveEngine.CreateClients([groupTuple])
                self.clientgroupObjs[groupName].addClients(thisGroupClients)
                self.ListOfClients.update(thisGroupClients) 
        #self.ListOfClients = WaveEngine.CreateClients(self.SourceClients)  
        
        # set probe delay, auth delay, assoc delay, eapol delay, grat ARP delay, traffic delay to 0
        for name in mc.getNames():
            mc.updateClientDelays(name,0)
        # rearrange client list, separate them by ports into different lists
        orderedListofClients = self.rearrangeClientList() 
        if  self.UserPassFailCriteria['user'] == "True":
                  self.ResultsForCSVfile.append(('Trial',
                                       'Number of Attempted Authentication',
                                       'Number of Successful Authentication',
                                       'Number of Failed Authentication',
                                       'USC:AR'
                                       ))
        else:      
                  self.ResultsForCSVfile.append(('Trial',
                                       'Number of Attempted Authentication',
                                       'Number of Successful Authentication',
                                       'Number of Failed Authentication',
                                       ))
        self.firstTrial = True           
        for TrialNumber in range(1, 1 + self.Trials): 
            self.invalidTestResult = False
            self.totalAuthCounts = []
            for portName in self.CardList:  
                self.authCounts[portName] = []
                # have to save the eapol success counter before we begin the trial since it
                # doesn't get reset by doing stats.resetAll()
                WaveEngine.VCLtest("stats.read('%s')" % (portName))  
                self.prevEapolSuccessCount[portName] = stats.getTotalEAPOLHandshakeSuccess()  
                                         
            WaveEngine.ClearAllCounter(self.CardList)
            if self.clientType == 'mc':
                # Write AP's RSSI info
                WaveEngine.WriteAPinformation(self.ListOfClients)
            
            WaveEngine.OutputstreamHDL("\nTrial Number: %s" % (TrialNumber), WaveEngine.MSG_OK)
            
            (self.elapsedTime, self.totalConnected, self.totalAttempted) = \
                self.authClients(orderedListofClients, self.authRate, self.TransmitTime)
            
            if self.SettleTime > 0:
                WaveEngine.Sleep(self.SettleTime, "SUT settle time...")
            
            if self.elapsedTime == -1:
                self.elapsedTime = 1
                if self.clientType == 'mc':
                    WaveEngine.OutputstreamHDL("\nFailed to associate all wireless clients...", WaveEngine.MSG_WARNING)
                else:
                    WaveEngine.OutputstreamHDL("\nFailed to connect all Ethernet clients...", WaveEngine.MSG_WARNING)                    
                self.failedTestList.append(TrialNumber)
            else:
                WaveEngine.OutputstreamHDL("\nThe number of successful connections is %d in %0.2f secs at the rate of %0.2f connections/sec \n" % 
                                           (self.totalConnected, self.elapsedTime, self.totalConnected/self.elapsedTime), WaveEngine.MSG_OK) 
                WaveEngine.OutputstreamHDL("\nThe number of attempted connections is %d in %0.2f secs at the rate of %0.2f connections/sec \n" % 
                                           (self.totalAttempted, self.elapsedTime, self.totalAttempted/self.elapsedTime), WaveEngine.MSG_OK) 
            
            if self.disconnectClients == 'True' and self.clientType == 'mc': 
                WaveEngine.OutputstreamHDL("\nTearing down wireless clients...", WaveEngine.MSG_OK)     
                for name in mc.getNames():
                    mc.deauthenticate(name, 1) 
            
            if self.invalidTestResult == True:
                self.invalidTestList.append(TrialNumber)
            if  self.UserPassFailCriteria['user'] == "True":
                TestResult =''
                if self.totalAttempted != 0: 
                    if float( self.totalConnected/self.totalAttempted) >=float( self.UserPassFailCriteria['ref_min_auth']):
                        TestResult='PASS'
                        WaveEngine.OutputstreamHDL("\nThe test has achieved the P/F criteria set by the user:: User-%s,Achieved-%s"%(float(self.UserPassFailCriteria['ref_min_auth']*100),float( self.totalConnected/self.totalAttempted)*100),WaveEngine.MSG_SUCCESS) 
                    else:
                        TestResult='FAIL'
                        WaveEngine.OutputstreamHDL("\nThe test has failed to  achieve the P/F criteria set by the user:: User-%s,Achieved-%s"%(float(self.UserPassFailCriteria['ref_min_auth']* 100),float( self.totalConnected/self.totalAttempted)*100),WaveEngine.MSG_WARNING)
                else:
                    TestResult='INVALID'
                    WaveEngine.OutputstreamHDL("\nThe number of attempted connections is Zero:Results are Invalid\n",WaveEngine.MSG_WARNING)
                self.ResultsForCSVfile.append((TrialNumber, self.totalAttempted, self.totalConnected,
                                       (self.totalAttempted-self.totalConnected),TestResult))
            else:    
                self.ResultsForCSVfile.append((TrialNumber, self.totalAttempted, self.totalConnected,
                                           (self.totalAttempted-self.totalConnected)))                    
            
            WaveEngine.OutputstreamHDL("Completed: trial number: %s \n" % 
                                       (TrialNumber), WaveEngine.MSG_SUCCESS)
            if self.AgingTime > 0:
                WaveEngine.Sleep(self.AgingTime, 'SUT aging time...')
            WaveEngine.WriteDetailedLog(['',])
           
            self.trialResult[str(TrialNumber)] = copy.deepcopy(self.totalAuthCounts)
            self.firstTrial = False
            
    def PrintRealtimeStats(self, TXstate, Timeleft, elapsedTime, PassedParameters):
        return True
    
    
    def authClients(self, clientList, rate, connectTimeout):
        def printStats():       
            #try: 
            currTime = round((vclTime() - startTime), 1)
            totalEapolSuccessCount = 0
            samplingEapolSuccessCount = 0
            samplingEapolAttemptCount = 0
            for portName in self.authCounts.keys():
                WaveEngine.VCLtest("stats.read('%s')" % (portName))  
                # have to substract with the previous eapol success ctr value because 
                # it doesn't get reset on stats.resetAll()
                self.eapolSuccessCount = stats.getTotalEAPOLHandshakeSuccess() - self.prevEapolSuccessCount[portName]  
                self.authCounts[portName].append((self.eapolAttemptCount, self.eapolSuccessCount, currTime))
                totalEapolSuccessCount += self.eapolSuccessCount
                lastSuccessCnt = self.authCounts[portName][-1][1]   
                if len(self.authCounts[portName]) == 1:
                    samplingEapolSuccessCount += lastSuccessCnt                               
                else:
                    samplingEapolSuccessCount += (lastSuccessCnt - self.authCounts[portName][-2][1]) 
            lastAttemptCnt = self.authCounts[portName][-1][0]
            if len(self.authCounts[portName]) == 1:        
                samplingTime = currTime
                samplingEapolAttemptCount += lastAttemptCnt
            else:
                samplingTime = currTime - self.authCounts[portName][-2][2]
                samplingEapolAttemptCount += (lastAttemptCnt - self.authCounts[portName][-2][0])  
            if samplingTime <= 0:    
                samplingTime = 0.1                                           
            realTimeAuthRate = samplingEapolSuccessCount / float(samplingTime)    
            realTimeAttemptRate = samplingEapolAttemptCount / float(samplingTime)
                
            self.totalAuthCounts.append((totalEapolSuccessCount, self.eapolAttemptCount, realTimeAuthRate, realTimeAttemptRate, currTime))
           
            timeLeft  = stopTime - vclTime()
            if timeLeft >= 10.0:
                min = int(timeLeft / 60)
                sec = int(timeLeft % 60)
                timeStr =  "%02d:%02d" % (min, sec)
            else:
                timeStr = "%5.1f" % (timeLeft) 
            WaveEngine.OutputstreamHDL("\rCurrent: %4d\t\t%4d\t\t%.2f\t\t%.2f\t    %5s sec" % 
                                       (self.eapolAttemptCount, totalEapolSuccessCount, 
                                        realTimeAttemptRate, realTimeAuthRate, timeStr), 
                                       WaveEngine.MSG_OK) 
            if self.eapolAttemptCount - totalEapolSuccessCount < 0:
                WaveEngine.OutputstreamHDL("Warning: detected inconsistency between the number of attempted and successful authentication. Test result may be invalid.", WaveEngine.MSG_WARNING)
                self.invalidTestResult = True
            #except:
            #    WaveEngine.OutputstreamHDL("exception printStats", WaveEngine.MSG_ERROR)
            #    pass   

        def checkTime():
            if stopTime - vclTime() <= 0:
                # Cancel all the events in the scheduler since transmit time has expired.
                if scheduler.empty() == False:
                    for event in eventList:
                        try:
                            scheduler.cancel(event)
                        except:
                            pass

        def authMcClients(name):
            try:
                """
                if associatedList[name] == False:
                    WaveEngine.VCLtest("mc.doConnectToAP('%s', %d)" % (name, 0))
                    associatedList[name] = True
                else:
                """
                WaveEngine.VCLtest("mc.doEapolHandshake('%s')" % (name))
                self.eapolAttemptCount += 1    # increment number of connection attempts
            except:
                WaveEngine.OutputstreamHDL("exception authMcClients", WaveEngine.MSG_ERROR)
                pass  

        def authEcClients(name):
            try:
                if associatedList[name] == False:
                    WaveEngine.VCLtest("ec.doConnectEc('%s')" % (name))
                    associatedList[name] = True
                else:   
                    WaveEngine.VCLtest("ec.doEapolHandshake('%s')" % (name))
                self.eapolAttemptCount += 1    # increment number of connection attempts
            except:
                WaveEngine.OutputstreamHDL("exception authEcClients", WaveEngine.MSG_ERROR)
                pass                        
        
        intervalConnect  = 1.0 / float(rate)
        self.eapolAttemptCount = 0
        elapsedTime      = -1    
        self.eapolSuccessCount = 0
        associatedList = {}
        doConnectFlag = False
        eventList = []
        
        for name in clientList:
            associatedList[name] = False    
                
        if self.clientType == 'mc':
            authClients = authMcClients
            doConnectList = self.ListOfClients
            doConnectFlag = True
        else:
            doConnectList = {}
            authClients = authEcClients 
            # check if DHCP is enabled for Ethernet clients
            for clientName in self.ListOfClients:
                if self.ListOfClients[clientName][0] == WaveEngine.ClientStateDhcp:
                    doConnectList[clientName] = self.ListOfClients[clientName]
                    associatedList[clientName] = True
                    doConnectFlag = True
                    
        if doConnectFlag: 
            if self.firstTrial or self.clientType == 'ec' or self.disconnectClients == 'True':
                # MC: try to associate all the wifi clients first before start sending Eapol request
                # EC: try to do DHCP (if enabled) for all the Ethernet clients before start sending Eapol request
                AssociateRate     = float(self.AssociateRate)
                AssociateRetries  = 1
                AssociateTimeout  = float(self.AssociateTimeout)
                TotalTimeout = len(self.ListOfClients)/AssociateRate + AssociateTimeout * (1 + AssociateRetries)
                ConnType = self.ConnectionType
                if ConnType == 'Aggregate':
                    retVal = WaveEngine.ConnectClients(doConnectList, AssociateRetries, AssociateTimeout)
                else:
                    retVal = WaveEngine.ConnectClients(self.ListOfClients, AssociateRate, 
                                                       AssociateRetries, AssociateTimeout, 
                                                       TotalTimeout, ConnType)        
                if retVal < 0:
                    self.SavePCAPfile = True
                    return (-1,0,0)   
            
        for portName in self.CardList:  
            # Stored the  current the eapol success counter before we begin the trial since it
            # doesn't get reset by doing stats.resetAll()
            WaveEngine.VCLtest("stats.read('%s')" % (portName))  
            self.prevEapolSuccessCount[portName] = stats.getTotalEAPOLHandshakeSuccess()                      
                 
        schedDelay = ((connectTimeout + math.ceil(connectTimeout/self.resultSampleTime) +  
                      math.ceil(rate * connectTimeout)) * 0.0001) + 5          
        WaveEngine.OutputstreamHDL("Scheduling the clients for authentication in %.2f sec..." % (schedDelay), WaveEngine.MSG_OK)                              
        startTime = vclTime() + schedDelay
        stopTime  = startTime + connectTimeout
              
        scheduler = sched.scheduler(vclTime, time.sleep)
        
        #Entering events that print & record stats to the scheduler
        for n in range(1, int(math.ceil(connectTimeout/self.resultSampleTime))):
            eventList.append(scheduler.enter((n * self.resultSampleTime) + schedDelay, 2, printStats, ()))
        #Entering events that authenticate clients to the scheduler
        for n in range(0, int(rate * connectTimeout)): 
            clientName = clientList.pop(0)
            eventList.append(scheduler.enter((n * intervalConnect) + schedDelay, 1, authClients, (clientName,)))    
            clientList.append(clientName)  
        #Entering event to check if we already pass the transmit time
        for n in range(0, int(connectTimeout)):
            eventList.append(scheduler.enter(n + schedDelay, 3, checkTime, ()))
        
        #print "eventList: ", eventList
        while vclTime() - startTime < 0: pass

        WaveEngine.OutputstreamHDL("\nAuthenticating clients at %d per second, status is:\n" % (rate), WaveEngine.MSG_OK)
        WaveEngine.OutputstreamHDL("         Attempts  Authenticated  Attempted Rate  Authenticated Rate  Time\n", WaveEngine.MSG_OK)                                
        scheduler.run()
                
        time.sleep(intervalConnect)
        elapsedTime = round((vclTime() - startTime), 1)
        
        totalEapolSuccessCount = 0          
        samplingEapolSuccessCount = 0
        samplingEapolAttemptCount = 0
        for portName in self.authCounts.keys():
            WaveEngine.VCLtest("stats.read('%s')" % (portName))  
            # have to substract with the previous eapol success ctr value because 
            # it doesn't get reset on stats.resetAll()            
            self.eapolSuccessCount = stats.getTotalEAPOLHandshakeSuccess() - self.prevEapolSuccessCount[portName]
            self.authCounts[portName].append((self.eapolAttemptCount, self.eapolSuccessCount, elapsedTime))
            totalEapolSuccessCount += self.eapolSuccessCount
            lastCnt = self.authCounts[portName][-1][1]
            if len(self.authCounts[portName]) == 1:
                samplingEapolSuccessCount += lastCnt                       
            else:
                samplingEapolSuccessCount += (lastCnt - self.authCounts[portName][-2][1])    
        lastAttempt = self.authCounts[portName][-1][0]                     
        if len(self.authCounts[portName]) == 1:        
            samplingTime = elapsedTime
            samplingEapolAttemptCount += lastAttempt
        else:
            samplingTime = elapsedTime - self.authCounts[portName][-2][2]  
            samplingEapolAttemptCount += (lastAttempt - self.authCounts[portName][-2][0])  
        if samplingTime <= 0:
            samplingTime = 0.1
        realTimeAuthRate = samplingEapolSuccessCount / float(samplingTime)    
        realTimeAttemptRate = samplingEapolAttemptCount / float(samplingTime)
        self.totalAuthCounts.append((totalEapolSuccessCount, self.eapolAttemptCount, realTimeAuthRate, realTimeAttemptRate, elapsedTime))
                  
        return (elapsedTime, totalEapolSuccessCount, self.eapolAttemptCount)
    
      
    def PrintReport(self):
        import os.path
        Results  = []
        flag = False
        for line in self.ResultsForCSVfile:
            if flag:
                Results.append(line)
            if len(line) == 0:
                flag = True
                
        # Text Strings
        OverviewText1 = "The AAA Authentication Rate test measures the performance of AAA servers. "\
                        "The test generates a large number and variety of client connections using "\
                        "802.1x authentication transactions at very high rates to the authentication "\
                        "server, enabling you to determine the actual authentication rate supported "\
                        "by the system under test (SUT). You can also use this test to perform "\
                        "scaled authentication load testing, regression testing and "\
                        "performance-envelope testing." 
        
        summaryResultsDesc = "The following table shows the intended client authentication rate, "\
                             "the offered rate and the percentage of clients that successfully "\
                             "authenticated."
        
        summaryResultsDesc1 = "The following table shows the intended client authentication rate, "\
                             "the Min/Max/Avg/Std Deviation offered and successful client authentication rate over all "\
                             "iterations and the average percentage of clients successfully "\
                             "authenticated over all iterations."

        TestDescription1 = "For each trial in the test, clients are associated at the beginning "\
                           "of the trial and remain connected for the duration of the trial. Each "\
                           "client initiates an EAPOL handshake and then moves to the end of the "\
                           "client list. The test rotates through the list of clients until the "\
                           "trial ends. This sequence repeats for the number of trials specified "\
                           "for the test."

        TestDescription2 = "Authentication attempts and successes are reported in real time. At "\
                           "the end of the test, it reports the number of successful "\
                           "authentications and the offered authentication rate. If the test has "\
                           "more than one trial, it reports the minimum, maximum, average and "\
                           "standard deviation results over all the trials." 
        
        graph1Description = "The following graph shows the Min/Max/Average client authentication times for "\
                            "the clients in all the client groups for each Iteration"
        graph2Description = "The following graph shows the percentage of clients successfully connected "\
                            "in all the client groups for each Iteration"
        graph3Description = "The following graph shows the client authentication rate for the clients in "\
                            "all the client groups for each Iteration"
        
        RSSIdetails = "The following table shows the SUT details. The received signal strength "\
                      "indication (RSSI) from the SUT is sampled on each port at the start of each "\
                      "trial and averaged over all of the trials."
        
        RSSIdetails2 = "RSSI values should be between -25 dBm and -35 dBm. If the RSSI is not in "\
                       "this range, modify the external attenuation to bring it into this range."
                       
        if self.invalidTestList != []:
            trialNumStr = ""
            for i in self.invalidTestList:
                trialNumStr = trialNumStr + str(i) + ", "
            trialNumStr = trialNumStr[:-2]                              
            summaryBadResults = "Trial number: %s Based on the trial result data, we've discovered in several places that "\
                                "the number of attempted authentication is greater than the number "\
                                "of successful authentication. This problem could be caused by the "\
                                "SUT sending deauthentication to the client in the middle of the test which caused the client to "\
                                "try to reconnect. When this happens, the successful authentication "\
                                "counter will get incremented while the attempted authentication "\
                                "counter will not. Therefore, the trial result will be invalid." % trialNumStr
            self.ResultsForCSVfile.append(('Warning: detected inconsistency', 
                                           'between the number of attempted',
                                           'and successful authentication.',
                                           'Test result may be invalid.'))
            WaveEngine.WriteDetailedLog(['Trial number: %s' % trialNumStr,
                                         'Warning: detected inconsistency', 
                                         'between the number of attempted',
                                         'and successful authentication.',
                                         'Trial result may be invalid.'])                    
        if self.failedTestList != []:
            trialNumStr = ""
            for i in self.failedTestList:
                trialNumStr = trialNumStr + str(i) + ", "
            trialNumStr = trialNumStr[:-2]    
            summaryFailedTest = "Trial number: %s The SUT failed to connect all the clients and as a result no "\
                                "authentication request was sent during the trial." % trialNumStr
        
        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        
        MyReport.Title( "AAA Auth. Rate Test Report", self.DUTinfo, self.TestID )
        MyReport.InsertHeader( "Overview" )
        MyReport.InsertParagraph( OverviewText1 )
        MyReport.InsertHeader("Results Summary")
        
        if self.invalidTestList != []:
            MyReport.InsertParagraph(summaryBadResults)
        if self.failedTestList != []:
            MyReport.InsertParagraph(summaryFailedTest)
        if self.Trials == 1:
            resSummary = [('Total Num of Clients', 
                           'Intended Authentication Rate (auth/sec)', 
                           'Offered Authentication Rate (auth/sec)', 
                           'Sucessful Authentication Rate (auth/sec)',
                           '% Clients Authenticated')]
            self.ResultsForCSVfile.append((resSummary[0]))
            if self.totalAttempted == 0:
                pctAuth = 0
            else:
                pctAuth = self.totalConnected/float(self.totalAttempted)*100
            if self.UserPassFailCriteria['user'] =="True":
                resultTuple = (len(self.ListOfClients.keys()), self.authRate,
                           self.totalAttempted/self.elapsedTime,
                           self.totalConnected/self.elapsedTime,
                           pctAuth) 
            else:
                resultTuple = (len(self.ListOfClients.keys()), self.authRate, 
                           self.totalAttempted/self.elapsedTime, 
                           self.totalConnected/self.elapsedTime, 
                           pctAuth)
            authRateList = []
            attemptRateList = []
            timeList = []
            cumulativeAuthList = []
            cumulativeAttemptList = []
            WaveEngine.WriteDetailedLog(['Authentication Rate', self.authRate, 
                                         'Result Sample Time', self.resultSampleTime, 
                                         'Trial', '1'])                
            WaveEngine.WriteDetailedLog(['Number of Attempted Authentication', 
                                         'Number of Successful Authentication', 
                                         'Attempted Authentication Rate',
                                         'Successful Authentication Rate',
                                         'Time'])
            
            for (authCtr, attemptCtr, authRate, attemptRate, snapTime) in self.totalAuthCounts:   
                cumulativeAuthList.append(authCtr)
                cumulativeAttemptList.append(attemptCtr)
                authRateList.append(authRate)
                attemptRateList.append(attemptRate)
                prevTime = round(snapTime,2) 
                timeList.append(prevTime)                
                WaveEngine.WriteDetailedLog([attemptCtr, authCtr, attemptRate, authRate, prevTime])

            MyReport.InsertParagraph("The following graph plots the attempted and successful authentication rate for each sample time.")
            graphConnRate = Qlib.GenericGraph( 
                timeList, 
                "Duration (sec)", 
                list((authRateList, attemptRateList)),                          
                "Authentication Rate (auth/sec)", 
                "Attempted & Successful Authentication Rate Per Sampling Period", 
                ['Line'], 
                [["Successful Rate"], ["Attempted Rate"]],
                xAxisDigits = 0,
                yAxisDigits = 2)                      
            MyReport.InsertObject(graphConnRate)
            self.finalGraphs['Attempted & Successful Authentication Rate Per Sampling Period'] =  graphConnRate 

            MyReport.InsertParagraph("The following graph plots the cumulative number of attempted and successful authentications for each sample interval.")
            graphConnRate = Qlib.GenericGraph( 
                timeList, 
                "Duration (sec)", 
                list((cumulativeAuthList, cumulativeAttemptList)),                          
                "Number of Authentication", 
                "Cumulative Number of Attempted & Successful Authentications Per Sampling Period", 
                ['Line'], 
                [["Successful"], ["Attempted"]],
                xAxisDigits = 0,
                yAxisDigits = 0,
                dataLblDigits = 0)                      
            MyReport.InsertObject(graphConnRate)
            self.finalGraphs['Cumulative Number of Attempted & Successful Authentication Per Sampling Period'] =  graphConnRate 

            resSummary.append(resultTuple)  
            MyReport.InsertParagraph( summaryResultsDesc) 
            MyReport.InsertDetailedTable(resSummary, 
                                         columns=[1.0*inch, 1.0*inch, 1.0*inch, 1.0*inch, 1.0*inch])                 
            
        else:
            resSummary = [('Total Num of Clients', 
                           'Intended Authentication Rate (auth/sec)', 
                           'Min/Max/Avg/Std Dev Offered Authentication Rate (auth/sec)',
                           'Min/Max/Avg/Std Dev Successful Authentication Rate (auth/sec)', 
                           'Average % Clients Authenticated')]
            self.ResultsForCSVfile.append((resSummary[0]))
            authRateList = []
            attemptRateList = [] 
            pctAuth = 0     
            avgOffered = 0     
            avgSuccess = 0 
            trialList = [] #[str((int(val)+1)) for val in range(0, self.Trials)] 
            for trial in self.trialResult:
                WaveEngine.WriteDetailedLog(['Authentication Rate', self.authRate, 
                             'Result Sample Time', self.resultSampleTime, 
                             'Trial', trial])  
                WaveEngine.WriteDetailedLog(['Number of Attempted Authentication', 
                                             'Number of Successful Authentication', 
                                             'Attempted Authentication Rate',
                                             'Successful Authentication Rate',           
                                             'Time'])              
                for (authCtr, attemptCtr, authRate, attemptRate, snapTime) in self.trialResult[trial]:
                    WaveEngine.WriteDetailedLog([attemptCtr, authCtr, attemptRate, authRate, snapTime])  
                if self.trialResult[trial] != []:
                    if (attemptCtr - authCtr) >= 0:                    
                        authRateList.append(authCtr/float(snapTime))
                        avgSuccess += authCtr/float(snapTime)
                        attemptRateList.append(attemptCtr/float(snapTime))                
                        avgOffered += attemptCtr/float(snapTime)
                        pctAuth += authCtr/float(attemptCtr)*100
                        trialList.append(str(trial))
            
            if attemptRateList == []:
                # all trials failed
                minmaxavgOffered = "0, 0, 0, 0"
                minmaxavgSuccess = "0, 0, 0, 0"
                avgPctAuth = 0
            else:                       
                minmaxavgOffered = str("%0.01f %0.01f %0.01f %0.01f" % 
                                       (min(attemptRateList), max(attemptRateList), 
                                        avgOffered/float(len(attemptRateList)),
                                        CalcStandardDeviation(attemptRateList)))
                minmaxavgSuccess = str("%0.01f %0.01f %0.01f %0.01f" % 
                                       (min(authRateList), max(authRateList), 
                                        avgSuccess/float(len(authRateList)),
                                        CalcStandardDeviation(authRateList)))
                avgPctAuth = pctAuth/len(attemptRateList)
            resultTuple = (len(self.ListOfClients.keys()), self.authRate, 
                           minmaxavgOffered, minmaxavgSuccess, avgPctAuth)
            MyReport.InsertParagraph("The following graph plots the authentication rate over the trials." )        
            
            graphAuthRateMult = Qlib.GenericGraph( 
                trialList, 
                "Trials", 
                list((authRateList, attemptRateList)),                          
                "Authentication Rate (auth/sec)", 
                "Authentication Rate Over Trials", 
                ['Bar'], 
                [["Successful Rate"], ["Attempted Rate"]],
                xAxisDigits = 2,
                yAxisDigits = 3)                      
            MyReport.InsertObject(graphAuthRateMult)
            self.finalGraphs['Authentication Rate Over Trials'] =  graphAuthRateMult 
            resSummary.append(resultTuple) 
            MyReport.InsertParagraph(summaryResultsDesc1)
            MyReport.InsertDetailedTable(resSummary, 
                                         columns=[1.0*inch, 1.0*inch, 1.3*inch, 1.3*inch, 1.0*inch])                             
            
        self.ResultsForCSVfile.append(resultTuple)
        
        MyReport.InsertHeader( "Methodology" )
        MyReport.InsertParagraph( TestDescription1 )
        MyReport.InsertParagraph( TestDescription2 )     
        MyReport.InsertHeader( "Detailed Results" )

        MyReport.InsertParagraph("The following table shows the detailed results for this test.")
        if self.UserPassFailCriteria['user'] =="True":
            MyReport.InsertDetailedTable( Results, columns = [1.0*inch, #trials
                                                          1.0*inch, #attempted auth
                                                          1.0*inch, #successful auth
                                                          1.0*inch, #failed conn
                                                          1.0*inch, #USC
                                                         ])
            NoteText=""" Note: Abbreviations used: USC-User Specified Criteria,AR-Authentication Rate """
            MyReport.InsertParagraph(NoteText)
            iteration_count=-1
            fail_count =0
            fail_perc  =0
            pass_count= 0
            for each_tup in Results:
               iteration_count=iteration_count+1
               for each_value in each_tup:
                   if each_value == 'FAIL':
                      fail_count=fail_count+1
                   if each_value == 'PASS':
                      pass_count= pass_count+1
            MyReport.InsertHeader( "User Specified P/F criteria" )
            ConfigParameters = [ ( 'Parameter', 'User specified Value', 'Overall Result' ),
                                 ( 'Minimum Expected Authentications',"%s percent" %(self.UserPassFailCriteria['ref_min_auth']*100) , "Total:%s, PASS:%s, FAIL:%s and INVALID:%s" %(iteration_count, pass_count,fail_count,(iteration_count-pass_count-fail_count) ))]
            userspecifiedtext= """ With User specified Pass/Fail Criteria feature, user can decide the criteria for pass or fail of the test.
            User can configure the minimum expected clients based on which the test is evaluated to Pass/Fail"""
            MyReport.InsertParagraph (userspecifiedtext)
            if fail_count > 0:
                self.FinalResult =3
            MyReport.InsertParameterTable( ConfigParameters, columns = [ 3.0*inch, 1.25*inch, 3.0*inch ] ) # 6-inch total

        else:  
            MyReport.InsertDetailedTable( Results, columns = [1.0*inch, #trials
                                                          1.0*inch, #attempted auth
                                                          1.0*inch, #successful auth
                                                          1.0*inch, #failed conn
                                                         ])

        MyReport.InsertHeader("Configuration")
        MyReport.InsertParagraph("The following table shows the parameters set for the test.")        
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description'),
                            ( 'Transmit Time', "%d sec" % ( self.IntendedTransmitTime ), "Trial duration (seconds) - i.e., duration of test traffic" ),
                            ( 'Number of Trials', "%d" % ( self.Trials ), "Number of times measurements are repeated for averaging" ),
                            ( 'Settle Time', "%d sec" % (self.SettleTime), 'Idle time after client authentication transmission completes' ) ,                            
                            ( 'Intended Authentication Rate', "%d" % ( self.authRate ), "Intended Authentication Rate of Clients (auth/sec)" ),
                            ( 'Result Sample Time', "%d" % ( self.resultSampleTime ), "Result Sample Time (sec)" ),
                            ]
        
        MyReport.InsertParameterTable(ConfigParameters, columns=[2.0*inch, 1.0*inch, 3.25*inch])
        
        if self.clientType == 'mc':
            MyReport.InsertHeader( "Access Point Information" )
            MyReport.InsertParagraph( RSSIdetails )
            MyReport.InsertDetailedTable( self.AnalyizeRSSIdata( WaveEngine.ReadAPinformation() ),                
                                          columns = [ 1.5*inch,
                                                      0.60*inch,
                                                      1.25*inch,
                                                      1.55*inch,
                                                      0.40*inch,
                                                      0.40*inch,
                                                      0.40*inch,
                                                      ] )
            MyReport.InsertParagraph( RSSIdetails2 )

        # other info section
        MyReport.InsertHeader( "Other Information" )
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        #Hack to stop printing the document
        if self.generatePdfReportF:
            MyReport.Print()
            
    def run(self):
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)
        try:
            self.ExitStatus = 0
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()      
            self.startTest()
            self.PrintReport()
            self.SaveResults() 
            self.ExitStatus =self.FinalResult
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus
                
    def createClientLists(self, waveClientTableStore, waveSecurityStore):
        #After the changes involving the creation of self.clientgroupObjs, we
        #don't need this method, but currently left to not go on the cleanup
        #work. self.SourceClients presence is preserved
    
        self.SourceClients = []
        
        for groupName in self.clientgroupObjs:
            if self.clientgroupObjs[groupName].enabled:
                groupTuple = self.clientgroupObjs[groupName].groupTuple
                self.SourceClients.append(groupTuple)
    
############################ rearrangeClientList ###############################
# Separated and grouped the clients based on their ports 
# Returns: a dict of list of clients by ports    
    def rearrangeClientList(self):
        listOfClientPerPortDict = {}   
        orderedListofClients = []     
        
        for client in self.ListOfClients.keys():
            clientPortName = self.ListOfClients[client][1]
            if clientPortName in listOfClientPerPortDict.keys():
                listOfClientPerPortDict[clientPortName].append(client)
            else:
                listOfClientPerPortDict[clientPortName] = []    
                listOfClientPerPortDict[clientPortName].append(client)
        
        ii = 0
        jj = 0               
        while ii < len(self.ListOfClients.keys()):
            for ports in listOfClientPerPortDict.keys():
                if jj < len(listOfClientPerPortDict[ports]):
                    orderedListofClients.append(listOfClientPerPortDict[ports][jj])
                    ii += 1
            jj += 1 
        
        return orderedListofClients    
    
    def getInfo(self):
        """
        Returns blurb describing test for use in the GUI.
        """

        msg = "The AAA Authentication Rate test measures the performance of AAA servers. The test generates a large number and variety of client connections using 802.1x authentication transactions at very high rates to the authentication server, enabling you to determine the actual authentication rate supported by the system under test (SUT)."

        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        return self.finalGraphs

##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    parser.add_option("-l", "--savelogs",
                    dest="logs", action="store_true", default=False,
                    help="save hardware logs after test")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    # options.logs = True/False
    
    # Create the test
    userTest = Test()
    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )
    if options.logs:
        userTest.SavePCAPfile = True
    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)
