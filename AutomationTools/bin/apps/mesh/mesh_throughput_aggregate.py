#mesh_throghput_aggregate
#
# Objective: In a mesh network, measure the throughput of all hops at the
#            same time.  Uses a many-to-one flow distribution, where the many is
#            the Wireless side.
#
import sys, time, traceback
from basetest import *
from mesh_common import *
import WaveEngine
from CommonFunctions import *
from optparse import OptionParser
from vcl import *
from odict import *

class Test(MeshCommon, BaseTest):
    def __init__(self):
        BaseTest.__init__(self)
        ############# Hardware definition ####################
        """
        The CardMap defines the WaveBlade ports that will be available for the test.
        Field Definitions:                                                     
          PortName -    Name given to the specified WaveBlade port. This is a user defined name. 
          ChassisID -   The WT90/20 Chassis DNS name or IP address. Format: 'string' or '0.0.0.0'
          CardNumber -  The WaveBlade card number as given on the Chassis front panel.
          PortNumber -  The WaveBlade port number, should be equal to 0 for current cards. 
          Channel -     WiFi channel number to use on the port. 
          Autonegotiation - Ethernet Autonegotiation mode. Valid values: 'on', 'off', 'forced'.
          Speed -       Ethernet speed setting if not obtained by autonegotiation. Valid values: 10, 100, 1000
          Duplex -      Ethernet Duplex mode if not obtained by autonegotiation. Valid values: 'full', 'half'
        Field Format: dictionary
          For Wifi Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <Channel> ),
          For Ethernet Cards - 
              <PortName>: ( <ChassisID>, <CardNumber>, <PortNumber>, <autoNegotiation>, <speed>, <duplex> ),
        """
        self.CardMap = { 'WT90_E1': ( 'wt-tga-xx-xx', 1, 0, 'on', 100, 'full' ),
                         'WT90_W1': ( 'wt-tga-xx-xx', 2, 0,   1 ),
                         'WT90_W2': ( 'wt-tga-xx-xx', 3, 0,   4 ),
                         'WT90_W3': ( 'wt-tga-xx-xx', 4, 0,  11 ),
                         'WT90_W4': ( 'wt-tga-xx-xx', 5, 0,  54 )
                       }

        ############# Description of Client setups #######################
        """             
        ClientOptions defines the options available when setting up clients
        Field Definitions:
          PhyRate -   The 802.11 phy rate to apply to all data frames originating from the client.
                      Valid values are all legally defined values
          Sifs -      (optional) Short Interframe Space Value. Units: microseconds
          SlotTime -  (optional) Units: microseconds
          AckTimeout -(optional) Time to wait for an ACK before starting a retry. Units: microseconds
        Field Format: dictionary
          'PhyRate': <rate>, 'Sifs': <sifsValue>, 'SlotTime': <slotValue>, 'AckTimeout': <AckTimeouValue>          
        """
        self.ClientOptions = {'PhyRate': 54, 'Sifs': 16, 'SlotTime': 9, 'AckTimeout': 350}

        """
        Security Options is dictionary of passed security parameters.  It has a mandatory key of 'Method'
        and optional ekys depending upon the particular security chose.  Some common one defined:
        """
        Security_None = {'Method': 'NONE'}
        Security_WEP  = {'Method': 'WEP-OPEN-128', 'KeyId': 0, 'NetworkKey': '00:00:00:00:00:00' }
        Security_WPA2 = {'Method': 'WPA2-EAP-TLS', 'Identity': 'anonymous', 'Password' : 'whatever'}
          
        """
        To setup clients for the test they will be placed into client groups. Each group is assigned to
        a logical port. Many different client groups can be defined and a port may have more than one group
        assigned to it. The client groups are divided between source(orginating traffic) and destination
        (receiving traffic). 
        Field Definitions:
          GroupName -  User defined name given to the client Group
          PortName -   Logical port name defined the CardMap.
          BSSID/SSID - The BSSID or SSID to which this client group will associate. BSSID will be in 
                       the form 00:11:22:33:44:55. SSID will be an ASCII text string. A BSSID of 00:00:00:00:00:00
                       tells the system to pick the first on on the list.
          MACaddress - The MAC address to use. Using the word 'DEFAULT' wiil cause a unique address to be
                       generated by the system. 
          IPaddress -  The Base IP address to use for this client group. Individual addresses for each client
                       in the group will be derived from the base IP address. An address of 0.0.0.0 implies that
                       DHCP will be used to obtain the client IP address. 
          SubNet    -  SubNet mask 
          Gateway -    Gateway address. 
          IncrTuple -  This is tuple of three values in the form (<count>, <MacIncrByte>, <IpIncrByte>). <count>
                       is the number of clients to create, <MacIncrByte> is the byte in the six byte MAC address
                       to increment (e.g. 00:00:00:00:10:02); Use the keyword 'DEFAULT' for automatic MAC incrementing.
                       <IpIncrByte> is the byte in the four byte IP address to increment (e.g. 0.0.0.1 will increment the
                       last byte by 1). 
                       NOTE: An empty tuple - () means that just one client is being defined. 
          Security -   Name of security policy to use for this client group. 'NONE' will cause open security. 
                       Security policies only apply to WiFi clients. 
          Options -    Reference to a client option list as defined above. 
        Field Format: a list of tuples
          ( <GroupName>, <PortName>, <BSSID/SSID>, <MACaddress>, <IPaddress>, <SubNet>, <Gateway>, ( <IncrTuple> ), Security, <options> ),
          ( <GroupName2>, <PortName2>, <BSSID/SSID>, <MACaddress2>, <IPaddress2>, <SubNet2>, <Gateway2>, ( <IncrTuple2> ), Security2, <options2> )
        """
        self.meshGatewayClients = [ ('ClientEth', 'WT90_E1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.2', '255.255.255.0', '192.168.1.1', (), Security_None, {} )] 
        #Hop 1 is the closest to the Etherent, while hop 10 is the farthest
        self.meshHopClients    = [ [], [], [], [], [], [], [], [], [], [] ]
        self.meshHopClients[1] = [ ('ClientUno', 'WT90_W1', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.100', '255.255.255.0', '192.168.1.1', (), Security_None, self.ClientOptions)]
        self.meshHopClients[2] = [ ('ClientDuo', 'WT90_W2', '00:00:00:00:00:00', 'DEFAULT', '192.168.1.200', '255.255.255.0', '192.168.1.1', (), Security_None, self.ClientOptions)]

        ################### First Level Test Parameters ##########################
        """
        The parameters in this group need to be set by the user to define the primary
        test configuration. 
        FrameSizeList - List of frame sizes to use in performing the test. This is the
                        primary parameter used in reporting results. Units: bytes 
        Trials -        The number of unique trials to attempt for each combination of the above parameters.
        TransmitTime -  This is the amount of time for a test iteration to execute. RFC2544 recommends a time from
                        30-240 seconds. Units: seconds.
        SettleTime -    Amount of time the test will wait for activity to settle or propagate through the SUT
                        before taking the measurements. RFC2544 recommends 2 seconds.  Units: seconds
        AgingTime -     The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to
                        zero unless the DUT/SUT resets during the iteration and needs some extra time to recover.
        """
        self.FrameSizeList  = [ 128, 256, 1024 ]
        self.Trials         =  1 
        self.TransmitTime   = 10.0
        self.SettleTime     =  2.0
        self.AgingTime      =  0.0
          
         #___________________________________PASS/FAIL TEL_________________________________________________
        """
        Used Defined Test Pass/Fail criteria.
        UserPassFailCriteria['user']              - user defined pass/fail criteria enable/disable
        UserPassFailCriteria['ref_tput_mode']     - specify the reference throughput mode to calculate the pass/fail
                                                    criteria (percentage or specify). If percentage is selected
                                                    the reference throughput rate has to be in percentage of
                                                    Theoretical Medium capacity for the frame size given.
                                                    Else could be specified directly in Mbps.
        UserPassFailCriteria['ref_value']         - Specified as either percentage of theoretical Medium capacity
                                                    for the given framesize or directly in Mpbs.
        UserPassFailCriteria['ref_parameter']     - Either Theoretical or
        Default values:
        by default it is disabled and in percentage mode with 50% Theoretical Throughput.

        FinalResult         - The final Result of the particular test case executed, if the user defined
                              pass/fail criteria is enabled. If even one trial or iteration has failed the
                              outcome is fail and the finalResult and hence the exitstatus is 3.
        DbSupport           - Boolean True/False value. If True the results will be logged into Databse Tables.
        """
        self.UserPassFailCriteria = {}
        self.UserPassFailCriteria['user']='False'
        self.TestResult=''
        self.FinalResult=0
        #___________________________________PASS/FAIL TEL_________________________________________________
 

        ##################  Goal Seeking parameters  ##############################
        """
        The goal seeking parameters are used to define how the goal seeking algorithm will arrive at a solution.
        SearchMinimum -           The lower boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values less than this.  Unit is in SUT's frames/second or percent if the last character is a '%'
        SearchMaximum -           The upper boundry for the goal seeking algorthim.  The algorthim will not search for
                                  values higher than this.  The binary search algorithm will use this as the inital value.
                                  If it passed, then the test is complete.  Otherwise the next value is half way between
                                  the SearchMinimum and SearchMaximum.  Unit is in SUT's frames/second or percent if
                                  the last character is a '%'
        SearchResolutionPercent - Determines how precise the search for the final result needs to be. For instance,
                                  a value of 0.1 means that the search will stop if the current result is within 0.1% 
                                  of the previous iteration result. 
        SearchAcceptLossPercent - Determines how much packet loss will be acceptable in seeking the throughput result. 
                                  Ordinarily, throughput is defined as the maximum forwarding rate with zero frame loss.
                                  However, since 802.11 is a lossy medium it may not be possible in some circumstances to
                                  achieve zero frame loss. This parameter can be used in those situations to allow the search
                                  process to obtain the throughput goal. 
        """
        self.SearchMinimum           = None
        self.SearchMaximum           = None
        self.SearchStart             = None
        self.SearchResolutionPercent = 0.1
        self.SearchAcceptLossPercent = 0.0

        ####################### Learning parameters ################################
        """
        These paramters are used to train the DUT/SUT about the clients and flows that are used during the test.   Loss is not
        an issue during learning, only during the actual measurement.
        
        ClientLearningTime - The number of seconds that a Client will flood a DNS request with its source IP address.  This is
                             used to teach the AP about the existance of a client if Security or DHCP is not suffiecient.
        ClientLearningRate - The rate of DNS request the client will learn with in units of frames per second.
        FlowLearningTime   - The number of seconds that the actual test flows will send out learning frames to populate the
                             DUT/SUT forwarding table.  The rate is at the configure test rate. 
        FlowLearningRate   - The rate of flow learning frames are transmitted in units of frames per second.  This should be set
                             lower than the actual offered loads.
        """
        self.ClientLearningTime = 0
        self.ClientLearningRate = 10
        self.FlowLearningTime   = 1
        self.FlowLearningRate   = 100

        ###################### Logging Parameters #################################
        """
        These parameters determine the how the output of the test is to be formed. 
        CSVfilename -       Name of the output file that will contain the primary test results. This file will be in CSV format.
                            This name can include a path as well. Otherwise the file will be placed at the location of the calling
                            program. 
        ReportFilename -    Name of the output file that will contain a formatted report with graphs, explainations, diagrams and
                            the CSV data.  This file is in PDF format. This name can include a path as well. Otherwise the file will
                            be placed at the location of the calling program.
        LoggingDirectory -  Location for putting the remaining test results files.
        SavePCAPfile -      Boolean True/False value. If True a PCAP file will be created containing the detailed frame data that
                            was captured on each WT-20/90 port. 
        DetailedFilename -  Name of the file for capturing the test details. This file will be put in the LoggingDirectory. 
        """
        self.CSVfilename      = 'Results_mesh_throghput_aggregate.csv'
        self.ReportFilename   = 'Report_mesh_throghput_aggregate.pdf'
        self.LoggingDirectory = "logs"
        self.SavePCAPfile     = False
        self.DetailedFilename = 'Detailed_mesh_throghput_aggregate.csv'

        ####################### Timing parameters ################################
        """
        These parameters will effect the performance of the test. They should only be altered if a specific
        problem is occuring that keeps the test from executing with the DUT. 
        
        BSSIDscanTime -     Amount of time to allow for scanning during the BSSID discovery process. Units: seconds
        AssociateRate -     The rate at which the test will attempt to associate clients with the SUT. This includes the time
                            required to complete .1X authentications. 
                            Units: associations/second. Type: float
        AssociateRetries -  Number of attempts to retry the complete association process for each client in the test.
        AssociateTimeout -  Amount of time the test will wait for a client association to complete before considering iteration
                            a failed connection. Units: seconds; Type: float
        ARPRate -           The rate at which the test will attempt issue ARP requests during the learning phase. 
                            Units: ARPs/second; Type: float
        ARPRetries -        Number of attempts to retry any give ARP request before considering the ARP a failure. 
        ARPTimeout -        Amount of time the test will wait for an ARP response before retrying or failing.
        UpdateInterval -    Interval at which the test will attempt to update test status back to the display console. 
                            Units: seconds
        DisplayPrecision -  Number of decimal places to use in reporting results. 
        ClientContention -  Valid probability is between 0% and 100%.  The number should be interpreted as the "probability" 
                            of contention, and will be specified as the maximum probability of the [n-1,n] segment.
                            Example, specifying 50 means that the probability of generating a FCS error frame is between 40%
                            and 50%.  Only Values of 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, and 100 should be set.
        """
        self.BSSIDscanTime     =   1.5
        self.AssociateRate     =  10.0
        self.AssociateRetries  =   0
        self.AssociateTimeout  =   5.0
        self.ARPRate           =  10.0
        self.ARPRetries        =   3
        self.ARPTimeout        =  10.0
        self.UpdateInterval    =   0.5
        self.DisplayPrecision  =   3
        self.testOptions['ContentionProbability']  =   0

        #################  Flow parameters  #################################
        """
        These parameters determine the type of data frames and flows to be used in the test. 
        
        FlowOptions -   Dictionary of options used to configure data flows. 
                        Field Definitions:
                            Type     - Packet or frame type. Valid values: 'UDP', 'TCP', 'IP', 'ICMP'
                            srcPort  - Source Port number used in the UDP or TCP header
                            destPort - Destination Port number used in the UDP or TCP header
                            PhyRate  - The PhyRate for wireless cards.  Separate from the management frames.
        FlowDirection - Deteremide the direction of the flows:
                            up   - Wireless to Etherenet
                            down - Etherenet to Wireless
                            both - Bidirectional ( up + down )
        """
        self.FlowOptions    = {'Type': 'UDP', 'srcPort': 5902, 'destPort': 5903, 'PhyRate': 54 }
        self.FlowPattern = Enum("up down both")
        self.FlowDirection  = self.FlowPattern.down

########################## DO NOT MODIFY BELOW HERE ##########################
        # Include the version 
        self.version = '$Revision: 1.16 $' 
        self.date    = '$Date: 2007/07/13 18:32:29 $' 

        # What parameters supported by the real time stats
        self.RealtimeData = {'Intended Load BPS': 0, 'Offered Load BPS': 0, 'Forwarding Rate BPS': 0 }
        self.meshNumOfHopsDict = {}

        ################## Report parameters #################################
        """
        These parameters are used in the PDF report generator to create a table
        with frame sizes and the binary search parameters (min value, max value,
        starting value)
        """
        self.reportMin = []
        self.reportMax = []
        self.reportStart = []
        self.reportResolution = []

    def getTestName(self):
    
        return 'mesh_throughput_aggregate'
    
    def loadData( self,
                  waveChassisStore,
                  wavePortStore,
                  waveClientTableStore,
                  waveSecurityStore,
                  waveTestStore,
                  waveTestSpecificStore,
                  waveMappingStore,
                  waveBlogStore ):
        """
        Load dictionary data into test.
        Raise exception on error
        """
        # FIXME - support for the new client objects 
        # load data into base class
        BaseTest.loadData( self,
                           waveChassisStore,
                           wavePortStore,
                           waveClientTableStore,
                           waveSecurityStore,
                           waveTestStore,
                           waveTestSpecificStore,
                           waveMappingStore,
                           waveBlogStore )
        #These are the test specific parameters that get passed down from the GUI for the test execution
         #___________________________________PASS/FAIL TEL_________________________________________________
        if  waveTestStore['LogsAndResultsInfo'].has_key('db'):
            if  waveTestStore['LogsAndResultsInfo']['db'] == "True":
                self.DbSupport = waveTestStore['LogsAndResultsInfo']['db']
        if  waveTestStore['LogsAndResultsInfo'].has_key('pf'):
          if  waveTestStore['LogsAndResultsInfo']['pf'] == "True":
                self.UserPassFailCriteria['user'] = waveTestStore['LogsAndResultsInfo']['pf']
                #####  If no info available from config file then Setting to the defaults.......
                if waveTestSpecificStore['mesh_throughput_aggregate']['ReferenceTPUTMode']:
                   Ref_TPUTMode= str (waveTestSpecificStore['mesh_throughput_aggregate']['ReferenceTPUTMode'])
                   if (Ref_TPUTMode == "Theoretical" or Ref_TPUTMode == "MediumCapacity"):
                       self.UserPassFailCriteria['ref_parameter']=str (waveTestSpecificStore['mesh_throughput_aggregate']['ReferenceTPUTMode'])
                   else:
                       WaveEngine.OutputstreamHDL("\nThe value for the parameter ReferenceTPUTMode should be either Theoretical/MediumCapacity\n",WaveEngine.MSG_ERROR)
                       raise  WaveEngine.RaiseException
                else:
                    #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ReferenceTPUTMode> parameter, using default value and proceeding further...\n",WaveEngine.MSG_WARNING)
                    self.UserPassFailCriteria['ref_parameter']= "Theoretical"
                if waveTestSpecificStore['mesh_throughput_aggregate']['ThroughputInputMode']:
                   TputIPMode= str (waveTestSpecificStore['mesh_throughput_aggregate']['ThroughputInputMode'])
                   if (TputIPMode == "Specify" or TputIPMode == "Percentage"):
                       self.UserPassFailCriteria['ref_tput_mode']=waveTestSpecificStore['mesh_throughput_aggregate']['ThroughputInputMode']
                   else:
                       WaveEngine.OutputstreamHDL("\nThe value for the parameter ThroughputInputMode should be either Percentage/Specify\n",WaveEngine.MSG_ERROR)
                       raise  WaveEngine.RaiseException
                else:
                   #WaveEngine.OutputstreamHDL("\nUser has not given the value for <ThroughputInputMode> parameter, using default value and proceeding further...\n",WaveEngine.MSG_WARNING)
                   self.UserPassFailCriteria['ref_tput_mode']="Percentage"
                if waveTestSpecificStore['mesh_throughput_aggregate']['AcceptableThroughput']:
                   if float ( waveTestSpecificStore['mesh_throughput_aggregate']['AcceptableThroughput']) >=0:
                       self.UserPassFailCriteria['ref_value']=waveTestSpecificStore['mesh_throughput_aggregate']['AcceptableThroughput']
                   else:
                       WaveEngine.OutputstreamHDL("\nThe value for the parameter AcceptableThroughput should be a positive number\n",WaveEngine.MSG_ERROR)
                       raise  WaveEngine.RaiseException
                else:
                   #WaveEngine.OutputstreamHDL("\nUser has not given the value for <AcceptableThroughput> parameter, using default value and proceeding further...\n",WaveEngine.MSG_WARNING)
                   self.UserPassFailCriteria['ref_value']= 50
        #___________________________________PASS/FAIL TEL_________________________________________________

        self.SearchMode = waveTestSpecificStore['mesh_throughput_aggregate']['Mode']
        if waveTestSpecificStore['mesh_throughput_aggregate']['MinSearchValue'] == "Default":
            self.SearchMinimum = None
        else:
            self.SearchMinimum = waveTestSpecificStore['mesh_throughput_aggregate']['MinSearchValue']
        if waveTestSpecificStore['mesh_throughput_aggregate']['MaxSearchValue'] == "Default":
            self.SearchMaximum = None
        else:
            self.SearchMaximum = waveTestSpecificStore['mesh_throughput_aggregate']['MaxSearchValue']
        if waveTestSpecificStore['mesh_throughput_aggregate']['StartValue'] == "Default":
                self.SearchStart = None
        else:
            self.SearchStart = waveTestSpecificStore['mesh_throughput_aggregate']['StartValue']
        if waveTestSpecificStore['mesh_throughput_aggregate']['SearchResolution'] == "Default":
            self.SearchResolutionPercent = None
        else:
            self.SearchResolutionPercent = waveTestSpecificStore['mesh_throughput_aggregate']['SearchResolution']           
            
        self.SearchAcceptLossPercent = float(waveTestStore['TestParameters']['LossTolerance'])
        frameSizeList = waveTestSpecificStore['mesh_throughput_aggregate']['FrameSizeList']
        if (len(frameSizeList) != 0):
            self.FrameSizeList = []
            for eachFrameSize in frameSizeList:
                self.FrameSizeList.append(int(eachFrameSize))
        
        #Determine the direction of flow
        if waveMappingStore[4].lower() == 'bidirectional':
            self.FlowDirection = self.FlowPattern.both
        elif waveMappingStore[4].lower() == 'unidirectional':
            #Since we have only 1 gateway in the test bed,
            #the length of the source list can determine the
            #direction of flow
            #If the length of Source List which is waveMappingStore[1]
            #is more than 1 (which means there are multiple hops, as there
            #can only be a single gateway, hence the flow direction is from
            #hops to gateway which is upstream else the flow direction is
            #from gateway to hops which is downstream.
            if waveMappingStore[0] == "0":
                self.FlowDirection = self.FlowPattern.down
            elif waveMappingStore[0] == "1":
                self.FlowDirection = self.FlowPattern.up
        self._loadTrafficMapping(waveMappingStore, waveClientTableStore)
        #Define the self.meshGatewayClients and self.meshHopClients list here,
        #so that it can be used by the BuildClientTable() method.
        self.meshGatewayClients = []
        self.meshHopClients = []
        self.meshGatewayClients, self.meshHopClients = self.Import_MeshClientLists(waveClientTableStore, wavePortStore, waveSecurityStore, waveMappingStore)
        # all good
        return True    

    def PrintRealtimeStats(self, TXstate, Timeleft, ElapsedTime, PassedParameters):
        TotalTX = 0
        TotalRX = 0
        PktType = PassedParameters['Type'] 
        bpf = PassedParameters['BitsPerFrame']
        for Portname in PassedParameters['CardList']:
            WaveEngine.VCLtest("stats.read('%s')" % (Portname))
            if PktType == 'TCP':
                TotalTX += stats.txTcpFramesOkRate
                TotalRX += stats.rxTcpPacketsOkRate
            elif PktType == 'UDP':
                TotalTX += stats.txUdpFramesOkRate
                TotalRX += stats.rxUdpPacketsOkRate
            else:
                TotalTX += stats.txIpPacketsOkRate
                TotalRX += stats.rxIpPacketsOkRate
        OLOADtext = Float2EngNotation(bpf * TotalTX, self.DisplayPrecision)
        FRtext    = Float2EngNotation(bpf * TotalRX, self.DisplayPrecision)
        self.RealtimeData['Offered Load BPS']    = bpf * TotalTX
        self.RealtimeData['Forwarding Rate BPS'] = bpf * TotalRX
        # Change pkt/sec to bps per VPR 3030
        WaveEngine.OutputstreamHDL("\r%s OLOAD=%sbps, FR=%sbps, (%2s %4.1f secs)" % (PassedParameters['Title'], OLOADtext, FRtext, TXstate, ElapsedTime), WaveEngine.MSG_OK)
                    
    def startTest(self, FuncRealTime):
        if self.UserPassFailCriteria['user']=='True':
                self.ResultsForCSVfile.append( ('Frame Size', 'Trial', 'Theoretical Throughput pkts/sec', 'Theoretical Throughput bits/sec', 'ILOAD pkts/sec', 'Throughput pkts/sec', 'Throughput bits/sec','USC') )
        else:
                self.ResultsForCSVfile.append( ('Frame Size', 'Trial', 'Theoretical Throughput pkts/sec', 'Theoretical Throughput bits/sec', 'ILOAD pkts/sec', 'Throughput pkts/sec', 'Throughput bits/sec') )
        PassedParam = {'CardList': self.CardList, 'Type': self.FlowOptions['Type']}
        ActiveGroup = "XmitGroup"
        calcThroughput = self.getMediumCapacityCalculator()
        
        for eachSize in self.FrameSizeList:
            FrameSize = int(eachSize)
            MaximumHops = len(self.meshHopClients)
            for TrialNumber in range(1, 1 + self.Trials):
                
                #Do the Flow learning
                if self.FlowLearningTime > 0.0:
                    PassedParam['Title'] = "Training DUT/SUT:"
                    PassedParam['BitsPerFrame'] = 512
                    self._transmitIteration(self.FlowLearningTime, 0, self.UpdateInterval, ActiveGroup, True, FuncRealTime, PassedParam)
                    WaveEngine.OutputstreamHDL("\n", WaveEngine.MSG_OK)
       
                    if self.FlowOptions['Type'] == 'TCP':
                        # Wait for 2 seconds to make sure we get all the TCP ACKs
                        WaveEngine.Sleep(2, 'TCP settling time')        
       
                #"""
                #traffic = 'Wireless at on end' is used as part of quick fix to incorporate
                #user specified throughput capability into mesh tests.
                #"""
                #(TheoreticalMFR, 
                #    TheoreticalBPS) = self._getTheoretRatesBasedOnWEcalc(FrameSize,
                #                                                        traffic = 'Wireless at on end')
                  
                  
                # The _getBPSfromMFR method needs revision.  
                TheoreticalMFR = calcThroughput(FrameSize)
                TheoreticalBPS = self._getBPSfromMFR(FrameSize, TheoreticalMFR)
                PassedParam['BitsPerFrame'] = 8 * FrameSize
                PassedParam['FrameSize'] = FrameSize

                #Initialize the binary search logic
                SearchLogic = WaveEngine.BinarySerach()
                if self.SearchMinimum:
                    if isnum(self.SearchMinimum):
                        _minimum = float(self.SearchMinimum) / float(len(self.FlowList))
                    else:
                        if isnum(self.SearchMinimum[:-1]):
                            _minimum = (float(self.SearchMinimum[:-1]) / 100.0) * (TheoreticalMFR / float(len(self.FlowList)))
                        else:
                            _minimum = 0
                            WaveEngine.OutputstreamHDL("Warning: Can not understand minimum rate of '%s', using default.\n" % (self.SearchMinimum), WaveEngine.MSG_WARNING)
                else:
                    _minimum = 0.01 * (TheoreticalMFR / float(len(self.FlowList)))
                if _minimum == 0:    # min value can't be 0 fps
                    _minimum = 1     
                self.reportMin.append(_minimum * len(self.FlowList))
                              
                if self.SearchMaximum:
                    if isnum(self.SearchMaximum):
                        _maximum = float(self.SearchMaximum) / float(len(self.FlowList))
                    else:
                        if isnum(self.SearchMaximum[:-1]):
                            _maximum = (float(self.SearchMaximum[:-1]) / 100.0) * (TheoreticalMFR / float(len(self.FlowList)))
                        else:
                            _maximum = 1.50 * TheoreticalMFR / float(len(self.FlowList))
                            WaveEngine.OutputstreamHDL("Warning: Can not understand maximum rate of '%s', using default.\n" % (self.SearchMaximum), WaveEngine.MSG_WARNING)
                else:
                    # This is changed for VPR 2919 - The DUT was dying if offerered too much traffic
                    _maximum =  1.50 * TheoreticalMFR / float(len(self.FlowList))
                self.reportMax.append(_maximum * len(self.FlowList))
                    
                SearchLogic.minimum(_minimum)
                SearchLogic.maximum(_maximum)
                if self.SearchStart:
                    if isnum(self.SearchStart):
                        SearchLogic.NextValue = float(self.SearchStart) / float(len(self.FlowList))
                    else:
                        if isnum(self.SearchStart[:-1]):
                            SearchLogic.NextValue = (float(self.SearchStart[:-1]) / 100.0) * (TheoreticalMFR / float(len(self.FlowList)))
                        else:
                            SearchLogic.NextValue = 0.50 * (TheoreticalMFR / float(len(self.FlowList)))
                            WaveEngine.OutputstreamHDL("Warning: Can not understand maximum rate of '%s', using default.\n" % (self.SearchStart), WaveEngine.MSG_WARNING)
                    _start = SearchLogic.NextValue
                else:                    
                    _start = 0.50 *  TheoreticalMFR / float(len(self.FlowList))  # default to 0.5 * Theoritical MFR
                self.reportStart.append(_start * len(self.FlowList))
                
                searchResolutionPercent = 5
                if self.SearchResolutionPercent:
                    if isnum(self.SearchResolutionPercent):
                        _resol = float(self.SearchResolutionPercent)
                        searchResolutionPercent = float(self.SearchResolutionPercent)*len(self.FlowList)/float(TheoreticalMFR)*100
                    else:
                        if isnum(self.SearchResolutionPercent[:-1]):
                            _resol = (float(self.SearchResolutionPercent[:-1]) / 100.0)
                            if _resol <= 0.0:
                                _resol = 0.00001
                            if _resol > 1.0:
                                _resol = 1.0
                            _resol = _resol * (TheoreticalMFR / float(len(self.FlowList)))
                            searchResolutionPercent = self.SearchResolutionPercent.rstrip("%")
                        else:
                            _resol = 0.05 * (TheoreticalMFR / float(len(self.FlowList)))
                            WaveEngine.OutputstreamHDL("Warning: Can not understand search resolution value of '%s', using default.\n" % (self.SearchStart), WaveEngine.MSG_WARNING)
                else:                    
                    _resol = 0.05 * (TheoreticalMFR / float(len(self.FlowList)))    # default to 0.05 * Theoritical MFR                                    
                self.reportResolution.append(_resol * len(self.FlowList))
                SearchLogic.resolutionPercent(searchResolutionPercent)
        
                #Now do the Iterrations
                while SearchLogic.searching():
                    WaveEngine.WriteDetailedLog(['FrameSize', FrameSize, 
                                                 'IntendedRate', SearchLogic.query(),
                                                 'Trial:', TrialNumber])
                    
                    WaveEngine.ModifyFlows(self.FlowList, {'FrameSize': FrameSize, 'RateMode': 'pps', 'IntendedRate': SearchLogic.query() , 'NumFrames': int(SearchLogic.query() * self.TransmitTime), 'Type' : self.FlowOptions['Type']})
                    WaveEngine.ClearAllCounter(self.CardList)
                    WaveEngine.WriteAPinformation(self.ListOfClients)
                    self.RealtimeData['Intended Load BPS'] = 8 * FrameSize * SearchLogic.query() * len(self.FlowList)
                    PassedParam['Title'] = "ILOAD=%sbps," % (Float2EngNotation(self.RealtimeData['Intended Load BPS'], self.DisplayPrecision))
                    WaveEngine.OutputstreamHDL("Frame: %d Attempting %.1f pkts/sec\n" % (FrameSize, SearchLogic.query() * len(self.FlowList)), WaveEngine.MSG_OK)
                    self._transmitIterationWithBlogCards(self.TransmitTime, self.SettleTime, self.UpdateInterval, ActiveGroup, True, FuncRealTime , PassedParam, self.waveBlogStore )
        
                    # This is a hack since flows counter do not work with less than 64 byte frames
                    if FrameSize < 64:
                        (OLOAD, OLOAD_bps, FR, FR_bps, FrameLossRate) = \
                        WaveEngine.MeasurePort_OLOAD_FR_LOSSRate(self.CardList, 
                                                                 self.TransmitTime, 
                                                                 self.FlowOptions['Type'],
                                                                FrameSize)
                        FlowStatsDict['OLOAD']         = OLOAD
                        FlowStatsDict['OLOAD bps']     = OLOAD_bps
                        FlowStatsDict['FR']            = FR
                        FlowStatsDict['FR bps']        = FR_bps
                        FlowStatsDict['FrameLossRate'] = FrameLossRate
                    else:
                        FlowStatsDict = WaveEngine.MeasureFlow_Statistics(self.FlowList, self.TransmitTime)
                    if FlowStatsDict['OLOAD'] == 0:
                        WaveEngine.OutputstreamHDL(" FAIL (nothing transmitted)\n" , WaveEngine.MSG_WARNING)
                        SearchLogic.FAIL()
                    elif FlowStatsDict['FrameLossRate'] > self.SearchAcceptLossPercent:
                        if FlowStatsDict['FrameLossRate'] > 0.0001:
                            WaveEngine.OutputstreamHDL(" FAIL (loss of %s%%)\n" % \
                                (str(EngNotation2Int(Float2EngNotation(FlowStatsDict['FrameLossRate'], 2)))), \
                                WaveEngine.MSG_WARNING)
                        else:
                            WaveEngine.OutputstreamHDL(" FAIL (loss less than 0.0001%%)\n", WaveEngine.MSG_WARNING)
                        SearchLogic.FAIL()
                    else:
                        WaveEngine.OutputstreamHDL(" PASS\n", WaveEngine.MSG_SUCCESS)
                        TputStats = FlowStatsDict.copy()
                        TputStats['ILOAD'] = SearchLogic.query() * len(self.FlowList)
                        SearchLogic.PASS()

                    # Certain DUT do not like the constant traffic
                    if self.AgingTime > 0:
                        WaveEngine.Sleep(self.AgingTime, 'DUT/SUT recovery time,')

                # Print results for that frame size
                if self.UserPassFailCriteria['user']=='True':
                   self.TestResult=''
                   if TputStats['OLOAD bps']== 0:  
                       self.TestResult='INVALID'
                       WaveEngine.OutputstreamHDL("\nTest failed, so applying P/F criteria is invalid\n",WaveEngine.MSG_SUCCESS)
                   else:
                       if self.UserPassFailCriteria['ref_parameter']=="Theoretical":
                              if self.UserPassFailCriteria['ref_tput_mode']=="Percentage":
                                     tmpthroughput = TheoreticalBPS * float(self.UserPassFailCriteria['ref_value'])/100
                                     if TputStats['OLOAD bps'] >= tmpthroughput :
                                              self.TestResult =self.TestResult+ 'PASS'
                                              WaveEngine.OutputstreamHDL("\nIteration has achieved the Throughput mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_SUCCESS)
                                     else:
                                              self.TestResult =self.TestResult+ 'FAIL'
                                              WaveEngine.OutputstreamHDL("\nIteration has failed to achieve the throughput mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_WARNING)

                              elif self.UserPassFailCriteria['ref_tput_mode']=="Specify":
                                     tmpthroughput=int(self.UserPassFailCriteria['ref_value']) 
                                     if TputStats['OLOAD bps'] >= int(self.UserPassFailCriteria['ref_value']):
                                            self.TestResult =self.TestResult+ 'PASS'
                                            WaveEngine.OutputstreamHDL("\nIteration has achieved the  Fwd Rate mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_SUCCESS)
                                     else:
                                            self.TestResult =self.TestResult+ 'FAIL'
                                            WaveEngine.OutputstreamHDL("\nIteration has failed to achieve the throughput mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_WARNING)

                       elif self.UserPassFailCriteria['ref_parameter']=="MediumCapacity" :
                                    MC = TheoreticalMFR
                                    if self.UserPassFailCriteria['ref_tput_mode']=="Percentage":
                                             tmpthroughput = (TputStats['OLOAD bps']*float(self.UserPassFailCriteria['ref_value']))/100
                                             if tmpthroughput >= MC:
                                                      self.TestResult =self.TestResult+ 'PASS'
                                                      WaveEngine.OutputstreamHDL("\nIteration has achieved the Medium Capacity mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_SUCCESS)
                                             else:
                                                       self.TestResult =self.TestResult+ 'FAIL'
                                                       WaveEngine.OutputstreamHDL("\nIteration has failed to achieve the Mediuim Capacity mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_WARNING)

                                    elif self.UserPassFailCriteria['ref_tput_mode']=="Specify":
                                                tmpthroughput=float(self.UserPassFailCriteria['ref_value'])*1000000
                                                if TputStats['OLOAD bps'] >= tmpthroughput:
                                                        self.TestResult = self.TestResult + 'PASS'
                                                        WaveEngine.OutputstreamHDL("\nIteration has achieved the Medium Capacity  mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_SUCCESS)
                                                else:
                                                        self.TestResult = self.TestResult + 'FAIL'
                                                        WaveEngine.OutputstreamHDL("\nIteration has failed to achieve the MediumCapacity mentioned by the User:%s Got:%s\n" %(tmpthroughput,TputStats['OLOAD bps']),WaveEngine.MSG_WARNING)
                       else:
                               WaveEngine.OutputstreamHDL("User has entered wrong keys in configuration File\n",WaveEngine.MSG_WARNING)
                   if self.TestResult == "FAIL" :
                              self.FinalResult = 3
        #___________________________________PASS/FAIL TEL_________________________________________________
 
                if SearchLogic.neverpassed:
                    if self.UserPassFailCriteria['user']=='True':
                              self.ResultsForCSVfile.append( (FrameSize, TrialNumber, TheoreticalMFR, TheoreticalBPS, 0, 0, 0 ,'FAIL') )
                    else: 
                              self.ResultsForCSVfile.append( (FrameSize, TrialNumber, TheoreticalMFR, TheoreticalBPS, 0, 0, 0 ) )
                    WaveEngine.OutputstreamHDL("Error: Framesize=%d failed every pass. No throughput measurement.\n" % (int(FrameSize)), WaveEngine.MSG_ERROR)
                else:
                    if self.UserPassFailCriteria['user']=='True':
                           self.ResultsForCSVfile.append( (FrameSize, TrialNumber, TheoreticalMFR, TheoreticalBPS, TputStats['ILOAD'], TputStats['OLOAD'], TputStats['OLOAD bps'],self.TestResult ) )
                    else: 
                           self.ResultsForCSVfile.append( (FrameSize, TrialNumber, TheoreticalMFR, TheoreticalBPS, TputStats['ILOAD'], TputStats['OLOAD'], TputStats['OLOAD bps'] ) )
                    WaveEngine.OutputstreamHDL("Completed: Throughput for %d byte packets is %.1f pkts/sec (or %s bits/sec)\n" % \
                            (int(FrameSize), TputStats['OLOAD'], Float2EngNotation(TputStats['OLOAD bps'], self.DisplayPrecision)), \
                            WaveEngine.MSG_SUCCESS)
                    if TputStats.has_key('Min Latency'):
                        WaveEngine.OutputstreamHDL("           Latency: min = %sS max = %sS avg = %sS, Jitter = %sS\n" %
                        ( Float2EngNotation(TputStats['Min Latency'], self.DisplayPrecision),
                          Float2EngNotation(TputStats['Max Latency'], self.DisplayPrecision),
                          Float2EngNotation(TputStats['Avg Latency'], self.DisplayPrecision),
                          Float2EngNotation(TputStats['Avg Jitter'], self.DisplayPrecision)), WaveEngine.MSG_SUCCESS)
                WaveEngine.CheckEthLinkWifiClientState(self.CardList, self.ListOfClients)

    # Extract data from the CVS file and puts store it as the object's attribute
    def ParseCVSdata(self, dataFromFile):
        # List if bars used in the Troughput graph
        self._ReportList       = []
        # Data for the Troughput Graph
        self._ReportData   = {}
        # Data for the detailed section of the Report
        self._ReportResults = [('Frame Size', 'Trial', 'Theoretical Throughput pkts/sec', 'Theoretical Throughput bits/sec', 'ILOAD pkts/sec', 'Throughput pkts/sec', 'Throughput bits/sec'),]
        
        # we've removed the theoretical line from the graph & table, 
        # so these 2 variables below are ignored.
        #Theroy_FPS = 0
        #Theroy_BPS = 0
        for eachLine in dataFromFile:
            #print len(eachLine), ':', eachLine 
            if self.UserPassFailCriteria['user']=='True':
                   eachLine=eachLine[:-1]
            if len(eachLine) != 7:
                continue

            (FrameSize, TrialNumber, Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, OLOAD_BPS) = eachLine
            if not isnum(FrameSize):
                #Process Titles
                continue
            FrameSize =int(FrameSize)
            if not FrameSize in self._ReportList:
                self._ReportList.append(FrameSize)

            if self._ReportData.has_key(FrameSize):
                (m,n, TotalOLOAD_FPS, TotalOLOAD_BPS, Count) = self._ReportData[FrameSize]
                self._ReportData[FrameSize] = (Theroy_FPS, Theroy_BPS, TotalOLOAD_FPS + OLOAD_FPS, TotalOLOAD_BPS + OLOAD_BPS, Count + 1)
            else:
                self._ReportData[FrameSize] = (Theroy_FPS, Theroy_BPS, OLOAD_FPS, OLOAD_BPS, 1)
            self._ReportResults.append( (FrameSize, TrialNumber, Theroy_FPS, Theroy_BPS, ILOAD_FPS, OLOAD_FPS, OLOAD_BPS), )

    def PrintReport(self):
        import os.path
        # Text Paragraphs
        Overview1 = "The Aggregate Throughput test identifies the maximum rate at "\
                    "which the system under test (SUT) can forward packets without "\
                    "loss across all nodes in the mesh network."
        Overview2 = "This test determines the throughput rate by using a binary search "\
                    "algorithm. The test starts by offering half the maximum theoretical "\
                    "or user-specified load to the SUT. Packet loss is then measured "\
                    "across the entire mesh network. If packet loss is detected the "\
                    "offered load (OLOAD) is cut in half. If there is no packet loss "\
                    "the OLOAD is doubled. This process continues until the difference "\
                    "between OLOAD values is less than the search resolution setting. "\
                    "The process is repeated for each frame size specified in the test."
        Overview3 = "The test is repeated for each frame size specified in the test. "\
                    "The results are recorded separately for each frame size."

        Overview4 = "The desired measured throughput is as close as possible to theoretical limits of the "\
                    "physical medium.  The higher the throughput, the more data can be used. Most interfaces "\
                    "speeds are reporting in the bit rate of the encoding scheme. Where as throughput measures "\
                    "the usable portion of the data stream."

        Method1 = "The test associates test clients with the SUT ports, including "\
                  "the necessary security protocols and any learning transmissions. "\
                  "The test then generates test traffic between the test clients. "\
                  "The test then calculates throughput according to the procedure "\
                  "specified in RFC 2544. Proprietary signatures and tags are "\
                  "inserted into the test traffic to ensure accurate measurement "\
                  "results. The throughput is measured across all nodes in the "\
                  "mesh network and the weakest node will most likely be the limit."
        Method2 = "This test determines the throughput rate by using a binary "\
                  "search algorithm. The test starts by offering half the maximum "\
                  "theoretical or user-specified load to the SUT. Packet loss "\
                  "is then measured across the entire mesh network. If packet "\
                  "loss is detected the offered load (OLOAD) is cut in half. If "\
                  "there is no packet loss the OLOAD is doubled. This process "\
                  "continues until the difference between OLOAD values is less "\
                  "than the search resolution setting. The process is repeated "\
                  "for each frame size specified in the test."
        Method3 = "The test is repeated for each frame size specified in the "\
                  "test. The results are recorded separately for each frame size."

        RSSIdetails = """SUT details are given below. The received signal strength indication (RSSI) from the SUT is sampled on each port at the start of each trial and averaged over all trials."""
        RSSIdetails2 = """Desired RSSI values are in the range -25 dBm to -35 dBm. If the RSSI is not in this range, the external attenuation should be modified to bring it into this range."""
        IGdetails =     "The table below shows the different frame size bands configured along with their % "\
                        "strike rate. The % strike rate across a given frame size band represents the % knock down "\
                        "rate of a given frame size within a certain trial duration."
        IISdetails =    "The table below lists all the ports that were generating interference during the "\
                        "test run. Also shown are the instants of time (as % offset from the Transmit time) "\
                        "when these ports were fired up to generate the desired percentage of interference in "\
                        "the test bed."

        _minText = "Lower limit of aggregate ILOAD offered to the SUT"
        
        isFps = False
        if self.SearchMinimum:
            if isnum(self.SearchMinimum):
                isFps = True
                _minimum = "%.0f fps" % (float(self.SearchMinimum))
            else:
                if isnum(self.SearchMinimum[:-1]):
                    _minimum = "%.1f%%" % (float(self.SearchMinimum[:-1]))
                else:
                    _minimum = "1%"
                _minText = "Lower limit of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput"
        else:
            _minimum = "1%"
            _minText = "Lower limit of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput"
            
        _maxText = "Upper limit of aggregate ILOAD offered to the SUT"
        if self.SearchMaximum:
            if isnum(self.SearchMaximum):
                _maximum = "%.0f fps" % (float(self.SearchMaximum))
            else:
                if isnum(self.SearchMaximum[:-1]):
                    _maximum = "%.1f%%" % ( float(self.SearchMaximum[:-1]) )
                else:
                    _maximum = "150%"
                _maxText = "Upper limit of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput"
        else:
            _maximum = "150%"
            _maxText = "Upper limit of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput"
                            
        _startText = "Initial value of aggregate ILOAD offered to the SUT"             
        if self.SearchStart:
            if isnum(self.SearchStart):
                _start = "%.0f fps" % (float(self.SearchStart))
            else:
                if isnum(self.SearchStart[:-1]):
                    _start = "%.1f%%" % (float(self.SearchStart[:-1]))
                else:
                    _start = "50%"
                _startText = "Initial value of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput" 
        else: 
            _start = "50%"  
            _startText = "Initial value of aggregate ILOAD offered to the SUT, in percent of theoretical maximum throughput" 
            
        _resolText = "Granularity of measured values"  
        if self.SearchResolutionPercent:
            if isnum(self.SearchResolutionPercent):
                _resol = "%.0f fps" % (float(self.SearchResolutionPercent))
            else:
                _resolText = "Granularity of measured values, in percent of theoretical maximum throughput"
                if isnum(self.SearchResolutionPercent[:-1]):
                    _resol = "%.1f%%" % (float(self.SearchResolutionPercent[:-1]))           
                else:
                    _resol = "5%"
        else:                    
            _resol = "5%"
            _resolText = "Granularity of measured values, in percent of theoretical maximum throughput"

        MyReport = WaveReport(os.path.join(self.LoggingDirectory, self.ReportFilename))
        if MyReport.Story == None:
            # Reportlab is not installed, no use creating a file
            return
        MyReport.Title("Mesh Aggregate Throughput Report", self.DUTinfo, self.TestID )
        MyReport.InsertHeader("Overview")
        MyReport.InsertParagraph(Overview1)
        MyReport.InsertParagraph(Overview2)        
        MyReport.InsertParagraph(Overview3) 
        
        self.ParseCVSdata(self.ResultsForCSVfile)
        GraphWidth  = 6.0 * inch
        GraphHeight = 3.5 * inch
        MyReport.InsertObject(self.CreateThroughputGraph(GraphWidth, GraphHeight, self._ReportList, self._ReportData))
        MyReport.InsertParagraph(Overview4)
        #MyReport.InsertPageBreak()

        MyReport.InsertHeader( "Test Conditions" )
        ConfigParameters = [ ( 'Parameter', 'Value', 'Description' ),
                             ( 'Frame Sizes', str( self.FrameSizeList ), "Frame sizes in bytes" ) ]
        MyReport.InsertParameterTable( ConfigParameters, columns = [ 1.25*inch, 3.0*inch, 1.75*inch ] ) # 6-inch total
        
        MyReport.InsertHeader("Test Configuration")
        ConfigParamters = [('Parameter', 'Value', 'Description'),
                           ('Learning Time', "%d secs" % (self.FlowLearningTime), 
                            'The number of seconds to transmit frames for the DUT/SUT to populate its forwarding tables'),
                           ('Transmit Time', "%d secs" % (self.TransmitTime), \
                            'The number of seconds that the WaveTest will transmit for each iteration.'),
                           ('Settle Time', "%d secs" % (self.SettleTime), \
                            'How many seconds to wait for the DUT/SUT to finish forwarding frames before making the final measurement'),
                           ('AgingTime', "%d secs" % (self.AgingTime), \
                            'The number of seconds the DUT/SUT needs to recover between each iteration.  Normally set to zero.'),
                           ('Number of Trials', "%d" % (self.Trials), \
                            'Number of times the measurement will be repeated.  Multiple trials are used for averaging the measurement.'),
                            ( 'Search Minimum', _minimum, _minText ),
                            ( 'Search Maximum', _maximum, _maxText ),
                            ( 'Starting Point', _start, _startText ),                            
                            ( 'Search Resolution', _resol, _resolText),
                           ]
        
        if self.SearchAcceptLossPercent == 0.0:
            Value = 'Zero'
        else:
            Value = "%s%%" % (str(EngNotation2Int(Float2EngNotation(float(self.SearchAcceptLossPercent), 3))))
        ConfigParamters.append( ('Search Acceptable Loss', Value, 'Determines how much packet loss will be acceptable in seeking the throughput result.'), )
        if self.testOptions['ContentionProbability'] > 0:
            ConfigParamters.append( ('Client Contention', "%d%%" % (self.testOptions['ContentionProbability']) , 'The probability that 2 clients will try to access the media at the same time and create an errored frame.'), )
        MyReport.InsertParameterTable(ConfigParamters, columns=[1.5*inch, 1.25*inch, 3.25*inch])

        if isFps == False: 
            MyReport.InsertHeader("Binary Search Options")
            MyReport.InsertParagraph("The maximum, minimum, starting point and search resolution of aggregate ILOAD values are calculated in percent of the theoretical maximum frame rate for the particular frame size. Please refer to the Test Configuration table for the percent values.")
            BinSearchParams = [('Frame Sizes', 'Search Max (fps)', 'Search Min (fps)', 'Start Point (fps)', 'Search Resolution (fps)')]
            for a,b,c,d,e in zip(self.FrameSizeList, self.reportMax, self.reportMin, self.reportStart, self.reportResolution):
                BinSearchParams.append((a,b,c,d,e))
            MyReport.InsertDetailedTable(BinSearchParams, columns=[1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch]) 
        
        MyReport.InsertPageBreak(inch) #Break if there is less than an inch left.
        MyReport.InsertHeader("Mesh Client Map")
        if len(self.meshHopClients) <= 6:          
            MyReport.InsertObject(self.MeshClientMap(self.meshGatewayClients, self.meshHopClients, self.FlowDirection, self.CardMap) )
        
        MyReport.InsertPageBreak()  #Forced break
        MyReport.InsertHeader("Methodology")
        MyReport.InsertParagraph(Method1)
        MyReport.InsertParagraph(Method2)
        MyReport.InsertParagraph(Method3)

        MyReport.InsertPageBreak(inch) #Break if there is less than an inch left.
        MyReport.InsertHeader("Detailed Results")
        if self.UserPassFailCriteria['user']=='True':
           flag=False
           Results_PF=[]
           for line in self.ResultsForCSVfile:
              if flag:
                   Results_PF.append(line)
              if len(line) == 0:
                   flag = True
           MyReport.InsertDetailedTable(Results_PF,columns=[0.5*inch, 0.4*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch,1*inch])
           notetext=""" Note:Abbreviations used are USC:User Specified Criteria and AT: Acceptable Throughput"""
           fail_count =0
           iteration_count=-1
           for temper in Results_PF:
               iteration_count=iteration_count+1
               if temper[-1]== 'FAIL':
                   fail_count=fail_count+1
               else:
                   pass
           #percent_fail= (float(fail_count)/iteration_count)* 100
           MyReport.InsertHeader( "User Specified P/F criteria" )
           userspecifiedtext= """  With this feature user can decide the criteria for pass or fail of the test.User can configure the allowable throughput and
                                also the mode of input in terms of percentage of Theoretical Throughput (or) directly he can mention in Mbps
                                based on which the test is evaluated to Pass/Fail"""
           MyReport.InsertParagraph (userspecifiedtext)
           ConfigParamters = [ ( 'Parameter', 'User specified Value', 'Overall result'),
                            ( 'Reference Parameter',"%s" %self.UserPassFailCriteria['ref_parameter'],'NA'),
                            ('Mode of Input',"%s" %self.UserPassFailCriteria['ref_tput_mode'],'NA'),
                            ('Acceptable Throughput',"%f" %float(self.UserPassFailCriteria['ref_value']),
 "Total:%s, PASS:%s and FAIL:%s"%(iteration_count,(iteration_count-fail_count),fail_count))]
           MyReport.InsertParameterTable(ConfigParamters, columns=[1.5*inch, 1.5*inch, 1.5*inch])
        else: 
              MyReport.InsertDetailedTable(self._ReportResults, columns=[0.5*inch, 0.4*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch, 0.8*inch])        

        RSSI_Data = self.AnalyizeRSSIdata(WaveEngine.ReadAPinformation())
        MyReport.InsertPageBreak( (0.95 + len(RSSI_Data) * 0.42) * inch )
        MyReport.InsertHeader("Access Point Information")
        MyReport.InsertParagraph(RSSIdetails)
        MyReport.InsertDetailedTable(RSSI_Data, columns=[1.5*inch, 0.60*inch, 1.25*inch, 1.55*inch, 0.40*inch, 0.40*inch, 0.40*inch])
        MyReport.InsertParagraph(RSSIdetails2)
        
        if len(self.InterferenceRate) > 1:
            MyReport.InsertPageBreak(inch * 1.50)
            MyReport.InsertHeader("Interference Information")
            MyReport.InsertParagraph(IGdetails)
            MyReport.InsertDetailedTable(self.InterferenceRate, columns=[1.3*inch, 0.9*inch, 1.3*inch, 1.3*inch, 1.2*inch])

        # other info section
        MyReport.InsertPageBreak(1.275*inch)
        MyReport.InsertHeader("Other Info")
        OtherParameters = []
        OtherParameters.append( ( 'Results Directory',  str( self.LoggingDirectory ) )  )
        for item in self.OtherInfoData.items():
            OtherParameters.append( item )
        OtherParameters.append( ( 'WaveTest Version',   str( action.getVclVersionStr() ) ) )
        MyReport.InsertGenericTable( OtherParameters , columns = [ 1.5*inch, 4.5*inch ] )
        # generate output
        self.BuildReport(MyReport)

    def run(self):
        # For debuging reports
        #print "\n--- New Run --- "
        #self.ReadResults()
        #self.BuildClientTable()
        #self.PrintReport()
        #return
   
        #Add code here to check setup parameters

        
        #Configure the test which includes configure chassid,ports,create clients and create flows (Configure Stage)
        #Setup the clients which includes connect clients,ARP and DHCP
        WaveEngine.OpenLogging(Path=self.LoggingDirectory, Detailed=self.DetailedFilename)
        self.ExitStatus = 0

        try:
            self.BuildClientTable()
            self.configurePorts()
            self.initailizeCSVfile()
            self.VerifyBSSID_MAC()
            self.createClients()
            self.connectClients()
#            self._clientLearning(self.ListOfClients, self.ClientLearningTime, self.ClientLearningRate)
            self.configureMeshFlows(perHop=False, connectBiflow=True)
            self.doArpExchanges()
            self.startTest(self.RealtimeCallback)
            self.SaveResults()
            self.PrintReport()
            self.ExitStatus= self.FinalResult
        except WaveEngine.RaiseException:
            WaveEngine.OutputstreamHDL('\n', WaveEngine.MSG_OK)
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            WaveEngine.OutputstreamHDL(str(exc_value), WaveEngine.MSG_ERROR)
            self.ExitStatus = 2
            self.SaveResults()
        except Exception, e:
            # some other error occured
            (exc_type, exc_value, exc_tb) = sys.exc_info()
            try:
                # print out nice traceback and error strings
                msg = "Fatal script error:\n"
                for text in traceback.format_exception(exc_type, exc_value, exc_tb):
                    msg += str(text)
                WaveEngine.OutputstreamHDL(str(msg), WaveEngine.MSG_ERROR)
            except Exception, e:
                # just incase the exception handler blows up
                print "ERROR:\n%s\n%s\n" % (str(msg), str(e))
            self.ExitStatus = 1
        self.CloseShop()
        return self.ExitStatus

    def getInfo(self):
        msg =  """The Aggregate Throughput mesh test identifies the maximum rate at which the system under test (SUT) can forward packets without loss across all the nodes in the mesh network.""" 
        
        return msg

    def getCharts(self):
        """
        Returns dictionary of all chart objects supported by this test.
        """
        self.ParseCVSdata(self.ResultsForCSVfile)
      
        # create charts
        charts = {}
        c = self.CreateThroughputGraph(640, 480, self._ReportList, self._ReportData)
        t = c.title
        charts[ t ] = c
        return charts

################################### Flowables #################################
# These are unique objects that a placed in the Report.PDF file.
    def CreateThroughputGraph(self, GraphWidth, GraphHeight, IndexList, Resultdata):
        graphTitle = "Throughput vs. Frame size"
        FrameSizeData = ()
        FrameSizeTheory = ()
        FrameSizeName = []
        for eachFrameSize in IndexList:
            (Theroy_FPS, Theroy_BPS, TotalOLOAD_FPS, TotalOLOAD_BPS, Count) = Resultdata[eachFrameSize]
            OLOAD_Mbps  = TotalOLOAD_BPS  / (int(Count) * 1000000.0)
            Theroy_Mbps = Theroy_BPS / 1000000.0
            FrameSizeData   += (OLOAD_Mbps, )
            FrameSizeTheory += (Theroy_Mbps, )
            FrameSizeName.append(str(eachFrameSize))

        return self.ThroughputGraph(GraphWidth, GraphHeight, FrameSizeName, [FrameSizeTheory, ], [FrameSizeData, ], graphTitle)

    class ThroughputGraph(FlowableGraph):
        def __init__(self, width, height, names, line, bar, title):
            FlowableGraph.__init__(self, width, height)
            self.dataNames = names
            self.dataLine  = line
            self.dataBar   = bar
            self.offset    = (defaultPageSize[0] - 2 * inch - width) / 2.0
            self.title     = title

        def _rawDraw(self, x, y):
            from reportlab.lib import colors 
            from reportlab.graphics.shapes import Drawing, Line, String, STATE_DEFAULTS
            from reportlab.graphics.charts.linecharts import HorizontalLineChart, Label
            from reportlab.graphics.charts.barcharts  import VerticalBarChart
            from reportlab.graphics.widgets.markers import makeMarker
            self.originX = x
            self.originY = y
            self._setScale([self.dataLine, self.dataBar])
            (x1, y1, Width, Height) = self._getGraphRegion(x, y)

            #Build the graph
            self.drawing = Drawing(self.width, self.height)

            #Size of the Axis
            SizeXaxis = 14
            SizeYaxis = 0.0
            for n in range(int(self.valueMax / self.valueStep) + 1):
                eachValue = self.valueMin + n * self.valueStep
                SizeYaxis = max(SizeYaxis, self._stringWidth(str("%.1f Mbps" % eachValue), STATE_DEFAULTS['fontName'], STATE_DEFAULTS['fontSize']) )

            bc = VerticalBarChart()
            SizeYaxis += bc.valueAxis.tickLeft
            bc.y = y1 - y + SizeXaxis
            bc.height = Height - SizeXaxis
            self.graphCenterY = bc.y + bc.height/2
            if self.validData:
                # add valid data
                bc.x = x1 - x + SizeYaxis
                bc.width  = Width  - SizeYaxis
                bc.data = self.dataBar
                bc.categoryAxis.categoryNames = self.dataNames
                # axis values
                bc.valueAxis.valueMin  = self.valueMin
                bc.valueAxis.valueMax  = self.valueMax
                bc.valueAxis.valueStep = self.valueStep
                self.graphCenterX = bc.x + bc.width/2
                # add value labels above bars
                bc.barLabelFormat = "%.2f"
                bc.barLabels.dy = 0.08*inch
                bc.barLabels.fontSize = 6
            else:
                # no valid data
                SizeYaxis = 16
                bc.x = x1 - x + SizeYaxis
                bc.width  = Width  - SizeYaxis
                self.graphCenterX = bc.x + bc.width/2
                bc.data = [ (0, ), ]
                bc.categoryAxis.categoryNames = [ '' ]
                bc.valueAxis.valueMin  = 0
                bc.valueAxis.valueMax  = 1
                bc.valueAxis.valueStep = 1
                Nodata = Label()
                Nodata.fontSize = 12
                Nodata.angle = 0
                Nodata.boxAnchor = 'c'
                Nodata.dx = self.graphCenterX
                Nodata.dy = self.graphCenterY
                Nodata.setText("NO VALID DATA")
                self.drawing.add(Nodata)
                
            # chart formatting
            (R,G,B) = VeriwaveYellow
            bc.bars[0].fillColor   = colors.Color(R,G,B)
            bc.valueAxis.labelTextFormat = "%.1f Mbps"
            bc.categoryAxis.labels.boxAnchor = 'ne'
            bc.categoryAxis.labels.dx = 8
            bc.categoryAxis.labels.dy = -2
            bc.categoryAxis.labels.angle = 0
            # add chart
            self.drawing.add(bc)

            # Add Legend in upper right corner
            legendHeight  = 9 
            legendX = bc.x + 5
            legendY = bc.y + bc.height - 12
            self.drawing.add(Line(legendX, legendY + 3 , legendX + 20, legendY + 3, strokeColor=bc.bars[0].fillColor, strokeWidth=3 ))
            self.drawing.add(String(legendX + 22, legendY, 'Measured', fontName='Helvetica', fontSize=8))
            legendY -= legendHeight

            # FIXME - Keith wants number on top of the bars
            self._drawLabels(self.title, "Frame Size", "")
        
            #Comment this portion out to remove the theoretical line from the graph
            if self.validData and len(self.dataLine[0]) > 0:
                DashArray = [2,2]
                # add horizontal line if only one datapoint
                if len(self.dataLine[0]) == 1:
                    yPos = bc.height * (self.dataLine[0][0] - bc.valueAxis.valueMin) / (bc.valueAxis.valueMax - bc.valueAxis.valueMin)
                    self.drawing.add(Line(bc.x, bc.y + yPos, bc.x + bc.width, bc.y + yPos, strokeColor=colors.red, strokeWidth=1, strokeDashArray = DashArray))
                # theoretical line
                lc = HorizontalLineChart()    
                lc.x = bc.x
                lc.y = bc.y
                lc.height = bc.height
                lc.width  = bc.width
                lc.valueAxis.valueMin  = self.valueMin
                lc.valueAxis.valueMax  = self.valueMax
                lc.valueAxis.valueStep = self.valueStep
                lc.valueAxis.visible   = False
                lc.data = self.dataLine
                # line format
                lc.lines[0].strokeColor = colors.red
                lc.lines[0].strokeDashArray = DashArray
                lc.lines[0].symbol = makeMarker('FilledDiamond')
                lc.joinedLines = 1
                self.drawing.add(lc)
                    
                # legend
                self.drawing.add(Line(legendX, legendY + 3, legendX + 20 , legendY + 3, strokeColor=colors.red, strokeWidth=1, strokeDashArray = DashArray))
                self.drawing.add(String(legendX + 22, legendY, 'Theory', fontName='Helvetica', fontSize=8))
                legendY -= legendHeight
            
            # all done

##################################### Main ###################################
if __name__=='__main__':
    # Commandline execution starts here
        
    # set up options parser.  -h or --help will print usage.
    usage = "usage: %prog [options] -f FILENAME"
    parser = OptionParser( usage )
    parser.add_option("-f", "--file", dest="filename",
                    help="read configuration from FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                    action="store_true", dest="quietmode", default=False,
                    help="don't print status messages to stdout")
    parser.add_option("-s", "--script",
                    action="store_true", dest="scriptmode", default=False,
                    help="don't run interactively")
    parser.add_option("-t", "--trials",
                    action="store", type="int", dest="trials", default=0,
                    help="override number of trials")
    (options, args) = parser.parse_args()
    # ...args is a list of extra arguments, like a wml config file.
    # options.scriptmode = True/False
    # options.quietmode = True/False
    # options.filename = string
    
    # Create the test
    userTest = Test()

    WaveEngine.SetOutputStream(PrintToConsole)
    if options.filename != None:
        userTest.loadFile( options.filename )
        
    # override options if we need to
    if options.trials:
        userTest.setTrials( options.trials )

    # Run the test
    userTest.run()
    sys.exit(userTest.ExitStatus)            
